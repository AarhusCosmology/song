#include "perturbations2.h"


// *** Shortcuts for the moments of the various species at second order

/* Define the photon temperature multipoles. Note that we set them to zero by default when
  the no-radiation approximation is switched on. */
#define I(l,m) ( ((abs(m)>l) || (l<0) || ((l)>ppw2->pv->l_max_g)) ? 0 : y[ppw2->pv->index_pt2_monopole_g + lm((l),(m))] )
#define dI(l,m) dy[ppw2->pv->index_pt2_monopole_g + lm((l),(m))]

/* Define the photon polarization multipoles.  We include a check on the E and B modes, so
  that they are non-zero only if polarization is requested.  This will allow us to write
  the photon temperature hierarchy in the same way regardless of whether polarization is on
  or off. */
#define E(l,m) ( ((ppt2->has_polarization2 == _FALSE_)||(abs(m)>l)||(l<0)||((l)>ppw2->pv->l_max_pol_g)) ? 0 : y[ppw2->pv->index_pt2_monopole_E + lm((l),(m))] )
#define dE(l,m) dy[ppw2->pv->index_pt2_monopole_E + lm((l),(m))]

#define B(l,m) ( ((ppt2->has_polarization2 == _FALSE_)||(abs(m)>l)||(l<0)||((l)>ppw2->pv->l_max_pol_g)) ? 0 : y[ppw2->pv->index_pt2_monopole_B + lm((l),(m))] )
#define dB(l,m) dy[ppw2->pv->index_pt2_monopole_B + lm((l),(m))]

/* Define the neutrinos multipoles */
#define N(l,m) ( ((abs(m) > l) || ((l)>ppw2->pv->l_max_ur)) ? 0 : y[ppw2->pv->index_pt2_monopole_ur + lm((l),(m))] )
#define dN(l,m) dy[ppw2->pv->index_pt2_monopole_ur + lm((l),(m))]


/* Define the baryon beta-moments */
#define b(n,l,m) y[ppw2->pv->index_pt2_monopole_b + nlm_b((n),(l),(m))]
#define db(n,l,m) dy[ppw2->pv->index_pt2_monopole_b + nlm_b((n),(l),(m))]

/* Define the CDM beta-moments */
#define cdm(n,l,m) y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm((n),(l),(m))]
#define dcdm(n,l,m) dy[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm((n),(l),(m))]


/* Shortcuts to the quadratic sources that form the right hand side of the second-order
  equations.  For the matter hierachies, these are the sum of the quadratic Liouville operator
  plus the quadratic collision term. */
#define dI_quad(l,m) ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_monopole_g + lm((l),(m))]
#define dE_quad(l,m) ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_monopole_E + lm((l),(m))]  
#define dB_quad(l,m) ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_monopole_B + lm((l),(m))]
#define db_quad(n,l,m) ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_monopole_b + nlm_b((n),(l),(m))]
#define dcdm_quad(n,l,m) ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm((n),(l),(m))]
#define dN_quad(l,m) ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_monopole_ur + lm((l),(m))]  

/* Shortcuts for the Liouville quadratic sources (precomputed in the workspace table) */
#define dI_ql_table(l,m) ppw2->liouville_quadsources_table[ppw2->index_ql2_monopole_g + lm((l),(m))][index_tau]
#define dE_ql_table(l,m) ppw2->liouville_quadsources_table[ppw2->index_ql2_monopole_E + lm((l),(m))][index_tau]
#define dB_ql_table(l,m) ppw2->liouville_quadsources_table[ppw2->index_ql2_monopole_B + lm((l),(m))][index_tau]
#define db_ql_table(n,l,m) ppw2->liouville_quadsources_table[ppw2->index_ql2_monopole_b + nlm_b((n),(l),(m))][index_tau]
#define dcdm_ql_table(n,l,m) ppw2->liouville_quadsources_table[ppw2->index_ql2_monopole_cdm + nlm_cdm((n),(l),(m))][index_tau]
#define dN_ql_table(l,m) ppw2->liouville_quadsources_table[ppw2->index_ql2_monopole_ur + lm((l),(m))][index_tau]

/* Shortcuts for the collisional quadratic sources (precomputed in the workspace table) */
#define dI_qc_table(l,m) ppw2->collision_quadsources_table[ppw2->index_qc2_monopole_g + lm((l),(m))][index_tau]
#define dE_qc_table(l,m) ppw2->collision_quadsources_table[ppw2->index_qc2_monopole_E + lm((l),(m))][index_tau]
#define dB_qc_table(l,m) ppw2->collision_quadsources_table[ppw2->index_qc2_monopole_B + lm((l),(m))][index_tau]
#define db_qc_table(n,l,m) ppw2->collision_quadsources_table[ppw2->index_qc2_monopole_b + nlm_b((n),(l),(m))][index_tau]

/* Shortcuts to access the Liouville quadratic sources (interpolated by perturb2_quadratic_sources_at_tau) */
#define dI_ql(l,m) ppw2->pvec_liouville_quadsources[ppw2->index_ql2_monopole_g + lm((l),(m))]
#define dE_ql(l,m) ppw2->pvec_liouville_quadsources[ppw2->index_ql2_monopole_E + lm((l),(m))]
#define dB_ql(l,m) ppw2->pvec_liouville_quadsources[ppw2->index_ql2_monopole_B + lm((l),(m))]
#define db_ql(n,l,m) ppw2->pvec_liouville_quadsources[ppw2->index_ql2_monopole_b + nlm_b((n),(l),(m))]
#define dcdm_ql(n,l,m) ppw2->pvec_liouville_quadsources[ppw2->index_ql2_monopole_cdm + nlm_cdm((n),(l),(m))]
#define dN_ql(l,m) ppw2->pvec_liouville_quadsources[ppw2->index_ql2_monopole_ur + lm((l),(m))]

/* Shortcuts to access the collisional quadratic sources (interpolated by perturb2_quadratic_sources_at_tau) */
#define dI_qc(l,m) ppw2->pvec_collision_quadsources[ppw2->index_qc2_monopole_g + lm((l),(m))]
#define dE_qc(l,m) ppw2->pvec_collision_quadsources[ppw2->index_qc2_monopole_E + lm((l),(m))]
#define dB_qc(l,m) ppw2->pvec_collision_quadsources[ppw2->index_qc2_monopole_B + lm((l),(m))]
#define db_qc(n,l,m) ppw2->pvec_collision_quadsources[ppw2->index_qc2_monopole_b + nlm_b((n),(l),(m))]







// *** Shorthands for the coupling coefficients
#define c_minus_12(l,m) ppw2->c_minus_product_12[lm(l,m)]
#define c_minus_21(l,m) ppw2->c_minus_product_21[lm(l,m)]
#define c_plus_12(l,m)  ppw2->c_plus_product_12[lm(l,m)]  
#define c_plus_21(l,m)  ppw2->c_plus_product_21[lm(l,m)]  
#define c_minus_11(l,m) ppw2->c_minus_product_11[lm(l,m)]
#define c_minus_22(l,m) ppw2->c_minus_product_22[lm(l,m)]
#define c_plus_11(l,m)  ppw2->c_plus_product_11[lm(l,m)]  
#define c_plus_22(l,m)  ppw2->c_plus_product_22[lm(l,m)]  

#define r_minus_12(l,m) ppw2->r_minus_product_12[lm(l,m)]
#define r_minus_21(l,m) ppw2->r_minus_product_21[lm(l,m)]
#define r_plus_12(l,m)  ppw2->r_plus_product_12[lm(l,m)]  
#define r_plus_21(l,m)  ppw2->r_plus_product_21[lm(l,m)] 
 
#define d_minus_12(l,m) ppw2->d_minus_product_12[lm(l,m)]
#define d_minus_21(l,m) ppw2->d_minus_product_21[lm(l,m)]
#define d_plus_12(l,m)  ppw2->d_plus_product_12[lm(l,m)]  
#define d_plus_21(l,m)  ppw2->d_plus_product_21[lm(l,m)]
#define d_minus_11(l,m) ppw2->d_minus_product_11[lm(l,m)]
#define d_minus_22(l,m) ppw2->d_minus_product_22[lm(l,m)]
#define d_plus_11(l,m)  ppw2->d_plus_product_11[lm(l,m)]  
#define d_plus_22(l,m)  ppw2->d_plus_product_22[lm(l,m)]  

#define d_zero_12(l,m)  ppw2->d_zero_product_12[lm(l,m)]  
#define d_zero_21(l,m)  ppw2->d_zero_product_21[lm(l,m)]  
#define d_zero_11(l,m)  ppw2->d_zero_product_11[lm(l,m)]  
#define d_zero_22(l,m)  ppw2->d_zero_product_22[lm(l,m)]  

#define k_minus_12(l,m) ppw2->k_minus_product_12[lm(l,m)]
#define k_minus_21(l,m) ppw2->k_minus_product_21[lm(l,m)]
#define k_plus_12(l,m)  ppw2->k_plus_product_12[lm(l,m)]  
#define k_plus_21(l,m)  ppw2->k_plus_product_21[lm(l,m)]  
#define k_minus_11(l,m) ppw2->k_minus_product_11[lm(l,m)]
#define k_minus_22(l,m) ppw2->k_minus_product_22[lm(l,m)]
#define k_plus_11(l,m)  ppw2->k_plus_product_11[lm(l,m)]  
#define k_plus_22(l,m)  ppw2->k_plus_product_22[lm(l,m)]  

#define k_zero_12(l,m)  ppw2->k_zero_product_12[lm(l,m)]  
#define k_zero_21(l,m)  ppw2->k_zero_product_21[lm(l,m)]  
#define k_zero_11(l,m)  ppw2->k_zero_product_11[lm(l,m)]  
#define k_zero_22(l,m)  ppw2->k_zero_product_22[lm(l,m)]  
  
  
// *** Shorthands for the first-order multipoles.

/* The 'tilde' suffix denotes any 1st-order quantity which is computed with
  the symmetry axis aligned with its wavemode.  For example, I_1_tilde(l) is
  the (l,0) 1st-order moment in k1, computed with k1 aligned with the z-axis. */

#define I_1_tilde(l) ( l < 0 ? 0 : pvec_sources1[ppt->index_qs_monopole_g + l] )
#define I_2_tilde(l) ( l < 0 ? 0 : pvec_sources2[ppt->index_qs_monopole_g + l] )

#define E_1_tilde(l) ( ((l < 0)||(ppt2->has_polarization2==_FALSE_)) ? 0 : pvec_sources1[ppt->index_qs_monopole_E + l] )
#define E_2_tilde(l) ( ((l < 0)||(ppt2->has_polarization2==_FALSE_)) ? 0 : pvec_sources2[ppt->index_qs_monopole_E + l] )

#define N_1_tilde(l) ( l < 0 ? 0 : pvec_sources1[ppt->index_qs_monopole_ur + l] )
#define N_2_tilde(l) ( l < 0 ? 0 : pvec_sources2[ppt->index_qs_monopole_ur + l] )







int perturb2_init(
     struct precision * ppr,
     struct background * pba,
     struct thermo * pth,
     struct perturbs * ppt,
     struct perturbs2 * ppt2
     )
{
  

  // ************************               Preparations             ***************************


  // =====================================
  // =        Preliminary checks         =
  // =====================================
  if (ppt2->has_perturbations2 == _FALSE_) {

    if (ppt2->perturbations2_verbose > 0)
      printf("No second-order sources requested. Perturbation2 module skipped.\n");

    return _SUCCESS_;
  }

  if (ppt2->perturbations2_verbose > 0)
    printf("Computing 2nd-order perturbations\n");




  // ============================================
  // =          Indices and k-samplings         =
  // ============================================
  /* Initialize all indices and arrays in the ppt2 structure using perturb2_indices_of_perturbs.
    In detail, this function does the following:
     - assigns tp2 indices
     - call perturb2_get_k_lists, that allocates and fills ppt2->k_size, ppt2->cosk1k2_size
     - fill ppt2->k, ppt2->cosk1k2
     - set ppt->k = ppt2->k   
  */
  class_call(perturb2_indices_of_perturbs(
            ppr,
            pba,
            pth,
            ppt,
            ppt2),
        ppt2->error_message,
        ppt2->error_message);




  // =========================================
  // =              Time sampling            =
  // =========================================

  /* The following function will:
    
      - define the common time sampling for all sources in ppt2->tau_sampling
      - define the time sampling for the first-order quadratic sources in ppt->tau_sampling_quadsources
      - allocate the k1, k2, cosk1k2 and tau levels of ppt2->sources
      
  */
  class_call(perturb2_timesampling_for_sources(
                 ppr,
                 pba,
                 pth,
                 ppt,
                 ppt2),
        ppt2->error_message,
        ppt2->error_message);




  // ==============================================
  // =          Solve 1st-order system            =
  // ==============================================

  /* We now compute the 1st-order perturbations in order to (i) fill ppt->quadsources with the 1st-order quantities
    needed to compute the quadratic sources to the 2nd-order equations, and (ii) fill ppt->sources with the line-
    of-sight sources needed to compute the first-order transfer functions and Cl's.

    Note that the k-sampling for the first order sources (ppt->k) is determined by perturb2_get_k_lists;
    the time sampling (ppt->tau_sampling_quadsources) is determined by perturb2_timesampling_for_sources */
  class_call (perturb_init (ppr,pba,pth,ppt), ppt->error_message, ppt2->error_message);
  
  /* Index for the mode to be considered at first order. As we shall assume the first-order
    vector and tensor modes are vanishing, we shall take it to be always equal to zero */
  ppt2->index_mode = ppt->index_md_scalars;
  
  /* For the time being, we assume that 1st-order adiabatic initial conditions were computed.
    In the future, this should be set in input.c and should depend on the ic_2nd_order option */
  ppt2->index_ic = ppt->index_ic_ad;


  /* If the user asked to output only the 1st-order transfer functions needed by the second-order module,
    then we stop here. */
  if (ppt2->has_early_transfers1_only == _TRUE_) {

    if (ppt2->perturbations2_verbose > 0)
      printf("Computed first-order early transfer functions, exiting with success.\n");
      
    return _SUCCESS_;
  }



  // ******        Adjust ppt->tau_sampling       *******
  
  /* The first-order time-sampling for the line-of-sight sources in CLASS goes all the way to today.  At
    second-order, we might be interested in recombination effects only, and thus limit the 2nd-order
    sampling to a smaller range. As we want to consider the same effects at first and second order, we adapt
    the end time of the first-order time sampling (ppt->tau_sampling) to the second-order one (ppt2->tau_sampling) */
  
  if (ppt2->match_final_time_los == _TRUE_) {
    if (ppt->tau_sampling[ppt->tau_size-1] != ppt2->tau_sampling[ppt2->tau_size-1]) {
  
      /* Test that CLASS sampling actually goes all the way to today */
      class_test (ppt->tau_sampling[ppt->tau_size-1] < pba->conformal_age,
                  ppt2->error_message,
                  "something went wrong: CLASS time sampling does not reach today");
  
  
      /* Find the index of ppt->tau_sampling corresponding to the last element of ppt2->tau_sampling */
      int index_tau = ppt->tau_size-1;
      while (ppt->tau_sampling[index_tau] > ppt2->tau_sampling[ppt2->tau_size-1]) --index_tau;
      ppt->tau_size = index_tau + 1;
  
      /* Some debug */
      // for (index_tau=0; index_tau < ppt->tau_size; ++index_tau) {
      //   printf("%13d %13g\n", index_tau, ppt->tau_sampling[index_tau]);
      // }
  
      if (ppt2->perturbations2_verbose > 1)
        printf("    * adjusted 1st-order LOS sources time sampling: %d times in the range tau=(%g,%g)\n",
          ppt->tau_size, ppt->tau_sampling[0], ppt->tau_sampling[ppt->tau_size-1]);
        
    } // end of if(ppt->tau_sampling[ppt->tau_size-1] != ppt2->tau_sampling[ppt2->tau_size-1])
  } // end of if(match_final_time_los)



  /* Print some info on the screen */
  if (ppt2->perturbations2_verbose > 0) {
    printf(" -> computing 2nd-order sources ");
    if (ppt->gauge == newtonian)
      printf("in Newtonian gauge\n");
    if (ppt->gauge == synchronous)
      printf("in synchronous gauge\n");
  }

  

  


  /* Apart from ppt2->sources, all the arrays needed by the subsequent modules have been filled.
    If the user requested to load the line of sight sources from disk, we can stop the execution of
    this module now without regrets. */
  if (ppt2->load_sources_from_disk == _TRUE_) {
    
    if (ppt2->perturbations2_verbose > 0)
      printf(" -> leaving perturbs2 module without having computed the line-of-sight sources, which will be read from disk\n");
    
    return _SUCCESS_;
  }





  // ************************               Allocate workspaces             ***************************



  // *** Parallelization variables

  /* Number of available omp threads (remains always one if no openmp) */
  int number_of_threads = 1;

  /* Index of each thread (reminas always zero if no openmp) */
  int thread = 0;

  /* Variables related to timing */
  double tstart, tstop, tspent;

  /* Flag for error management inside parallel regions */
  int abort;

  
  /* Find number of threads */
  #ifdef _OPENMP
  #pragma omp parallel
  {
    number_of_threads = omp_get_num_threads();
  }
  #endif
  

  #ifdef _OPENMP
  if (ppt2->perturbations2_verbose > 4)
    printf("In %s: Split computation of the source functions between %d threads\n",
     __func__,number_of_threads);
  #endif





  // *** Allocate a workspace per thread
    
  /* Array of workspaces.  Each workspace will contain shared quantities useful for functions
    throughout the module.  Note that each set of wavemodes (k1,k2,cosk1k2) will have a
    workspace assigned. (Note that pppw2 stands for pointer of pointers to perturb2_workspaces.) */
  struct perturb2_workspace ** pppw2;
  class_alloc(pppw2, number_of_threads*sizeof(struct perturb2_workspace*), ppt2->error_message);
  

  /* Beginning of parallel region */
  abort = _FALSE_;
  #pragma omp parallel shared(ppr,pba,pth,ppt,ppt2,pppw2) private(thread)
  {

    #ifdef _OPENMP
    thread = omp_get_thread_num();
    #endif
    
    /* Allocate arrays in workspace */
    class_alloc_parallel(
      pppw2[thread],
      sizeof(struct perturb2_workspace),
      ppt2->error_message);
    
    
    /* Initialize each workspace */
    class_call_parallel(perturb2_workspace_init(
              ppr,
              pba,
              pth,
              ppt,
              ppt2,
              pppw2[thread]
              ),
          ppt2->error_message,
          ppt2->error_message);
      
    
  } // end of parallel region
  
  if (abort == _TRUE_) return _FAILURE_;
  







  // ********************            Solve the differential system for (k1,k2,cosk1k2)             ********************


  /* Beginning of parallel region */
  abort = _FALSE_;    

  #pragma omp parallel                              \
    shared (pppw2,ppr,pba,pth,ppt,ppt2,abort)       \
    private (thread,tstart,tstop,tspent)
  {

    #ifdef _OPENMP
    thread = omp_get_thread_num();
    tspent = 0.;
    #endif

    /* Running indexes for wavenumbers and type */
    int index_k1, index_k2, index_cosk1k2, index_type;


    /* Three loops over k1, k2, cosk1k2 follow */
    #pragma omp for schedule (dynamic)
    for (index_k1 = 0; index_k1 < ppt2->k_size; ++index_k1) {                              /* Loop on k1 */
      


      // ***    Disk input/output management   ***

      /* Allocate the k1 level of ppt2->sources[index_type][index_k1][index_k2][index_cosk1k2][index_tau],
        the array used to store the results of the computations made in this module.  */
      class_call_parallel(perturb2_allocate_k1_level(ppt2, index_k1),
        ppt2->error_message, ppt2->error_message);




      #ifdef _OPENMP
      tstart = omp_get_wtime();
      #endif

      /* IMPORTANT: we are assuming that the quadratic sources are given in a form symmetric
        under exchange of k1 and k2.  Hence, we shall solve the system only for those k2 that
        are equal to or larger than k1, which means that the cycle on k2 will be starting
        from index_k1.*/
      for (index_k2 = index_k1; index_k2 < ppt2->k_size; ++index_k2) {                     /* Loop on k2 */

        for (index_cosk1k2 = 0; index_cosk1k2 < ppt2->cosk1k2_size; ++index_cosk1k2) {     /* Loop on cosk1k2 */
  
            class_call_parallel(perturb2_solve(
                  ppr,
                  pba,
                  pth,
                  ppt,
                  ppt2,
                  index_k1,
                  index_k2,
                  index_cosk1k2,
                  pppw2[thread]),
                ppt2->error_message,
                ppt2->error_message);
               
        }  // end of for(index_cosk1k2)

      } // end of for(index_k2)





      // *** Disk input/output management ***

      /* Save sources to disk, if requested */
      if (ppt2->store_sources_to_disk == _TRUE_) {

        class_call_parallel(perturb2_save_sources_to_disk(ppt2, index_k1),
            ppt2->error_message,
            ppt2->error_message);
            
        /* Free the memory associated with the line-of-sight sources for the considered k1.
          The next time we'll need them, we shall load them from disk. */
        class_call_parallel(perturb2_free_k1_level(ppt2, index_k1),
          ppt2->error_message, ppt2->error_message);

      } // end of if(store_sources_to_disk)

    }  // end of for(index_k1)

    #ifdef _OPENMP
    tstop = omp_get_wtime();
    tspent += tstop-tstart;
    #endif
    
    #pragma omp flush(abort)

  } if (abort == _TRUE_) return _FAILURE_; /* end of parallel region */

  #ifdef _OPENMP
  if (ppt2->perturbations2_verbose > 4)
    printf("In %s: time spent in parallel region (loop over cosk1k2's) = %6.3g s for thread %d\n",
     __func__,tspent,omp_get_thread_num());
  #endif

    
    
    
    
    

  // ***         Clean & exit       ***


   /* Free the workspaces */
  #pragma omp parallel shared(pppw2,pba,ppt2,abort) private(thread)
  {
    #ifdef _OPENMP
    thread=omp_get_thread_num();
    #endif
    
    class_call_parallel(perturb2_workspace_free(ppt2,pba,pppw2[thread]),
        ppt2->error_message,
        ppt2->error_message);
    
  } if (abort == _TRUE_) return _FAILURE_; /* end of parallel region */

  free(pppw2);


  if (ppt2->perturbations2_verbose > 1)
    printf(" -> filled ppt2->sources with %d values\n", ppt2->count_memorized_sources);
    
  // /* Check that the number of filled values corresponds to the number of allocated space */
  // if ((ppr->load_run == _FALSE_) || ((ppr->load_run == _TRUE_)&&(ppt2->store_sources_to_disk == _FALSE_)))
  //   class_test (ppt2->count_allocated_sources != ppt2->count_memorized_sources,
  //               ppt2->error_message,
  //               "there is a mismatch between allocated (%d) and used (%d) space!", ppt2->count_allocated_sources, ppt2->count_memorized_sources);


  /* Do not evaluate the subsequent modules if ppt2->has_early_transfers2_only == _TRUE_ */
  if (ppt2->has_early_transfers2_only == _TRUE_)
    ppt2->has_cls = _FALSE_;

  return _SUCCESS_;
       
}














/* Here we set the indices and arrays associated to the system of equations at second perturbative order. */
int perturb2_indices_of_perturbs(
        struct precision * ppr,
        struct background * pba,
        struct thermo * pth,
        struct perturbs * ppt,
        struct perturbs2 * ppt2
        )
{


  /* Allocate and fill the m-array, which contains the azimuthal moments to evolve.  We just copy
    it from the precision structure. */
  ppt2->m_size = ppr->m_size;
  int index_m;
  class_alloc(ppt2->m, ppt2->m_size*sizeof(int), ppt2->error_message);
  for (index_m=0; index_m<ppt2->m_size; ++index_m)
    ppt2->m[index_m] = ppr->m[index_m];


  /* Initialize the counter that will contain the number of values filled in
    ppt2->sources (debug only) */
  ppt2->count_memorized_sources = 0;



  // *******************          Assign  source type indices        ********************

  /* Count source types and assign corresponding indices.  Also set
    the flags has_cmb and has_lss. */
  int index_type = 0;
  ppt2->has_cmb = _FALSE_;
  ppt2->has_lss = _FALSE_;



  // *** Photons temperature sources
    
  if ((ppt2->has_cl_cmb_temperature == _TRUE_) || (ppt2->has_bi_cmb_temperature == _TRUE_)) {

    ppt2->has_source_t = _TRUE_;
    ppt2->has_cmb = _TRUE_;
    
    /* Test that the number of sources kept in the line of sight integration is
      smaller than the number of available 1st-order multipoles */
    class_test(ppr->l_max_g_2nd_order < ppr->l_max_t_los,
               ppt2->error_message,
               "you chose to compute more line-of-sight sources than evolved multipoles at first order. Make sure that l_max_t_los is smaller or equal than l_max_g.");
 
    /* The number of sources kept for the line of sight integration of the photon temperature multipoles
      is determined by the l_max_t_los parameter. */
    ppt2->n_sources_t = lm_number_of_elements(ppr->l_max_t_los, ppr->m_max_2nd_order);

    ppt2->index_tp2_t = index_type;                  /* The first moment of the hierarchy is the monopole l=0, m=0 */
    index_type += ppt2->n_sources_t;                 /* Make space for l>0 moments of the hierarchy */
    
  }
  else {
    ppt2->has_source_t = _FALSE_;
  }



  // *** Photons polarization sources
    
  if (ppt2->has_cl_cmb_polarization == _TRUE_) {

    /* E-mode polarization */
    ppt2->has_source_E = _TRUE_;
    ppt2->has_cmb = _TRUE_;

    /* B-mode polarization should be available only when m>0, TODO! */
    ppt2->has_source_B = _TRUE_;
    ppt2->has_cmb = _TRUE_;
    
    /* E-mode and B-mode sources not included yet, TODO! */

  }
  else {
    ppt2->has_source_E = _FALSE_;
    ppt2->has_source_B = _FALSE_;
  }


  /* Set the size of the sources to be stored */
  ppt2->tp2_size = index_type;

  if (ppt2->perturbations2_verbose > 1)
    printf("    * will compute index_tp=%d source terms\n", ppt2->tp2_size);


  // *** Allocate type-level of the arrays

  /* Allocate memory for the labels of the source types */
  class_alloc(ppt2->tp2_labels, ppt2->tp2_size*sizeof(char *), ppt2->error_message);
  for (index_type=0; index_type<ppt2->tp2_size; ++index_type)
    class_alloc(ppt2->tp2_labels[index_type], 64*sizeof(char), ppt2->error_message);


  /* For each mode, allocate the level corresponding to the needed sources
    and intial conditions */
  class_alloc(ppt2->sources, ppt2->tp2_size * sizeof(double ***), ppt2->error_message);







  // *******************           Fill k-arrays            **********************


  /* Define (k1,k2,cosk1k2) values, and allocate the ppt2->sources array accordingly */
  
  class_call(perturb2_get_k_lists(ppr,
         pba,
         pth,
         ppt,
         ppt2),
      ppt2->error_message,
      ppt2->error_message);






  // *******************           Create files for the sources           **********************
  

  /* If it does not exist, create the directory for the line of sight sources.  Also create/open
    the status file for the sources.  The status file is an ASCII file used to determine the values
    of k1 for which we already succesfully stored the sources. Finally, create a source file for each
    requested k1. */
  if (ppt2->store_sources_to_disk == _TRUE_) {
    
    sprintf(ppt2->sources_run_directory, "%s/sources", ppr->run_directory);
    mkdir (ppt2->sources_run_directory, 0777);

    /* Create/open the status file. The 'a+' mode means that if the file does not exist it will be created,
      but if it exist it won't be erased (append mode) */
    sprintf(ppt2->sources_status_path, "%s/sources_status_file.txt", ppr->run_directory);
    class_open(ppt2->sources_status_file, ppt2->sources_status_path, "a+", ppt2->error_message);
    

    // *** Allocate sources files
    int index_k1;

    if (ppt2->perturbations2_verbose > 2)
      if (ppr->load_run == _FALSE_) printf ("    * run_storage: will create %d files to store the sources\n", ppt2->k_size);
      else printf ("    * run_storage: will read the line of sight sources from %d files\n", ppt2->k_size);
    
    /* We are going to store the sources in n=k_size files, one for each requested k1 */
    class_alloc (ppt2->sources_run_files, ppt2->k_size*sizeof(FILE *), ppt2->error_message);
    class_alloc (ppt2->sources_run_paths, ppt2->k_size*sizeof(char *), ppt2->error_message);

    for(index_k1=0; index_k1<ppt2->k_size; ++index_k1) {
      
      /* The name of each sources file will have the k1 index in it */
      class_alloc (ppt2->sources_run_paths[index_k1], _FILENAMESIZE_*sizeof(char), ppt2->error_message);
      sprintf (ppt2->sources_run_paths[index_k1], "%s/sources_%03d.dat", ppt2->sources_run_directory, index_k1);
      
    } // end of loop on index_k1

  } // end of if(ppt2->store_sources_to_disk)





  
  // ********************           (l,m) indexing of arrays       *******************

  /*  Throughout this module, we shall store (access) Boltzmann hierarchies into (from)
    1-dimensional arrays.  To do so we assume that the angular indices (l,m) can assume
    the following values:
          0 <= l <= l_max ,   m in ppr->m .
    In principle, the azimuthal index 'm' can assume negative values, but we shall only consider
    positive ones since, with our conventions, the former can be derived from the latter.
    We shall address arrays in the following way:
        lm_multipole = array[index_monopole + lm(l,m)].
    where the function lm(l,m) is a pre-processor macro that accesses the array
    ppt2->lm_array[l][m], which we fill below.  Here is an example of what lm(l,m) does
    if ppr->m = [0,1]:
    
      lm(0,0) -> 0
      lm(1,0) -> 1
      lm(1,1) -> 2
      lm(2,0) -> 3
      lm(2,1) -> 4
      lm(2,2) -> ACCESSING UNALLOCATED MEMORY
      lm(3,0) -> 5
    
      A complication arises when indexing the first-order multipoles.  The (l,m)-th Boltzmann
    equation is sourced by terms quadratic in first-order perturbations with indices (l*,m*)
    in the following range:
        l-1 < l* < l+1 ,   m-1 < m* < m+1   for Newtonian gauge
        l-3 < l* < l+3 ,   m-3 < m* < m+3   for synchronous gauge.
    We label the extra term (1 for NG, 3 for SG) as 'lm_extra', and we create an ad hoc array
    called 'lm_array_quad' to index the arrays that need to have an extended (l,m) range. Examples
    of such arrays are 
        ppw2->rotation_1, ppw2->rotation_2, ppw2->rotated_multipoles_g_1, ppw2->rotated_multipoles_g_2
    and should be accessed as
        lm_multipole = array[index_monopole + lm_quad(l,m)].
    Again, 'lm_quad(l,m)' is just a pre-processor macro linked to lm_array_quad[l][m].
  
  */
  
  int l, m;

  /* Obtain the maximum 'l' that we need to index in this module */
  int l_max = ppr->l_max_g_2nd_order;
  if (pba->has_ur == _TRUE_) l_max = max(l_max, ppr->l_max_ur_2nd_order);
  if (ppt2->has_polarization2 == _TRUE_) l_max = max(l_max, ppr->l_max_pol_g_2nd_order);
  if ((ppt2->has_cls==_TRUE_)||(ppt2->has_bispectra==_TRUE_)) l_max = max(l_max, ppr->l_max_t_los);
  ppt2->l_max = l_max;
    
  /* We need the rotation factors up to l=l_max, plus a number that is 1 for 
    Newtonian gauge and 3 for synchronous gauge.  The same for the azimuthal number 'm'.
    The reason for this is that the angular dependence of the quadratic sources in
    Boltzmann equation is much more complex in synchronous gauge than in Newtonian gauge. */
  int m_max = ppr->m_max_2nd_order;
  int largest_l = ppt2->largest_l = l_max + ppt2->lm_extra;
  int largest_m = ppt2->largest_m = m_max + ppt2->lm_extra;  


   // *** Fill the lm_array's
   
  /* Note that the following arrays are accessed only by the preprocessor macros
    lm(l,m) and lm_quad(l,m), defined in common.h. */

  /* Fill ppt2->lm_array, used to index the (l,m) hierarchies. For example,
    y[index_monopole + lm_array[l][m]] will return the value of the (l,m)-th multipole. */
  class_calloc(ppt2->lm_array, largest_l+1, sizeof(int*), ppt2->error_message);    
  for(l=0; l<=ppt2->largest_l; ++l) {

    class_calloc(ppt2->lm_array[l], min(l,m_max)+1, sizeof(int), ppt2->error_message);

    for(m=0; m<=min(l,m_max); ++m)
      ppt2->lm_array[l][m] = lm_offset(l,m,m_max);
  }
  
  /* Fill ppt2->lm_array_quad', used to index the (l,m) rotated multipoles.  We use a different array
   because we need such multipoles to be indexed up to 'l_max + lm_extra' and 'm_max + lm_extra'.
   Example: rotation_1[index_monopole + lm_array_quad[l][m]]. */
  class_calloc(ppt2->lm_array_quad, largest_l+1, sizeof(int*), ppt2->error_message);
  for(l=0; l<=largest_l; ++l) {

    class_calloc(ppt2->lm_array_quad[l], min(l,largest_m)+1, sizeof(int), ppt2->error_message);

    for(m=0; m<=min(l,largest_m); ++m)
      ppt2->lm_array_quad[l][m] = lm_offset(l,m,largest_m);
  }


  
  return _SUCCESS_;

}




/**
 * Determine the (k1,k2,cosk1k2) grid where the 2nd-order system of equations will be solved.
 * The following fields will be written:
 *   ppt2->k, ppt2->cosk1k2, ppt->k, ppt->k_size, ppt->k_size_cl
 */
int perturb2_get_k_lists(
          struct precision * ppr,
          struct background * pba,
          struct thermo * pth,
          struct perturbs * ppt,
          struct perturbs2 * ppt2
          )
{



  // ******************         Second-order grid for k1 and k2          ********************

  // *** Limits and sized of wavemode arrays

  /* Sizes */
  ppt2->k_size = ppr->k_size_scalars;
  ppt2->cosk1k2_size = ppr->cosk1k2_size_scalars;
      
  /* Minima */
  ppt2->k_min = ppr->k_min_scalars;
  ppt2->cosk1k2_min = ppr->cosk1k2_min_scalars;    

  /* Maxima */
  ppt2->k_max = ppr->k_max_scalars;
  ppt2->cosk1k2_max = ppr->cosk1k2_max_scalars;    
 


  
  // *** Allocate and fill the wavemode arrays
  
  /* k1 and k2 are analogues to the 1st-order k */
  class_alloc (ppt2->k, ppt2->k_size*sizeof(double), ppt2->error_message);
  
  if (ppt2->k_sampling == lin_k_sampling)
    lin_space (ppt2->k, ppt2->k_min, ppt2->k_max, ppt2->k_size);
  else if (ppt2->k_sampling == log_k_sampling)
    log_space (ppt2->k, ppt2->k_min, ppt2->k_max, ppt2->k_size);
  
  /* We sample the cosine between k1 and k2 linearly. */
  class_alloc (ppt2->cosk1k2, ppt2->cosk1k2_size*sizeof(double), ppt2->error_message);
  lin_space (ppt2->cosk1k2, ppt2->cosk1k2_min, ppt2->cosk1k2_max, ppt2->cosk1k2_size);





  // ******************         First-order k-grid          ********************


  /* The 1st-order system must be solved for the k-values needed at second-order */
  class_alloc (ppt->k_size, sizeof(double), ppt2->error_message);
  ppt->k_size[0] = ppt2->k_size;

  class_alloc (ppt->k_size_cl, sizeof(double), ppt2->error_message);
  ppt->k_size_cl[0] = ppt2->k_size;

  class_alloc (ppt->k, sizeof(double *), ppt2->error_message);
  ppt->k[0] = ppt2->k;    


  /* Some debug */
  // int index_k1 = 20;
  // int index_k2 = 85;
  // int index_cosk1k2 = 22;
  // printf ("k1=%.20f, k2=%.20f, cosk1k2=%.20f\n", ppt2->k[index_k1], ppt2->k[index_k2], ppt2->cosk1k2[index_cosk1k2]);


  return _SUCCESS_;

}








/**
 * Define time-sampling for the source terms.
 * Here allocate and fill ppt2->tau_sampling, and we allocate ppt2->sources.
 */
int perturb2_timesampling_for_sources(
             struct precision * ppr,
             struct background * pba,
             struct thermo * pth,
             struct perturbs * ppt,
             struct perturbs2 * ppt2
             )
{

  /* Temporary arrays used to store background and thermodynamics quantities */
  double *pvecback, *pvecthermo;
  class_alloc (pvecback, pba->bg_size*sizeof(double), ppt2->error_message);
  class_alloc (pvecthermo, pth->th_size*sizeof(double), ppt2->error_message);
  int dump;


  // ==================================================================
  // =                 Custom 2nd-order time sampling                 =
  // ==================================================================
  
  /* If the user specified a custom time-sampling through the parameter files, just use that */
  if (ppt2->has_custom_timesampling == _TRUE_) {

    ppt2->tau_size = ppt2->custom_tau_size;

    /* If the user set the custom end-time to 0, we assume that he wants to compute the sources
      all the way to today */
    ppt2->custom_tau_end = (ppt2->custom_tau_end == 0 ? pba->conformal_age : ppt2->custom_tau_end);

    /* Allocate and fill ppt2->timesampling using the custom settings */
    class_alloc (ppt2->tau_sampling, ppt2->tau_size*sizeof(double), ppt2->error_message);
  
    /* Linear sampling */
    if (ppt2->custom_tau_mode == lin_tau_sampling) {
      lin_space(ppt2->tau_sampling, ppt2->custom_tau_ini, ppt2->custom_tau_end, ppt2->tau_size);
    }
    /* Logarithmic sampling */
    else if (ppt2->custom_tau_mode == log_tau_sampling) {
      log_space(ppt2->tau_sampling, ppt2->custom_tau_ini, ppt2->custom_tau_end, ppt2->tau_size);
    }
  } // end of if (has_custom_timesampling)





  // ==================================================================
  // =                Standard 2nd-order time sampling                =
  // ==================================================================

  /* General case where we integrate the system up to today.  This is the case when the user asked to include the
    metric or lensing terms in the line-of-sight integral, which are important all the way up to today.  
    We use the same time-sampling technique as in standard CLASS, who is optimized to sample the visibility
    function and the late ISW regime. For details, please refer to the function perturb_timesampling_for_sources. */
  else {


    // ******            Determine size of ppt2->tau_sampling              *******


    /* Using bisection, search time tau such that the ratio of thermo to Hubble time scales
      tau_c/tau_h=aH/kappa' is equal to start_sources_at_tau_c_over_tau_h */  

    /* The lower limit for the first sampling point is when the universe stops being opaque */
    double tau_lower = pth->tau_ini;

    class_call (background_at_tau(pba,
                 tau_lower, 
                 pba->short_info, 
                 pba->inter_normal, 
                 &dump, 
                 pvecback),
      pba->error_message,
      ppt2->error_message);
  
    class_call (thermodynamics_at_z(pba,
                  pth,
                  1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                  pth->inter_normal,
                  &dump,
                  pvecback,
                  pvecthermo),
      pth->error_message,
      ppt2->error_message);
  
    class_test (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_H]/pvecthermo[pth->index_th_dkappa] > 
                  ppr->start_sources_at_tau_c_over_tau_h,
                ppt2->error_message,
                "your choice of initial time for computing sources is inappropriate: it corresponds to an earlier time than the one at which the integration of thermodynamical variables started (tau=%g). You should increase either 'start_sources_at_tau_c_over_tau_h' or 'recfast_z_initial'\n",
                  tau_lower);
     
    /* The upper limit is when the visibility function peaks */
    double tau_upper = pth->tau_rec;
    
    class_call (background_at_tau(pba,
                  tau_upper, 
                  pba->short_info, 
                  pba->inter_normal, 
                  &dump, 
                  pvecback),
      pba->error_message,
      ppt2->error_message);
  
    class_call (thermodynamics_at_z(pba,
                  pth,
                  1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                  pth->inter_normal,
                  &dump,
                  pvecback,
                  pvecthermo),
      pth->error_message,
      ppt2->error_message);

    class_test (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_H]/pvecthermo[pth->index_th_dkappa] <
                  ppr->start_sources_at_tau_c_over_tau_h,
                ppt2->error_message,
                "your choice of initial time for computing sources is inappropriate: it corresponds to a time after recombination. You should decrease 'start_sources_at_tau_c_over_tau_h'\n");
    
    double tau_mid = 0.5*(tau_lower + tau_upper);
  
    while (tau_upper - tau_lower > ppr->tol_tau_approx) {

      class_call (background_at_tau(pba,
                    tau_mid, 
                    pba->short_info, 
                    pba->inter_normal, 
                    &dump, 
                    pvecback),
        pba->error_message,
        ppt2->error_message);
    
      class_call (thermodynamics_at_z(pba,
                    pth,
                    1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                    pth->inter_normal,
                    &dump,
                    pvecback,
                    pvecthermo),
        pth->error_message,
        ppt2->error_message);
    
    
      if (pvecback[pba->index_bg_a]*pvecback[pba->index_bg_H]/pvecthermo[pth->index_th_dkappa] > 
        ppr->start_sources_at_tau_c_over_tau_h)

        tau_upper = tau_mid;

      else
        tau_lower = tau_mid;

      tau_mid = 0.5*(tau_lower + tau_upper);
    
    }

    double tau_ini = tau_mid;

    int counter = 1;

    /* The next sampling point is determined by the lowest of two timescales: the time variation of the
      visibility function, and the acceleration parameter.  Schematically:
      
        next sampling point = previous + ppr->perturb_sampling_stepsize_2nd_order * timescale_source, where:

        timescale_source1 = g/g_dot
        timescale_source2 = sqrt |a_dot_dot/a - Hc^2|
        timescale_source = 1 / (1/timescale_source1 + 1/timescale_source2)
    */

    double tau = tau_ini;

    while (tau < pba->conformal_age) {

      class_call (background_at_tau(pba,
                    tau, 
                    pba->short_info, 
                    pba->inter_normal, 
                    &dump, 
                    pvecback),
        pba->error_message,
        ppt2->error_message);

      class_call (thermodynamics_at_z(pba,
                    pth,
                    1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                    pth->inter_normal,
                    &dump,
                    pvecback,
                    pvecthermo),
        pth->error_message,
        ppt2->error_message);

      /* Variation rate of thermodynamics variables */
      double rate_thermo = pvecthermo[pth->index_th_rate];
    
      /* Variation rate of metric due to late ISW effect (important at late times) */
      double a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      double a_primeprime_over_a = pvecback[pba->index_bg_H_prime] * pvecback[pba->index_bg_a] + 2*a_prime_over_a*a_prime_over_a;
      double rate_isw_squared = fabs (2*a_primeprime_over_a - a_prime_over_a*a_prime_over_a);

      /* Compute rate */
      double timescale_source = sqrt(rate_thermo*rate_thermo + rate_isw_squared);


      /* Check it is non-zero */
      class_test(timescale_source == 0., ppt2->error_message, "null evolution rate, integration is diverging");

      /* Compute inverse rate */
      timescale_source = 1./timescale_source;

      class_test(fabs(ppr->perturb_sampling_stepsize_2nd_order*timescale_source/tau) < ppr->smallest_allowed_variation,
           ppt2->error_message,
           "integration step =%e < machine precision : leads either to numerical error or infinite loop", ppr->perturb_sampling_stepsize_2nd_order*timescale_source);

      tau = tau + ppr->perturb_sampling_stepsize_2nd_order * timescale_source; 
      counter++;

    }

    /* Infer total number of time steps, ppt2->tau_size */
    ppt2->tau_size = counter;

    /* Allocate array of time steps, ppt2->tau_sampling[index_tau] */
    class_alloc (ppt2->tau_sampling, ppt2->tau_size * sizeof(double), ppt2->error_message);



    // ******            Fill  ppt2->tau_sampling              *******

    /* First sampling point = when the universe stops being opaque */
    counter = 0;
    ppt2->tau_sampling[counter] = tau_ini;
    tau = tau_ini;

    while (tau < pba->conformal_age) {
    
      class_call (background_at_tau(pba,
                    tau, 
                    pba->short_info, 
                    pba->inter_normal, 
                    &dump, 
                    pvecback),
        pba->error_message,
        ppt2->error_message);

      class_call (thermodynamics_at_z(pba,
                    pth,
                    1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                    pth->inter_normal,
                    &dump,
                    pvecback,
                    pvecthermo),
        pth->error_message,
        ppt2->error_message);



      /* Variation rate of thermodynamics variables */
      double rate_thermo = pvecthermo[pth->index_th_rate];

      /* Variation rate of metric due to late ISW effect (important at late times) */
      double a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      double a_primeprime_over_a = pvecback[pba->index_bg_H_prime] * pvecback[pba->index_bg_a] + 2*a_prime_over_a*a_prime_over_a;
      double rate_isw_squared = fabs(2*a_primeprime_over_a - a_prime_over_a*a_prime_over_a);

      /* Compute rate */
      double timescale_source = sqrt(rate_thermo*rate_thermo + rate_isw_squared);

      /* Check it is non-zero */
      class_test(timescale_source == 0., ppt2->error_message, "null evolution rate, integration is diverging");

      /* Compute inverse rate */
      timescale_source = 1./timescale_source;

      class_test(fabs(ppr->perturb_sampling_stepsize_2nd_order*timescale_source/tau) < ppr->smallest_allowed_variation,
           ppt2->error_message,
           "integration step =%e < machine precision : leads either to numerical error or infinite loop", ppr->perturb_sampling_stepsize_2nd_order*timescale_source);

      tau = tau + ppr->perturb_sampling_stepsize_2nd_order*timescale_source; 
      counter++;
      ppt2->tau_sampling[counter] = tau;

    }

    /* Last sampling point = exactly today */
    ppt2->tau_sampling[counter] = pba->conformal_age;
  
    /* Some debug - print out time sampling for the 2nd-order line of sight sources */
    // for (counter=0; counter < ppt2->tau_size-1; ++counter) {
    //   fprintf(stderr, "%10d %11g\n", counter, ppt2->tau_sampling[counter]);
    // }
  

    /* If we are only interested into the scattering sources of the line-of-sight integral, then
      we can stop integrating the  system just after recombination.  In this case, we cut
      the standard time-sampling at some suitable time, which we define as the time when the
      visibility function is 'ppt2->visibility_max_to_end_ratio' times smaller than its maximum
      value. */

    // ==================================================================
    // =          Recombination only 2nd-order time sampling            =
    // ==================================================================

    if (ppt2->has_recombination_only == _TRUE_) {

      // ***  Find maximum value of the visibiliy function  ****
        
      /* Redshift and conformal time where the visibility function 'g' peaks */
      double tau_rec;
      double z_max = pth->z_rec;
      class_call (background_tau_of_z (pba, z_max, &tau_rec), pba->error_message, ppt2->error_message);

      /* Interpolate background quantities */
      class_call (background_at_tau(
                    pba,
                    tau_rec, 
                    pba->normal_info, 
                    pba->inter_normal, 
                    &dump, 
                    pvecback),
        pba->error_message,
        ppt2->error_message);


      /* Interpolate thermodynamics quantities */
      class_call (thermodynamics_at_z(
                    pba,
                    pth,
                    z_max,
                    pth->inter_normal,
                    &dump,
                    pvecback,
                    pvecthermo),
       pth->error_message,
       ppt2->error_message);

      /* Maximum of the visibility function */
      double g_max = pvecthermo[pth->index_th_g];
    
      /* Value of the visibility function when recombination ends */
      double g_end = g_max/ppt2->recombination_max_to_end_ratio;


      // *** Find time index corresponding to the maximum ***

      int index_tau = 0;

      for (index_tau=0; index_tau < ppt2->tau_size; ++index_tau) {

        /* We want to find a time after recombination, not before */
        if (ppt2->tau_sampling[index_tau] < tau_rec)
          continue;

        /* Interpolate background quantities */
        class_call (background_at_tau(
                      pba,
                      ppt2->tau_sampling[index_tau], 
                      pba->normal_info, 
                      pba->inter_normal, 
                      &dump, 
                      pvecback),
          pba->error_message,
          ppt2->error_message);

        double a = pvecback[pba->index_bg_a];

        /* Interpolate thermodynamics quantities */
        class_call (thermodynamics_at_z(
                      pba,
                      pth,
                      1./a-1.,  /* redshift z=1/a-1 */
                      pth->inter_normal,
                      &dump,
                      pvecback,
                      pvecthermo),
          pth->error_message,
          ppt2->error_message);
      
        /* If we reached the time where the visibility function is smaller than g_end, we decide
          that recombination is over and resize the time-sampling vector accordingly */
        if (pvecthermo[pth->index_th_g] <= g_end) {

          ppt2->tau_size = index_tau + 1;
          break;
        }

      } // end of for(index_tau)


      /* Some debug */
      // printf("z_rec = %g\n", pth->z_rec);
      // printf("tau_rec = %g\n", tau_rec);
      // printf("g_max = %g\n", g_max);
      // printf("g_end = %g\n", g_end);

    } // end of if (ppt2->has_recombination_only==_TRUE_)


  } // end of if (has_custom_timesampling == _FALSE_)



  




  // ***************              Allocate ppt2->sources         *****************

  /* Loop over types, k1, k2, and cosk1k2.  For each combination of them, allocate the tau level. */

  int index_type, index_k1, index_k2, index_cosk1k2;

  if(ppt2->perturbations2_verbose > 2)
    printf(" -> allocating memory for the sources array\n");
  
  /* Keep track of memory usage */
  ppt2->count_allocated_sources = 0;
  
  /* Allocate k1 level.  The further levels (k2, cosk1k2 and time) will be allocated when needed */
  for (index_type = 0; index_type < ppt2->tp2_size; index_type++)
    class_alloc(ppt2->sources[index_type], ppt2->k_size * sizeof(double ***), ppt2->error_message);
  
  /* Allocate and initialize the logical array that keeps track of the memory state of ppt2->sources */
  class_calloc(ppt2->has_allocated_sources, ppt2->k_size, sizeof(short), ppt2->error_message);





  // ======================================================================
  // =                Custom quadratic sources time sampling              =
  // ======================================================================

  /* If the user specified a custom time-sampling through the parameter files, just use that */
  if (ppt->has_custom_timesampling_for_quadsources == _TRUE_) {

    ppt->tau_size_quadsources = ppt->custom_tau_size_quadsources;

    /* If the user set the custom end-time to 0, we assume that he wants to compute the sources
      all the way to today */
    ppt->custom_tau_end_quadsources = (ppt->custom_tau_end_quadsources == 0 ? pba->conformal_age : ppt->custom_tau_end_quadsources);

    /* Allocate and fill ppt->tau_sampling_quadsources using the custom settings */
    class_alloc (ppt->tau_sampling_quadsources, ppt->tau_size_quadsources*sizeof(double), ppt2->error_message);
  
    /* Linear sampling */
    if (ppt->custom_tau_mode_quadsources == lin_tau_sampling) {
      lin_space(ppt->tau_sampling_quadsources, ppt->custom_tau_ini_quadsources,
        ppt->custom_tau_end_quadsources, ppt->tau_size_quadsources);
    }
    /* Logarithmic sampling */
    else if (ppt->custom_tau_mode_quadsources == log_tau_sampling) {
      log_space(ppt->tau_sampling_quadsources, ppt->custom_tau_ini_quadsources,
        ppt->custom_tau_end_quadsources, ppt->tau_size_quadsources);
    }
      
  } // end of if (has_custom_timesampling_for_quadsources==_TRUE_)


  // ======================================================================
  // =              Standard quadratic sources time sampling              =
  // ======================================================================

  else {
  

    // ******      Determine size of ppt->tau_sampling_quadsources     *******

    /* Determine how many sample points we need for the quadratic sources, based on the parameter
      ppr->perturb_sampling_stepsize_quadsources. */

    /* We start sampling the quadratic sources at the time when we start to evolve the second-order
      system.  */
    class_test (ppt2->tau_start_evolution == 0,
                ppt2->error_message,
                "a variable starting integration time is not supported yet.  To implement it, you should first determine a starting integration time for the first-order system, maybe by using the bisection technique applied to k_min");

    double tau_ini_quadsources = min (ppt2->tau_sampling[0], ppt2->tau_start_evolution);
  
    /* We stop sampling the quadratic sources when we do not need the second-order sources */
    double tau_end_quadsources = ppt2->tau_sampling[ppt2->tau_size-1];

    /* In order to determine the next sampling point, we do similarly to what is done 
      in the first-order CLASS: we determine a timescale for the evolution and choose
      the next sample point at a given time based on that timescale at that time.  The
      timescale we choose is 1/aH as it is the evolution timescale of the system.
      Schematically, we shall choose the next point as:    
      
        next sampling point = previous + ppr->perturb_sampling_stepsize_quadsources * 1/aH
      
       It is interesting to note that, as 1/aH is proportional to tau, the above sampling is
       basically a logarithmic sampling.  The sampling becomes more dense during matter
       domination because the coefficient between aH and 1/tau is larger than the same
       coefficient during radiation domination. */
    double tau = tau_ini_quadsources;
    int dump=0, counter=1;

    while (tau < tau_end_quadsources) {

      class_call (background_at_tau(
                    pba,
                    tau, 
                    pba->short_info, 
                    pba->inter_normal, 
                    &dump, 
                    pvecback),
        pba->error_message,
        ppt2->error_message);
 
      class_call (thermodynamics_at_z(pba,
                    pth,
                    1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                    pth->inter_normal,
                    &dump,
                    pvecback,
                    pvecthermo),
        pth->error_message,
        ppt2->error_message);


      /* We set the variation rate as given by the Hubble time */
      double a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      double timescale_source = a_prime_over_a;

      /* Check it is non-zero */
      class_test (timescale_source == 0., ppt2->error_message, "null evolution rate, integration is diverging");

      /* compute inverse rate */
      timescale_source = 1./timescale_source;

      class_test(fabs(ppr->perturb_sampling_stepsize_quadsources*timescale_source/tau) < ppr->smallest_allowed_variation,
           ppt2->error_message,
           "integration step =%e < machine precision : leads either to numerical error or infinite loop",ppr->perturb_sampling_stepsize*timescale_source);

      tau = tau + ppr->perturb_sampling_stepsize_quadsources * timescale_source; 
      ++counter;

    } // end of cycle on times

    /* Infer total number of time steps, ppt->tau_size_quadsources */
    ppt->tau_size_quadsources = counter;

    /* Allocate array of time steps, ppt->tau_sampling_quadsources[index_tau] */
    class_alloc (ppt->tau_sampling_quadsources, ppt->tau_size_quadsources * sizeof(double), ppt2->error_message);




    // ******      Fill ppt->tau_sampling_quadsources     *******
    
    counter = 0;
    ppt->tau_sampling_quadsources[counter] = tau_ini_quadsources;
    tau = tau_ini_quadsources;
  
    while (tau < tau_end_quadsources) {
    
      class_call (background_at_tau(pba,
                    tau, 
                    pba->short_info, 
                    pba->inter_normal, 
                    &dump, 
                    pvecback),
        pba->error_message,
        ppt2->error_message);
  
      class_call (thermodynamics_at_z(pba,
                    pth,
                    1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
                    pth->inter_normal,
                    &dump,
                    pvecback,
                    pvecthermo),
        pth->error_message,
        ppt2->error_message);
  
      double a_prime_over_a = pvecback[pba->index_bg_H] * pvecback[pba->index_bg_a];
      double timescale_source = a_prime_over_a;
  
      /* Check it is non-zero */
      class_test(timescale_source == 0., ppt2->error_message, "null evolution rate, integration is diverging");
  
      /* Compute inverse rate */
      timescale_source = 1./timescale_source;
  
      class_test(fabs(ppr->perturb_sampling_stepsize_quadsources*timescale_source/tau) < ppr->smallest_allowed_variation,
           ppt2->error_message,
           "integration step =%e < machine precision : leads either to numerical error or infinite loop",ppr->perturb_sampling_stepsize_quadsources*timescale_source);
  
      tau = tau + ppr->perturb_sampling_stepsize_quadsources*timescale_source; 
      counter++;
      ppt->tau_sampling_quadsources[counter] = tau;
  
    }
  
    /* The last sampling point is the last sampling point of the second-order sources */
    ppt->tau_sampling_quadsources[counter] = tau_end_quadsources;
  
  } // end of if(has_custom_timesampling_for_quadsources==_FALSE_)


  /* Some debug - print the time sampling for the quadratic sources */
  // {
  //   int index_tau;
  //   for (index_tau=0; index_tau < ppt->tau_size_quadsources; ++index_tau)
  //     printf("%12d %17.7g\n", index_tau, ppt->tau_sampling_quadsources[index_tau]);
  // }

  /* Some debug - print the time sampling for the 2nd-order LOS sources */
  // {
  //   int index_tau;
  //   for (index_tau=0; index_tau < ppt2->tau_size; ++index_tau)
  //     printf("%12d %17.7g\n", index_tau, ppt2->tau_sampling[index_tau]);
  // }


  /* Check that the time range chosen to sample the 2nd-order sources is compatible with the
    range we chosen to compute the 1st-order ones */
  class_test(ppt2->tau_sampling[0] < ppt->tau_sampling_quadsources[0],
    ppt2->error_message,
    "the requested initial time for the sampling of the 2nd-order sources is too low.");

  class_test(ppt2->tau_sampling[ppt2->tau_size-1] > ppt->tau_sampling_quadsources[ppt->tau_size_quadsources-1],
    ppt2->error_message,
    "the requested final time for the sampling of the 2nd-order sources is too high.");










  // =============================================================================
  // =                         Print important information                       =
  // =============================================================================
  if (ppt2->perturbations2_verbose > 1) {
    
    /* We want to give information on the time-sampling both in time and in scale-factor */
    double a_ini, a_end, y_ini, y_end;
        
    /* Interpolate background quantities */
    int dump;

    class_call (background_at_tau(
                  pba,
                  ppt2->tau_sampling[0], 
                  pba->normal_info, 
                  pba->inter_normal, 
                  &dump, 
                  pvecback),
      pba->error_message,
      ppt2->error_message);

    a_ini = pvecback[pba->index_bg_a];
    y_ini = log10(a_ini/pba->a_eq);

    class_call (background_at_tau(
                  pba,
                  ppt2->tau_sampling[ppt2->tau_size-1], 
                  pba->normal_info, 
                  pba->inter_normal, 
                  &dump, 
                  pvecback),
      pba->error_message,
      ppt2->error_message);

    a_end = pvecback[pba->index_bg_a];
    y_end = log10(a_end/pba->a_eq);
    
      /* Print some information */
    printf("    * 2nd-order line-of-sight sources time sampling:\n");
    printf("      %d times in the range tau=(%g,%g), a=(%.2e,%.2e), log10(a/a_eq)=(%.3g,%.3g)\n",
      ppt2->tau_size, ppt2->tau_sampling[0], ppt2->tau_sampling[ppt2->tau_size-1], a_ini, a_end, y_ini, y_end);
    printf("    * quadratic sources time sampling: %d times in the range tau=(%g,%g)\n",
      ppt->tau_size_quadsources, ppt->tau_sampling_quadsources[0], ppt->tau_sampling_quadsources[ppt->tau_size_quadsources-1]);
    printf("    * sources k1-k2 sampling: %d times in the range k=(%g,%g), k/k_eq=(%g,%g)\n",
      ppt2->k_size, ppt2->k_min, ppt2->k_max, ppt2->k_min/pba->k_eq, ppt2->k_max/pba->k_eq);
    printf("    * sources cosk1k2 sampling: %d times in the range (%g,%g)\n",
      ppt2->cosk1k2_size, ppt2->cosk1k2_min, ppt2->cosk1k2_max);
        
  }

  free (pvecback);
  free (pvecthermo);

  return _SUCCESS_;
  
}



/**
  * As in the 1st-order case, initial_conditions is called inside the vector_init function,
  * which is in the innermost cycle on the k-modes (k1,k2,cosk1k2).  This function is called
  * as many times as the points in the grid k1 - k2 - cosk1k2. 
  * IMPORTANT:  you should not set shear_g here, not even to zero!  At this stage, if the tca
  * approx is on, then index_pt_shear_g = 0 which means that setting it will overwrite
  * delta_g!
  */
int perturb2_initial_conditions(
             struct precision * ppr,
             struct background * pba,
             struct thermo * pth,
             struct perturbs * ppt,
             struct perturbs2 * ppt2,
             double tau,
             struct perturb2_workspace * ppw2
             )
{


  /* Shortcuts */
  double * y = ppw2->pv->y;
  int m_max = ppw2->pv->m_max;
  
  /* Wavemodes */
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  double mu = ppw2->cosk1k2;
  double mu_sq = mu*mu;  
  double k1_sq = k1*k1;
  double k2_sq = k2*k2;
  double k1_pow3 = k1_sq*k1;
  double k1_pow4 = k1_sq*k1_sq;
  double k2_pow3 = k2_sq*k2;
  double k2_pow4 = k2_sq*k2_sq; 
  double k_sq = ppw2->k_sq;
  double k = ppw2->k;
  double k_pow4 = k_sq*k_sq;
  double k1_dot_k2 = ppw2->k1_dot_k2;
  double k1_dot_k  = ppw2->k1_dot_k;
  double k2_dot_k  = ppw2->k2_dot_k;    
  double k1_0 = ppw2->k1_0;
  double k2_0 = ppw2->k2_0;  
  double k1_M1 = ppw2->k1_M1;
  double k2_M1 = ppw2->k2_M1;  
  double k1_P1 = ppw2->k1_P1;
  double k2_P1 = ppw2->k2_P1;  



  /* Tensor product between k1 and k2, that is X[0]^ij k1_i k2_j */
  double * k1_ten_k2 = ppw2->k1_ten_k2;


  // *** Get background quantities
  class_call (background_at_tau(
        pba,
        tau, 
        pba->long_info, 
        pba->inter_normal, 
        &(ppw2->last_index_back), 
        ppw2->pvecback),
       pba->error_message,
       ppt2->error_message);

  double a     = ppw2->pvecback[pba->index_bg_a];
  double Y     = log10(a/pba->a_eq) ;
  double a2    = a*a;
  double H     = ppw2->pvecback[pba->index_bg_H];
  double Hc    = a*H;
  double Hc_sq = Hc*Hc;
  double Omega_m = ppw2->pvecback[pba->index_bg_Omega_m];
  double Omega_r = ppw2->pvecback[pba->index_bg_Omega_r];

  double rho_g = ppw2->pvecback[pba->index_bg_rho_g];
  double rho_r = rho_g;
  double rho_ur = 0;

  if (pba->has_ur == _TRUE_) {
    rho_ur  =  ppw2->pvecback[pba->index_bg_rho_ur];
    rho_r   +=  rho_ur;
  }

  double frac_ur = rho_ur/rho_r;
  double frac_g = 1 - frac_ur;

  // *** Get thermodynamics quantities (needed by quadratic_sources, below)
  class_call (thermodynamics_at_z(
           pba,
           pth,
           1./a-1.,  /* redshift z=1/a-1 */
           pth->inter_normal,
           &(ppw2->last_index_thermo),
           ppw2->pvecback,
           ppw2->pvecthermo),
       pth->error_message,
       ppt2->error_message);

  
  /* Newtonian gauge potential */
  double psi;


  /* Interpolate quadratic sources at tau.  They are then accessed through the array
    ppw2->pv->dy_quadsources, or with the macroes dX_ql and dX_qc, where X is an
    arbitrary species with X = I, E, B, N and where ql and qc stands for quadratic
    Liouville and collision terms.  Note that calling this function does not fill
    the dX_quad arrays! */
  if (ppt2->has_quadratic_sources == _TRUE_) {
    class_call(perturb2_quadratic_sources_at_tau(
              ppt,
              ppt2,
              tau,            
              ppw2
              ),
          ppt2->error_message,
          ppt2->error_message);
  }



  // *** Interpolate first-order quantities (ppw2->psources_1)
  class_call(perturb_quadsources_at_tau_for_all_types(
                 ppt,
                 ppt2->index_mode,
                 ppt2->index_ic,
                 ppw2->index_k1,
                 tau,
                 ppt->inter_normal,
                 &(ppw2->last_index_sources),
                 ppw2->pvec_sources1),
             ppt->error_message,
             ppt2->error_message);


  // *** Interpolate first-order quantities (ppw2->psources_2)  
  class_call(perturb_quadsources_at_tau_for_all_types(
                 ppt,
                 ppt2->index_mode,
                 ppt2->index_ic,
                 ppw2->index_k2,
                 tau,
                 ppt->inter_normal,
                 &(ppw2->last_index_sources),                 
                 ppw2->pvec_sources2),
             ppt->error_message,
             ppt2->error_message);  

  /* Shortcuts to access the first-order quantities */
  double * pvec_sources1 = ppw2->pvec_sources1;
  double * pvec_sources2 = ppw2->pvec_sources2;



    
  // *** Densities and velocities at first order
  double delta_g=0, pressure_g=0, v_0_g=0, sigma_0_g=0, delta_g_adiab=0;
  double delta_g_1=0, delta_g_2=0, v_g_1=0, v_g_2=0;
  double delta_b=0, pressure_b=0, v_0_b=0, sigma_0_b=0;
  double delta_b_1=0, delta_b_2=0, v_b_1=0, v_b_2=0;  
  double delta_cdm=0, pressure_cdm=0, v_0_cdm=0, sigma_0_cdm=0;  
  double delta_cdm_1=0, delta_cdm_2=0, v_cdm_1=0, v_cdm_2=0;
  double delta_ur=0, pressure_ur=0, v_0_ur=0, sigma_0_ur=0;  
  double delta_ur_1=0, delta_ur_2=0, v_ur_1=0, v_ur_2=0;
  double phi_1, phi_2, psi_1, psi_2;

  /* Photons */
  delta_g_1 = pvec_sources1[ppt->index_qs_delta_g];
  delta_g_2 = pvec_sources2[ppt->index_qs_delta_g];
  v_g_1 = pvec_sources1[ppt->index_qs_v_g];
  v_g_2 = pvec_sources2[ppt->index_qs_v_g];

  /* Baryons */
  delta_b_1 = pvec_sources1[ppt->index_qs_delta_b];
  delta_b_2 = pvec_sources2[ppt->index_qs_delta_b];
  v_b_1 = pvec_sources1[ppt->index_qs_v_b];
  v_b_2 = pvec_sources2[ppt->index_qs_v_b];

  /* Cold dark matter */
  if (pba->has_cdm == _TRUE_) {

    delta_cdm_1 = pvec_sources1[ppt->index_qs_delta_cdm];
    delta_cdm_2 = pvec_sources2[ppt->index_qs_delta_cdm];  

    if(ppt->gauge != synchronous) {
      v_cdm_1 = pvec_sources1[ppt->index_qs_v_cdm];
      v_cdm_2 = pvec_sources2[ppt->index_qs_v_cdm];
    }
  }

  /* Neutrinos */
  if (pba->has_ur == _TRUE_) {

    delta_ur_1 = pvec_sources1[ppt->index_qs_delta_ur];
    delta_ur_2 = pvec_sources2[ppt->index_qs_delta_ur];
    v_ur_1 = pvec_sources1[ppt->index_qs_v_ur];
    v_ur_2 = pvec_sources2[ppt->index_qs_v_ur];
  }
  
  /* Newtonian gauge */
  if (ppt->gauge == newtonian) {

    phi_1 = ppw2->pvec_sources1[ppt->index_qs_phi];
    phi_2 = ppw2->pvec_sources2[ppt->index_qs_phi];
          
    psi_1 = ppw2->pvec_sources1[ppt->index_qs_psi];
    psi_2 = ppw2->pvec_sources2[ppt->index_qs_psi];
  }

  

  
  
  // ****    Amplitude of perturbations    ****

  
  /* C constant as in Ma & Bertschinger, squared.  The 2 factor arises because all the initial conditions at first order
    in CLASS are multiplied by ppr->curvature_ini and divided by 1./2. with respect to those quoted in Ma & Bertschinger. */
  double C = 0.5*ppr->curvature_ini;
  double C_sq = C*C;
  
  /* D constant as in my Mathematica notebook.   This is equivalent to the C constant, but it arises
    from solving the equation for h(tau) at second order instead that the one at first order.  As in
    the first order case, D is the integration costant associated with the tau^2 eigenmode, the only
    one we consider from the homogeneous solutions. */
  double D = 0.5*ppr->curvature_ini_2nd_order;





  // ****   Treat perfect fluids    ****


  /* Set the beta-moments b(2,0,0) and b(2,2,m) in such a way that the baryon pressure and anisotropic
   stresses start at zero.  */
  if (ppt2->has_perfect_baryons == _TRUE_) {
   
    b(2,0,0) = - 2 * k1_dot_k2*v_b_1*v_b_2;

    int m;
    for (m=0; m <= min(2,m_max); ++m)
      b(2,2,m) =  15 * k1_ten_k2[m+2]*v_b_1*v_b_2;
  }

  /* Set the beta-moments cdm(2,0,0) and cdm(2,2,m) in such a way that the cold dark matter pressure
   and anisotropic stresses start at zero.  */
  if (pba->has_cdm == _TRUE_) {
    if (ppt2->has_perfect_cdm == _TRUE_) {

      cdm(2,0,0) = - 2 * k1_dot_k2*v_cdm_1*v_cdm_2;

      int m;
      for (m=0; m <= min(2,m_max); ++m)
        cdm(2,2,m) =  15 * k1_ten_k2[m+2]*v_cdm_1*v_cdm_2;
    }
  }

  



  // ======================================================
  // =            Vanishing initial conditions            =
  // ======================================================


  /* If the user asked for vanishing initial conditions, then do not do anything, as the
    ppw2->pv->y array was initialized with calloc. Works fine in synchronous gauge. */

  if (ppt2->has_ad_zero == _TRUE_) {

    if (ppt2->perturbations2_verbose > 3)
      printf("    * assuming vanishing initial conditions for the 2nd-order system\n");

    return _SUCCESS_;

  }






  // ========================================================
  // =            First-order initial conditions            =
  // ========================================================

  /* These initial conditions should be used only for testing purposes.  For example,
    if you set 'quadratic_sources = no' in the .ini file and use these IC, then
    you should get the first-order tranfer functions as in standard CLASS.  Note that
    you should compare with the latter computed for k = sqrt(k1^2 + k2^2 + 2*k1_dot_k2). */

  if (ppt2->first_order_ic == _TRUE_) {

    double C = 0.5*ppr->curvature_ini;         
    
    if (ppt2->perturbations2_verbose > 3)
      printf("    * Using 'first_order_ic' initial conditions with C = %g... \n", C);
    
    double psi = 20.*C / (15. + 4.*frac_ur);
    y[ppw2->pv->index_pt2_phi] = (1. + 2./5.*frac_ur)*psi;
           
    /* Photon density */        
    y[ppw2->pv->index_pt2_monopole_g] = -2.*psi;
    
    /* Photon velocity */
    double theta_g =  0.5 * k_sq* tau *psi;
    y[ppw2->pv->index_pt2_monopole_g + lm(1,0)] = 4*theta_g/k;   //  I_1_0 = 3 theta (w+1)/k
    
    /* Baryon density */        
    y[ppw2->pv->index_pt2_monopole_b] = 3./4.*y[ppw2->pv->index_pt2_monopole_g];
        
    /* Baryon velocity */
    y[ppw2->pv->index_pt2_monopole_b + nlm_b(1,1,0)] = y[ppw2->pv->index_pt2_monopole_g + lm(1,0)]/4;
    
    
    if (pba->has_cdm == _TRUE_) {
      /* Cold dark matter density */
      y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(0,0,0)] = 3./4.*y[ppw2->pv->index_pt2_monopole_g];
    
      /* Cold dark matter velocity */
      y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(1,1,0)] = y[ppw2->pv->index_pt2_monopole_g + lm(1,0)]/4;
    }
    


    if (pba->has_ur == _TRUE_) {

      /* Neutrino density */        
      y[ppw2->pv->index_pt2_monopole_ur] = y[ppw2->pv->index_pt2_monopole_g];
    
      /* Neutrino velocity */
      y[ppw2->pv->index_pt2_monopole_ur + lm(1,0)] = y[ppw2->pv->index_pt2_monopole_g + lm(1,0)];
    
      /* Neutrino shear (gauge invariant) */
      double shear_ur = 1/15. * k*k*tau*tau * psi;
      y[ppw2->pv->index_pt2_monopole_ur + lm(2,0)] = shear_ur/10.;      // I_2_0 = 15/2 (w+1) shear
              
    }
    
    
    return _SUCCESS_;  

  }




  // ========================================================
  // =            Unphysical initial conditions            =
  // ========================================================

  /* These initial conditions are used for testing purposes only. */

  if (ppt2->unphysical_ic == _TRUE_) {
    
    y[ppw2->pv->index_pt2_monopole_g] = 1;
    
    return _SUCCESS_;
    
  }



  // ============================================================
  // =              Adiabatic initial conditions                =
  // ============================================================

  if (ppt2->has_ad == _TRUE_) {  

    if (ppt2->perturbations2_verbose > 3)
      printf("    * Using adiabatic initial conditions.\n");
    

    // *****         Metric & quadrupoles        ******

    /* The curvature perturbation at first order is given by R(1) = phi(1) + 1/2*psi(1) (eq. 3.6a of
      Pitrou et al. 2010). Using Ma & Bertschinger 1995, eq. 98, it follows that R(1) = 2*C, where
      C is set as 0.5*ppr->curvature_ini */
    double R_1, R_2;
    R_1 = R_2 = 2*C;

    /* At second-order, we have that R^(2) = - 2 * fNL_zeta * R^(1)*R^(1), where fNL_zeta = 3/5. * fNL_phi + 1.
      In order to have Gaussian primordial initial conditions, set fNL_phi = 0. This is also what you get for
      slow-rolling single field inflationary models: R(2) = - 2 R(1)*R(1)  (eq. 3.19 of Pitrou et al. 2010), 
      Note that we set R^(1) = 5/3 at first-order, in order to obtain psi=1 at early times. Hence, a Gaussian 
      Universe will have R^(2) = - 2 R(1)*R(1) equal to -50/9 ~ 5.555. */
    double primordial_local_fnl_phi = ppt2->primordial_local_fnl_phi;
    double primordial_local_fnl_zeta = 3/5. * primordial_local_fnl_phi + 1;
    double R = - 2 * primordial_local_fnl_zeta * R_1 * R_2;

    /* Quadratic part of the anisotropic stresses equation, i.e. phi - psi = - quadrupoles + A */
    double A_quad = ppw2->pvec_metric_quadsources[ppw2->index_mt2_psi];
    
    /* To compute the initial conditions for the time potential psi, we need the photon
      quadrupole.  This is obtained directly from Boltzmann equation assuming an infinitely
      large interaction rate.  (The following equation is equivalent ot eq. C.6 of Pitrou et
      al 2010) */
    double I_2_0_quad = 5/8. * (c_minus_12(2,0) * I_1_tilde(1) * I_2_tilde(1) + c_minus_21(2,0) * I_2_tilde(1) * I_1_tilde(1));

    /* The IC for the neutrino quadrupole come from integrating the dipole & quadrupole
      equations with H >> anything.  We store the quadratic part of N_2_0 here. */
    double N_2_0_quad = 0;

    if (pba->has_ur == _TRUE_)
      N_2_0_quad = 1/3.*(k/Hc_sq)*dN_ql(1,0) + 1/(2*Hc)*dN_ql(2,0) + 8/3.*(k_sq/Hc_sq)*psi_1*psi_2;

    
    /* Here we put together the quadratic parts of the radiation quadrupoles */
    double quadrupole_quad = frac_g * I_2_0_quad;

    if (pba->has_ur == _TRUE_)
      quadrupole_quad += frac_ur * N_2_0_quad;

    /* We multiply the quadrupoles by the same factor they are multiplied with in the
      anisotropic stresses equation. */
    quadrupole_quad *= 3/5.*(Hc_sq/k_sq);
  
    /* B_quad is crucial in the determination of psi:  psi * (1 + 2/5*frac_nu) = phi + B_quad */
    double B_quad = A_quad - quadrupole_quad;
    
    /* The time potential is readily obtained using B_quad */
    double frac_g_factor = 1 + 4/15.*(1-frac_g);
    psi = 1/frac_g_factor * 2/3. * (3/2.*psi_1*psi_2 + phi_1*psi_2 + phi_2*psi_1 + B_quad + R);

    /* The photon quadrupole does not have a purely second-order part at early times (see eq. C.6 of P2010) */
    double I_2_0 = I_2_0_quad;

    /* Now that we obtained psi, we can compute the purely second-order part of the neutrinos
      shear, and add it to the quadratic part, which we already computed */
    double N_2_0 = 0;

    if (pba->has_ur == _TRUE_)
      N_2_0 = 2/3.*(k_sq/Hc_sq)*psi + N_2_0_quad;


    /* To obtain the initial conditions for phi we need to define S3 = phi-psi, that is
      given by S3_quad + quadrupoles.  This could also easily obtained as 
      double S3 = S3_quad + 3*Hc_sq/(5*k_sq)* ((1.-frac_ur)*I_2_0 + frac_ur*N_2_0); */
    // double rho_quadrupole = 3/5.*(Hc_sq/k_sq) * (frac_g*I_2_0 + frac_ur*N_2_0);
    double rho_quadrupole = rho_g*I_2_0;
      
    if (pba->has_ur == _TRUE_)
      rho_quadrupole += rho_ur*N_2_0;

    y[ppw2->pv->index_pt2_phi] = psi - A_quad + 3/5. * (a2/k_sq) * rho_quadrupole;
    




    // *****         Velocities & dipoles        ******

    /* Similary to the first-order case, at second-order the velocities of the different matter
      species are equal at early times.  Such unique velocity can be computed from the longitudinal
      Einstein equation (G_0i = T_0i) once the time potential psi is known, and assuming that the
      potentials are constant at early times. */
    
    /* Quadratic terms of the longitudinal equation */
    double L_quad = ppw2->pvec_metric_quadsources[ppw2->index_mt2_phi_prime_longitudinal];

    /* Common matter & radiation velocity (m=0 case, which is the one appearing in the RHS of the
      longitudinal equation).  Note that here we use the fact that also at first order
      v_b = v_g = v_cdm = v_ur. */

    double v_0_adiabatic = 2*(k/Hc)*(psi - L_quad/Hc)
                         - (-k1_0*v_cdm_1)*(3*Omega_m*delta_cdm_2 + 4*Omega_r*delta_g_2)
                         - (-k2_0*v_cdm_2)*(3*Omega_m*delta_cdm_1 + 4*Omega_r*delta_g_1);

    v_0_adiabatic *= 1/(3*Omega_m + 4*Omega_r);

    
    // *** Obtain the dipoles of the various species from the common velocity
    double I_1_0=0., N_1_0=0., b_1_1_0=0., cdm_1_1_0=0.;

    /* Photon dipole */
    I_1_0 = 4*(v_0_adiabatic + delta_g_1*(-k2_0*v_g_2) + delta_g_2*(-k1_0*v_g_1));
    
    /* Neutrino dipole */
    if (pba->has_ur == _TRUE_) {

      N_1_0 = 4*(v_0_adiabatic + delta_ur_1*(-k2_0*v_ur_2) + delta_ur_2*(-k1_0*v_ur_1));

      /* One can also compute the neutrino dipole by directly using its dipole equation, assuming that psi and
        dN_ql(1,0) are constant at early times.  Here we check that the two ways of computing N_1_0 give the
        same answer to the 10% level.  Note that when N_1_0 is very small, this check is likely to fail but
        we don't care much about that because... N_1_0 is very small :-)  */
      double N_1_0_boltzmann = 2*(k/Hc)*psi + 8*(k/Hc)*psi_1*psi_2 + 1/Hc*dN_ql(1,0);

      // class_test (abs(N_1_0/N_1_0_boltzmann-1) > 0.1,
      //             ppt2->error_message,
      //             "consistency check on initial conditions failed (%.5g != %.5g), try evolving from earlier on", N_1_0, N_1_0_boltzmann);
      
    } // end of if(has_ur)


    /* Baryons */
    b_1_1_0 = 3*(v_0_adiabatic + delta_b_1*(-k2_0*v_b_2) + delta_b_2*(-k1_0*v_b_1));

    /* Cold dark matter */
    if (pba->has_cdm == _TRUE_)
      cdm_1_1_0 = 3*(v_0_adiabatic + delta_cdm_1*(-k2_0*v_cdm_2) + delta_cdm_2*(-k1_0*v_cdm_1));
    

    /* CYRIL VALUES FOR (0.069453, 0.087205, 0.212556) */
    // if (pba->has_ur == _TRUE_) {
    // 
    //   psi = 0.637259;
    //   y[ppw2->pv->index_pt2_phi] = -2.01936;
    //   I_1_0 = -0.490709;
    //   I_2_0 = 0.0338067;
    //   N_2_0 = 0.0707047;
    // }
    // else {
    // 
    //   psi = 0.721905;
    //   y[ppw2->pv->index_pt2_phi] = -1.35945;
    //   I_2_0 = 0.0174282;
    // }

    /* CYRIL VALUES FOR (0.02, 0.1, -0.3) */
    // if (pba->has_ur == _TRUE_) {
    // 
    //   psi = 2.01894;
    //   y[ppw2->pv->index_pt2_phi] = -2.71053;
    //   I_1_0 = 0.00163578;
    //   I_2_0 = -0.0000460576;
    //   N_2_0 = 0.0281558;
    // }

      

    // ***** MATTER VARIABLES ******

    // *** Photons


    /* Photon monopole (like in eq. 3.5b of P2010) */
    double I_0_0 = - 2*psi + 8*psi_1*psi_2;
    y[ppw2->pv->index_pt2_monopole_g] = I_0_0;

    /* Photon dipole (eq. C.2 of P2010) */
    y[ppw2->pv->index_pt2_monopole_g + lm(1,0)] = I_1_0;

    /* Photon quadrupole */
    y[ppw2->pv->index_pt2_monopole_g + lm(2,0)] = I_2_0;




    // *** Baryons

    /* Baryon monopole (eq. 3.4b of P2010) */
    y[ppw2->pv->index_pt2_monopole_b] = 3*(I_0_0/4 - delta_g_1*delta_g_2/16);
                   
    /* Baryon dipole (eq. 3.2 of P2010) */
    y[ppw2->pv->index_pt2_monopole_b + nlm_b(1,1,0)] = b_1_1_0;


    // *** Cold dark matter

    if (pba->has_cdm == _TRUE_) {

      /* CDM monopole */
      y[ppw2->pv->index_pt2_monopole_cdm] = y[ppw2->pv->index_pt2_monopole_b];

      /* CDM dipole */
      if (ppt->gauge != synchronous)
        y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(1,1,0)] = cdm_1_1_0;
    }



    // *** Neutrinos

    if (pba->has_ur == _TRUE_) {

      /* Density */
      y[ppw2->pv->index_pt2_monopole_ur] = I_0_0;

      /* Velocity */
      y[ppw2->pv->index_pt2_monopole_ur + lm(1,0)] = N_1_0;

      /* Shear */                         
      y[ppw2->pv->index_pt2_monopole_ur + lm(2,0)] = N_2_0;
    }              


    class_call(perturb2_einstein(
               ppr,
               pba,
               pth,
               ppt,
               ppt2,
               tau,
               y,
               ppw2),       /* We shall store the metric variables in ppw2->pvecmetric */
           ppt2->error_message,
           ppt2->error_message);
    
    double psi_from_constraint = ppw2->pvecmetric[ppw2->index_mt2_psi];
    
    
    // if (ppt2->perturbations2_verbose > 0) {
    //   if (ppw2->index_k1 == 0) {
    //     if (ppw2->index_k2 == 1) {
    // 
    //       printf("Y = %g\n", Y);
    //       printf("R = %g\n", R);
    //       printf("Hc = %g\n", Hc);
    //       printf("EE_quad = %g\n", EE_quad);
    //       printf("S3_quad = %g\n", S3_quad);
    //       printf("3/2.*psi_1*psi_2 = %g\n", 3/2.*psi_1*psi_2);
    //       printf("phi_1*psi_2 + phi_2*psi_1 = %g\n", phi_1*psi_2 + phi_2*psi_1);
    //       if (pba->has_ur == _TRUE_) {
    //         printf("dN_quad(1,0) = %g\n", dN_ql(1,0));
    //         printf("dN_quad(2,0) = %g\n", dN_ql(2,0));
    //       }
    //       printf("N_2_0 = %g\n", N_2_0);            
    //       printf("phi = %g\n", y[ppw2->pv->index_pt2_phi]);
    //       printf("psi = %g\n", psi);          
    //       printf("psi_from_constraint = %g\n", psi_from_constraint);
    //       printf("I_0_0 = %g\n", I_0_0);
    //       printf("I_1_0 = %g\n", I_1_0);
    //       printf("I_2_0 = %g\n", I_2_0);
    //       printf("b_1_1_0 = %g\n", y[ppw2->pv->index_pt2_monopole_b + nlm_b(1,1,0)]);
    //       printf("cdm_1_1_0 = %g\n", y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(1,1,0)]);
    // 
    //     }
    //   }
    // }
    
    return _SUCCESS_;
        
  } // end of if(has_ad)  
  


  return _SUCCESS_;
}







int perturb2_workspace_init(
         struct precision * ppr,
         struct background * pba,
         struct thermo * pth,
         struct perturbs * ppt,
         struct perturbs2 * ppt2,
         struct perturb2_workspace * ppw2
         )
{


  
  // ***********************        Count the metric quantities       *******************


  /* Define indices of metric perturbations obeying to constraint equations.  This
    can be done once and for all, because the vector of metric perturbations is
    the same whatever the approximation scheme, unlike the vector of quantities to
    be integrated, which is allocated separately in perturb2_vector_init. */
  int index_mt = 0;


  // *** Newtonian gauge ***

  /* We are going to evolve phi, and use the anisotropic stresses constraint equation to obtain psi.
    We obtain phi_prime from either the time-time or longitudinal Einstein equations. */

  if (ppt->gauge == newtonian) {

    ppw2->index_mt2_psi = index_mt++;                         /* Psi */
    ppw2->index_mt2_phi_prime = index_mt++;                   /* Phi' */
    ppw2->index_mt2_phi_prime_poisson = index_mt++;           /* Phi' from the Poisson equation */
    ppw2->index_mt2_phi_prime_longitudinal = index_mt++;      /* Phi' from the longitudinal equation */

  }

    
  // *** Synchronous gauge ***
    
  /* We do not include eta because it is evolved, while here we only consider
    quantities obeying to constraint equations) */
  if (ppt->gauge == synchronous) {
 
    ppw2->index_mt2_h_prime = index_mt++;                     /* h' */
    ppw2->index_mt2_h_prime_prime = index_mt++;               /* h'' */
    ppw2->index_mt2_eta_prime = index_mt++;                   /* eta' */
    ppw2->index_mt2_alpha_prime = index_mt++;                 /* alpha' (with alpha = (h' + 6 eta') / (2 k**2) ) */

  }     


  /* Set the size of the array of metric quantities */
  ppw2->mt2_size = index_mt;




  // ***********************        Count the source terms       *******************

  /* Define indices of the ppw2->source_term_table array, which is used to store intermediate values needed for the
    computation of the line-of-sight sources. */
  int index_st = 0;

  ppw2->index_st2_tau = index_st++;
  ppw2->index_st2_exp_minus_kappa = index_st++;
  
  /* We need the derivative of the gravitational potentials if we want to compute the ISW effect. While
    we obtain phi_prime directly from the differential system, we shall need to take the derivative
    of psi numerically in perturb2_sources. */
  if ((ppt2->has_source_t == _TRUE_) && (ppt2->has_integrated_sachs_wolfe_in_los == _TRUE_)) {
    ppw2->index_st2_psi = index_st++;
    ppw2->index_st2_psi_prime = index_st++;
    ppw2->index_st2_phi_prime = index_st++;
  }

  ppw2->st2_size = index_st;


  /* Allocate the source terms array */
  class_alloc(ppw2->source_term_table,
              ppt2->tau_size*ppw2->st2_size*sizeof(double),
              ppt2->error_message);



  // ***********************        Count the approximations       *******************


  /* Count number of approximation, initialize their indices, and allocate their flags */
  int index_ap = 0;

  ppw2->index_ap2_tca = index_ap++;

  ppw2->index_ap2_rsa = index_ap++;
  
  if (pba->has_ur)
    ppw2->index_ap2_ufa = index_ap++;

  ppw2->index_ap2_nra = index_ap++;

  ppw2->ap2_size = index_ap;

  if (ppw2->ap2_size > 0)
    class_alloc(ppw2->approx, ppw2->ap2_size*sizeof(int), ppt2->error_message);

  /* Assign values to the approximation for definitness.  These will be overwritten in perturb2_approximations */
  ppw2->approx[ppw2->index_ap2_tca] = (int)tca_on;
  ppw2->approx[ppw2->index_ap2_rsa] = (int)rsa_off;

  if (pba->has_ur)
    ppw2->approx[ppw2->index_ap2_ufa] = (int)ufa_off;

  ppw2->approx[ppw2->index_ap2_nra] = (int)nra_off;




  // ***********************        Allocate arrays       *******************

  /* Allocate the arrays in which we will store temporarily the values of background,
    thermodynamics, metric and source quantities at a given time.  The pvec_sources1
    and pvec_sources2 arrays will contain the first order sources, while
    pvec_metric_quadsources, pvec_liouville_quadsources, pvec_collision_quadsources will
    contain the quadratic terms in the Einstein equations, Liouville operator and
    collision term, respectively.  */
        
  class_alloc(ppw2->pvecback, pba->bg_size*sizeof(double), ppt2->error_message);
  class_alloc(ppw2->pvecthermo, pth->th_size*sizeof(double), ppt2->error_message);
  class_alloc(ppw2->pvecmetric, ppw2->mt2_size*sizeof(double), ppt2->error_message);

  class_calloc(ppw2->pvec_sources1, ppt->qs_size[ppt2->index_mode], sizeof(double), ppt2->error_message);
  class_calloc(ppw2->pvec_sources2, ppt->qs_size[ppt2->index_mode], sizeof(double), ppt2->error_message);



  // **************            Initialize quadratic sources          **************

  class_call(perturb2_workspace_init_quadratic_sources(
        ppr,
        pba,
        pth,
        ppt,
        ppt2,
        ppw2
        ),
    ppt2->error_message,
    ppt2->error_message);


  return _SUCCESS_;

}



int perturb2_workspace_init_quadratic_sources(
         struct precision * ppr,
         struct background * pba,
         struct thermo * pth,
         struct perturbs * ppt,
         struct perturbs2 * ppt2,
         struct perturb2_workspace * ppw2
         )
{

  // ***********************        Count the metric quadratic sources       *******************

  int index_qm = 0;

  // *** Newtonian gauge ***

  if (ppt->gauge == newtonian) {

    ppw2->index_qm2_psi = index_qm++;                         /* Psi */
    ppw2->index_qm2_phi_prime = index_qm++;                   /* Phi' */
    ppw2->index_qm2_phi_prime_poisson = index_qm++;           /* Phi' from the Poisson equation */
    ppw2->index_qm2_phi_prime_longitudinal = index_qm++;      /* Phi' from the longitudinal equation */

  }

    
  // *** Synchronous gauge ***
    
  if (ppt->gauge == synchronous) {
 
    ppw2->index_qm2_h_prime = index_qm++;                     /* h' */
    ppw2->index_qm2_h_prime_prime = index_qm++;               /* h'' */
    ppw2->index_qm2_eta_prime = index_qm++;                   /* eta' */
    ppw2->index_qm2_alpha_prime = index_qm++;                 /* alpha' (with alpha = (h' + 6 eta') / (2 k**2) ) */

  }     

  /* Set the size of the array of metric quantities */
  ppw2->qm2_size = index_qm;  





  // ***********************        Count Liouville & collisional quadratic sources       *******************

  int index_ql = 0;
  int index_qc = 0;  
  ppw2->m_max = ppr->m_max_2nd_order;
  
  
  
  // =======================================
  // =          Photon temperature         =
  // =======================================

  /* Number of equations in the photon temperature hierarchy */
  ppw2->l_max_g = ppr->l_max_g_2nd_order;
  ppw2->n_hierarchy_g = lm_number_of_elements(ppw2->l_max_g, ppw2->m_max);

  /* The first moment of the hierarchy is the monopole l=0, m=0.  The other equations follow
    it in the order given by lm_offset. */
  ppw2->index_ql2_monopole_g = index_ql;
  index_ql += ppw2->n_hierarchy_g;

  ppw2->index_qc2_monopole_g = index_qc;
  index_qc += ppw2->n_hierarchy_g;


  // ========================================
  // =          Photon polarization         =
  // ========================================

  if (ppt2->has_polarization2 == _TRUE_) {

    ppw2->l_max_pol_g = ppr->l_max_pol_g_2nd_order;
    ppw2->n_hierarchy_pol_g = lm_number_of_elements(ppw2->l_max_pol_g, ppw2->m_max);

    // *** Photon E-mode polarization
    ppw2->index_ql2_monopole_E = index_ql;
    index_ql += ppw2->n_hierarchy_pol_g;

    ppw2->index_qc2_monopole_E = index_qc;
    index_qc += ppw2->n_hierarchy_pol_g;

    // *** Photon B-mode polarization
    ppw2->index_ql2_monopole_B = index_ql;
    index_ql += ppw2->n_hierarchy_pol_g;

    ppw2->index_qc2_monopole_B = index_qc;
    index_qc += ppw2->n_hierarchy_pol_g;
    
  } // end of if(has_polarization2)


  // =======================================================
  // =              Ultra Relativistic Neutrinos           =
  // =======================================================
  if (pba->has_ur == _TRUE_) {

    ppw2->l_max_ur = ppr->l_max_ur_2nd_order;
    ppw2->n_hierarchy_ur = lm_number_of_elements(ppw2->l_max_ur, ppw2->m_max);

    ppw2->index_ql2_monopole_ur = index_ql;
    index_ql += ppw2->n_hierarchy_ur;
  
  }



  // =======================================
  // =                Baryons              =
  // =======================================

  int n_max_b = 2;
  int l_max_b = 2;
  ppw2->n_hierarchy_b = nlm_constrained_number_of_elements(n_max_b, l_max_b, ppw2->m_max);        

  ppw2->index_ql2_monopole_b = index_ql;
  index_ql += ppw2->n_hierarchy_b;    

  ppw2->index_qc2_monopole_b = index_qc;
  index_qc += ppw2->n_hierarchy_b;    


  // ==============================================
  // =               Cold Dark Matter             =
  // ==============================================
  if (pba->has_cdm == _TRUE_) {

    int n_max_cdm = 2;
    int l_max_cdm = 2;
    ppw2->n_hierarchy_cdm = nlm_constrained_number_of_elements(n_max_cdm, l_max_cdm, ppw2->m_max);        

    ppw2->index_ql2_monopole_cdm = index_ql;
    index_ql += ppw2->n_hierarchy_cdm;
    
  }


  
  
  /* Infer sizes for the quadratic sources */
  ppw2->ql2_size = index_ql;
  ppw2->qc2_size = index_qc;

  /* Some debug */
  // printf("ppw2->ql2_size = %d\n", ppw2->ql2_size);
  // printf("ppw2->qc2_size = %d\n", ppw2->qc2_size);




  // ***********************        Allocate arrays       *******************
        
  /* Allocate the tables that will contain the quadratic sources for all types and for all the times
    in ppt->tau_sampling_quadsources.  They all have two levels, for example:
      ppw2->metric_quadsources_table[index_qm_type][index_tau] */
  class_calloc(ppw2->metric_quadsources_table, ppw2->qm2_size, sizeof(double), ppt2->error_message);  
  class_calloc(ppw2->liouville_quadsources_table, ppw2->ql2_size, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->collision_quadsources_table, ppw2->qc2_size, sizeof(double), ppt2->error_message);

  for(index_qm=0; index_qm<ppw2->qm2_size; ++index_qm)
    class_calloc(ppw2->metric_quadsources_table[index_qm], ppt->tau_size_quadsources, sizeof(double), ppt2->error_message);

  for(index_ql=0; index_ql<ppw2->ql2_size; ++index_ql)
    class_calloc(ppw2->liouville_quadsources_table[index_ql], ppt->tau_size_quadsources, sizeof(double), ppt2->error_message);

  for(index_qc=0; index_qc<ppw2->qc2_size; ++index_qc)
    class_calloc(ppw2->collision_quadsources_table[index_qc], ppt->tau_size_quadsources, sizeof(double), ppt2->error_message);

  /* Allocate the arrays that will contain the second-derivative of the table arrays, in view of
    spline interpolation */
  class_calloc(ppw2->dd_metric_quadsources_table, ppw2->qm2_size, sizeof(double), ppt2->error_message);  
  class_calloc(ppw2->dd_liouville_quadsources_table, ppw2->ql2_size, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->dd_collision_quadsources_table, ppw2->qc2_size, sizeof(double), ppt2->error_message);

  for(index_qm=0; index_qm<ppw2->qm2_size; ++index_qm)
    class_calloc(ppw2->dd_metric_quadsources_table[index_qm], ppt->tau_size_quadsources, sizeof(double), ppt2->error_message);

  for(index_ql=0; index_ql<ppw2->ql2_size; ++index_ql)
    class_calloc(ppw2->dd_liouville_quadsources_table[index_ql], ppt->tau_size_quadsources, sizeof(double), ppt2->error_message);

  for(index_qc=0; index_qc<ppw2->qc2_size; ++index_qc)
    class_calloc(ppw2->dd_collision_quadsources_table[index_qc], ppt->tau_size_quadsources, sizeof(double), ppt2->error_message);



  /* Allocate the temporary arrays that will contain the interpolated values of the quadratic sources
    contained in the above tables, at a certain time */
  class_calloc(ppw2->pvec_metric_quadsources, ppw2->qm2_size, sizeof(double), ppt2->error_message);  
  class_calloc(ppw2->pvec_liouville_quadsources, ppw2->ql2_size, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->pvec_collision_quadsources, ppw2->qc2_size, sizeof(double), ppt2->error_message);





  // *** Allocate memory for the rotated multipoles

  int n_rotation_coefficients = lm_number_of_elements(ppt2->largest_l, ppt2->largest_m);

  /* Allocate memory for the rotation coefficients arrays */
  class_calloc(ppw2->rotation_1, n_rotation_coefficients, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->rotation_2, n_rotation_coefficients, sizeof(double), ppt2->error_message);

  /* Allocate memory for the rotated multipoles of the photons and neutrinos. Such
    arrays will be filled in 'perturb2_quadratic_sources'. */
  class_calloc(ppw2->rotated_multipoles_g_1, n_rotation_coefficients, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->rotated_multipoles_g_2, n_rotation_coefficients, sizeof(double), ppt2->error_message);  

  /* At first order, we do not have B-mode polarization, hence we compute the need
    multipoles only for the E-mode polarization. */
  if (ppt2->has_polarization2 == _TRUE_) {
    class_calloc(ppw2->rotated_multipoles_E_1, n_rotation_coefficients, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->rotated_multipoles_E_2, n_rotation_coefficients, sizeof(double), ppt2->error_message);  
  }

  if (pba->has_ur == _TRUE_) {
    class_calloc(ppw2->rotated_multipoles_ur_1, n_rotation_coefficients, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->rotated_multipoles_ur_2, n_rotation_coefficients, sizeof(double), ppt2->error_message);
  }    



  // *** Allocate memory for the inner products

  int n_couplings_products = lm_number_of_elements(ppt2->l_max, ppr->m_max_2nd_order);

  class_calloc(ppw2->c_minus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->c_minus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);    
  class_calloc(ppw2->c_plus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->c_plus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);   

  class_calloc(ppw2->c_minus_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->c_minus_product_22, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->c_plus_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->c_plus_product_22, n_couplings_products, sizeof(double), ppt2->error_message);

  class_calloc(ppw2->r_minus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->r_minus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);    
  class_calloc(ppw2->r_plus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
  class_calloc(ppw2->r_plus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);   

  if (ppt2->has_polarization2) {

    class_calloc(ppw2->d_minus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->d_minus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);    
    class_calloc(ppw2->d_plus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->d_plus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);   

    class_calloc(ppw2->d_minus_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->d_minus_product_22, n_couplings_products, sizeof(double), ppt2->error_message);    
    class_calloc(ppw2->d_plus_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->d_plus_product_22, n_couplings_products, sizeof(double), ppt2->error_message);   

    class_calloc(ppw2->d_zero_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->d_zero_product_21, n_couplings_products, sizeof(double), ppt2->error_message);   
    class_calloc(ppw2->d_zero_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->d_zero_product_22, n_couplings_products, sizeof(double), ppt2->error_message);   

    class_calloc(ppw2->k_minus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->k_minus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);    
    class_calloc(ppw2->k_plus_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->k_plus_product_21, n_couplings_products, sizeof(double), ppt2->error_message);   

    class_calloc(ppw2->k_minus_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->k_minus_product_22, n_couplings_products, sizeof(double), ppt2->error_message);    
    class_calloc(ppw2->k_plus_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->k_plus_product_22, n_couplings_products, sizeof(double), ppt2->error_message);   

    class_calloc(ppw2->k_zero_product_12, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->k_zero_product_21, n_couplings_products, sizeof(double), ppt2->error_message);   
    class_calloc(ppw2->k_zero_product_11, n_couplings_products, sizeof(double), ppt2->error_message);
    class_calloc(ppw2->k_zero_product_22, n_couplings_products, sizeof(double), ppt2->error_message);   

  }

  return _SUCCESS_;
  
}




int perturb2_workspace_free (
          struct perturbs2 * ppt2,
          struct background * pba,          
          struct perturb2_workspace * ppw2
          )
{

  free(ppw2->pvecback);
  free(ppw2->pvecthermo);
  free(ppw2->pvecmetric);

  free(ppw2->pvec_sources1);    
  free(ppw2->pvec_sources2);  

  /* Free buffer array for source terms */
  free(ppw2->source_term_table);

  /* Free quadratic sources temporary arrays */
  free(ppw2->pvec_metric_quadsources);
  free(ppw2->pvec_liouville_quadsources);
  free(ppw2->pvec_collision_quadsources);

  /* Free quadratic sources tables */
  int index_qm, index_ql, index_qc;

  for(index_qm=0; index_qm<ppw2->qm2_size; ++index_qm)
    free(ppw2->metric_quadsources_table[index_qm]);

  free(ppw2->metric_quadsources_table);

  for(index_ql=0; index_ql<ppw2->ql2_size; ++index_ql)
    free(ppw2->liouville_quadsources_table[index_ql]);
    
  free(ppw2->liouville_quadsources_table);

  for(index_qc=0; index_qc<ppw2->qc2_size; ++index_qc)
    free(ppw2->collision_quadsources_table[index_qc]);
  
  free(ppw2->collision_quadsources_table);


  /* Free coupling coefficient products */
  free(ppw2->c_minus_product_12);
  free(ppw2->c_minus_product_21);
  free(ppw2->c_plus_product_12);
  free(ppw2->c_plus_product_21);

  free(ppw2->c_minus_product_11);
  free(ppw2->c_minus_product_22);
  free(ppw2->c_plus_product_11);
  free(ppw2->c_plus_product_22);

  free(ppw2->r_minus_product_12);
  free(ppw2->r_minus_product_21);
  free(ppw2->r_plus_product_12);
  free(ppw2->r_plus_product_21);

  if (ppt2->has_polarization2) {

    free(ppw2->d_minus_product_12);
    free(ppw2->d_minus_product_21);
    free(ppw2->d_plus_product_12);
    free(ppw2->d_plus_product_21);

    free(ppw2->d_minus_product_11);
    free(ppw2->d_minus_product_22);
    free(ppw2->d_plus_product_11);
    free(ppw2->d_plus_product_22);

    free(ppw2->d_zero_product_12);
    free(ppw2->d_zero_product_21);
    free(ppw2->d_zero_product_11);
    free(ppw2->d_zero_product_22);

    free(ppw2->k_minus_product_12);
    free(ppw2->k_minus_product_21);
    free(ppw2->k_plus_product_12);
    free(ppw2->k_plus_product_21);

    free(ppw2->k_minus_product_11);
    free(ppw2->k_minus_product_22);
    free(ppw2->k_plus_product_11);
    free(ppw2->k_plus_product_22);

    free(ppw2->k_zero_product_12);
    free(ppw2->k_zero_product_21);
    free(ppw2->k_zero_product_11);
    free(ppw2->k_zero_product_22);

  }  

  /* Free arrays for the rotated multipoles */
  free(ppw2->rotation_1);
  free(ppw2->rotation_2);
  
  free(ppw2->rotated_multipoles_g_1);
  free(ppw2->rotated_multipoles_g_2);

  if (ppt2->has_polarization2 == _TRUE_) {
    free(ppw2->rotated_multipoles_E_1);
    free(ppw2->rotated_multipoles_E_2);
  }

  if (pba->has_ur == _TRUE_) {
    free(ppw2->rotated_multipoles_ur_1);
    free(ppw2->rotated_multipoles_ur_2);
  }    


  free(ppw2);

  return _SUCCESS_;
}


/**
  * This function is used by the Runge-Kutta integrator.  The RK integrator is used only for those modes
  * where the implicit ndf15 integrator fails.  Note that ndf15 does not need a timescale, as it determines
  * timescales automatically by computing the Jacobian of the system.
  */
int perturb2_timescale(
          double tau,
          void * parameters_and_workspace,
          double * timescale,
          ErrorMsg error_message
          )
{ 
            
  *timescale = 1;
            
  return _SUCCESS_;
  
}


/**
 * For a given set of (k1,k2,cosk1k2), find the number of time-intervals bewteen tau_ini and
 * tau_end such that the approximation schemes (and the number of perturbation equations) are
 * uniform.
 *
 * This function is a a slightly modified version of the CLASS equivalent.
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input: pointer to the thermodynamics structure
 * @param ppt                Input: pointer to the perturbation structure
 * @param ppt2               Input: pointer to the perturbation2 structure
 * @param ppw                Input: pointer to perturb_workspace structure containing index values and workspaces
 * @param tau_ini            Input: initial time of the perturbation integration
 * @param tau_end            Input: final time of the perturbation integration
 * @param interval_number    Output: total number of intervals
 * @param interval_number_of Output: number of intervals with respect to each particular approximation
 * @return the error status
 */
int perturb2_find_approximation_number(
        struct precision * ppr,
        struct background * pba,
        struct thermo * pth,
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        struct perturb2_workspace * ppw2,
        double tau_ini,
        double tau_end,
        int * interval_number,
        int * interval_number_of
        )
{
  
  
  /* Index running over approximations */
  int index_ap;

  /* Value of a given approximation at tau_ini and tau_end.  It can be either on (1) or off (0). */
  int flag_ini, flag_end;

  /** - fix default number of intervals to one (if no approximation switch) */  

  *interval_number = 1; 

  /* Loop over each approximation and add the number of approximation switching times.
    The idea is that each approximation can be turned on or off only once.  Hence, if
    an approximation starts on, it can be turned off but after that it cannot be turned
    on again.  Similarly, an application that kicks is at a certain time cannot be turned
    off.  Hence, the approximation that are active can be counted just by checking whether
    their state (on or off) differs at tau_ini and tau_end.  If it is the same state, then
    it must mean that the approximation is turned off. */

  for (index_ap = 0; index_ap < ppw2->ap2_size; ++index_ap) {

    class_call(perturb2_approximations(
              ppr,
              pba,
              pth,
              ppt,
              ppt2,
              tau_ini,
              ppw2),
         ppt2->error_message,
         ppt2->error_message);
    
    /* This can either be 0 or 1, because ppw2->approx is a logical array */
    flag_ini = ppw2->approx[index_ap];
    
    class_call(perturb2_approximations(ppr,
              pba,
              pth,
              ppt,
              ppt2,
              tau_end,
              ppw2),
         ppt2->error_message,
         ppt2->error_message);

    /* This can either be 0 or 1, because ppw2->approx is a logical array */
    flag_end = ppw2->approx[index_ap];
    
    /* This test is meaningful only if the the various 'enum xxx_flags' enumerations are declared in cronological
      order (see the comment in perturbations.h).  */
    class_test(flag_end < flag_ini,
         ppt2->error_message,
         "For each approximation scheme, the declaration of approximation labels in the enumeration must follow chronological order, e.g: enum approx_flags {flag1, flag2, flag3} with flag1 being the initial one and flag3 the final one");
    
    /* If the approximation scheme doesn't switch state, then it is turned off */
    *interval_number += flag_end - flag_ini;

    interval_number_of[index_ap] = flag_end - flag_ini + 1;
    
    /* Some debug */
    // printf("interval_number_of[%d] = %d\n", index_ap, interval_number_of[index_ap]);

  } // end of for(index_ap)
  
  
  
  return _SUCCESS_;
  
}




/**
 * For a given mode and wavenumber, find the values of time at which the approximations switch state.
 * 
 * This function is almost exactly equal to the default CLASS one in the perturb module.
 *
 * @param ppr                Input: pointer to precision structure
 * @param pba                Input: pointer to background structure
 * @param pth                Input: pointer to the thermodynamics structure
 * @param ppt                Input: pointer to the perturbation structure
 * @param ppt2               Input: pointer to the perturbation2 structure
 * @param ppw2                Input: pointer to perturb_workspace structure containing index values and workspaces
 * @param tau_ini            Input: initial time of the perturbation integration
 * @param tau_end            Input: final time of the perturbation integration
 * @param interval_number    Input: total number of intervals
 * @param interval_number_of Input: number of intervals with respect to each particular approximation
 * @param interval_limit     Output: value of time at the boundary of the intervals: tau_ini, tau_switch1, ..., tau_end 
 * @param interval_approx    Output: value of approximations in each interval
 * @return the error status
 */

int perturb2_find_approximation_switches(
          struct precision * ppr,
          struct background * pba,
          struct thermo * pth,
          struct perturbs * ppt,
          struct perturbs2 * ppt2,
          struct perturb2_workspace * ppw2,
          double tau_ini,
          double tau_end,
          double precision,
          int interval_number,
          int * interval_number_of,
          double * interval_limit, /* interval_limit[index_interval] (already allocated) */
          int ** interval_approx   /* interval_approx[index_interval][index_ap] (already allocated) */
          )
{

  int index_ap;
  int index_switch;
  int index_switch_tot;
  int num_switch; 
  double tau_min, lower_bound, upper_bound;
  double mid = 0;
  double * unsorted_tau_switch;
  double next_tau_switch;
  int flag_ini;
  int num_switching_at_given_time;


  /** - write in output arrays the initial time and approximation */

  interval_limit[0] = tau_ini;

  class_call(perturb2_approximations(ppr,
               pba,
               pth,
               ppt,
               ppt2,
               tau_ini,
               ppw2),
    ppt2->error_message,
    ppt2->error_message);
  
  for (index_ap=0; index_ap<ppw2->ap2_size; index_ap++)
    interval_approx[0][index_ap] = ppw2->approx[index_ap];
  
  /** - if there are no approximation switches, just write final time and return */

  if (interval_number == 1) {

    interval_limit[1] = tau_end;

  }
  
  /** - if there are switches, consider approximations one after each
      other.  Find switching time by bisection. Store all switches in
      arbitrary order in array unsorted_tau_switch[] */

  else {

    class_alloc(unsorted_tau_switch, (interval_number-1)*sizeof(double), ppt2->error_message);

    index_switch_tot = 0;

    for (index_ap=0; index_ap < ppw2->ap2_size; index_ap++) {

      /* If there is a switch (on->off or off->on) in the current approximation,
        find the time of such switch */
      if (interval_number_of[index_ap] > 1) {

        tau_min = tau_ini;

        /* flag_ini is either on or off */
        flag_ini = interval_approx[0][index_ap];

        /* If we are indise this if-block, then num_switch must be 1 */
        num_switch = interval_number_of[index_ap]-1;

        for (index_switch=0; index_switch < num_switch; index_switch++) {
  
          lower_bound = tau_min;
          upper_bound = tau_end;
          mid = 0.5*(lower_bound+upper_bound);

          while (upper_bound - lower_bound > precision) {
       
            class_call(perturb2_approximations(ppr,
                     pba,
                     pth,
                     ppt,
                     ppt2,
                     mid,
                     ppw2),
                ppt2->error_message,
                ppt2->error_message);

            if (ppw2->approx[index_ap] > flag_ini+index_switch) {
              upper_bound=mid;
            }
            else {
              lower_bound=mid;
            }

            mid = 0.5*(lower_bound+upper_bound);

          }

          unsorted_tau_switch[index_switch_tot]=mid;
          index_switch_tot++;

          tau_min=mid;

        }
      }
    }

    class_test(index_switch_tot != (interval_number-1),
       ppt2->error_message,
       "bug in approximation switch search routine: should have %d = %d",
       index_switch_tot,interval_number-1);
    

    /** - now sort interval limits in correct order */
    
    index_switch_tot = 1;
    
    while (index_switch_tot < interval_number) {
      
      next_tau_switch=tau_end;
      for (index_switch=0; index_switch<interval_number-1; index_switch++) {
        if ((unsorted_tau_switch[index_switch] > interval_limit[index_switch_tot-1]) &&
            (unsorted_tau_switch[index_switch] < next_tau_switch)) {
          next_tau_switch=unsorted_tau_switch[index_switch];
        }
      }
      interval_limit[index_switch_tot]=next_tau_switch;
      index_switch_tot++;
    } // end of while(index_switch_tot)
    
    interval_limit[index_switch_tot]=tau_end;
    
    class_test(index_switch_tot != interval_number,
       ppt2->error_message,
       "most probably two approximation switching time were found to be equal, which cannot be handled\n");
    

    /** - store each approximation in chronological order */

    for (index_switch=1; index_switch<interval_number; index_switch++) {
      
      class_call(perturb2_approximations(ppr,
                   pba,
                   pth,
                   ppt,
                   ppt2,
                   0.5*(interval_limit[index_switch]+interval_limit[index_switch+1]),
                   ppw2),
        ppt2->error_message,
        ppt2->error_message);
      
      for (index_ap=0; index_ap < ppw2->ap2_size; index_ap++) {

        interval_approx[index_switch][index_ap]=ppw2->approx[index_ap];

        /* check here that approximation does not go backward (remember that by definition the value
          of an approximation can only increase) */
        class_test(interval_approx[index_switch][index_ap] < interval_approx[index_switch-1][index_ap],
          ppt2->error_message,
          "The approximation with label %d is not defined correctly: it goes backward (from %d to %d) for (k1,k2,cosk1k2)=(%g,%g,%g) and between tau=%e and %e; this cannot be handled\n",
          index_ap,
          interval_approx[index_switch-1][index_ap],
          interval_approx[index_switch][index_ap],
          ppw2->k1,
          ppw2->k2,
          ppw2->cosk1k2,
          0.5*(interval_limit[index_switch-1]+interval_limit[index_switch]),
          0.5*(interval_limit[index_switch]+interval_limit[index_switch+1])
          );
      }

      /* check here that more than one approximation is not switched on at a given time */
      num_switching_at_given_time=0;
      for (index_ap=0; index_ap<ppw2->ap2_size; index_ap++)
        if (interval_approx[index_switch][index_ap] != interval_approx[index_switch-1][index_ap])
          num_switching_at_given_time++;

        class_test(num_switching_at_given_time != 1,
                   ppt2->error_message,
                   "for (k1,k2,cosk1k2)=(%g,%g,%g), at tau=%g, you switch %d approximations at the same time, this cannot be handled. Usually happens in two cases: triggers for different approximations coincide, or one approx is reversible\n",
                   ppw2->k1,
                   ppw2->k2,
                   ppw2->cosk1k2,
                   interval_limit[index_switch],
                   num_switching_at_given_time);

      /* Print information of switching times */
      if (ppt2->perturbations2_verbose > 3) {

        if ((interval_approx[index_switch-1][ppw2->index_ap2_tca]==(int)tca_on) && 
            (interval_approx[index_switch][ppw2->index_ap2_tca]==(int)tca_off))
          fprintf(stdout, "     \\ will switch off tight-coupling approximation at tau = %g\n", interval_limit[index_switch]);
  
        if ((interval_approx[index_switch-1][ppw2->index_ap2_rsa]==(int)rsa_off) && 
            (interval_approx[index_switch][ppw2->index_ap2_rsa]==(int)rsa_on))
          fprintf(stdout, "     \\ will switch on radiation streaming approximation at tau = %g\n", interval_limit[index_switch]);
  
        if (pba->has_ur == _TRUE_)
          if ((interval_approx[index_switch-1][ppw2->index_ap2_ufa]==(int)ufa_off) && 
              (interval_approx[index_switch][ppw2->index_ap2_ufa]==(int)ufa_on))
            fprintf(stdout, "     \\ will switch on ur fluid approximation at tau = %g\n", interval_limit[index_switch]);

        if ((interval_approx[index_switch-1][ppw2->index_ap2_nra]==(int)nra_off) && 
            (interval_approx[index_switch][ppw2->index_ap2_nra]==(int)nra_on))
          fprintf(stdout, "     \\ will switch on no-radiation approximation at tau = %g\n", interval_limit[index_switch]);

      } // end of if(verbose)

    } // end of for(index_switch)
  
    free(unsorted_tau_switch);

    class_call(perturb2_approximations(ppr,
                 pba,
                 pth,
                 ppt,
                 ppt2,
                 tau_end,
                 ppw2),     
      ppt2->error_message,
      ppt2->error_message);

  } // end of if(interval_number!=1)

  return _SUCCESS_;

}








































/**
 * Determine which approximation are active at a given time and at a given k-mode.  This function is the second-order
 * equivalent of perturb_approximations.
 *
 * Evaluate background quantities at \f$ \tau \f$, as well as thermodynamics for scalar mode; infer useful flags and time scales for integrating the perturbations:
 * - check whether tight-coupling approximation is needed.
 * - check whether radiation (photons, massless neutrinos...) perturbations are needed.
 * - choose step of integration: step = ppr->perturb_integration_stepsize * min_time_scale, where min_time_scale = smallest time scale involved in the equations. There are three time scales to compare:
 * -# that of recombination, \f$ \tau_c = 1/\kappa' \f$
 * -# Hubble time scale, \f$ \tau_h = a/a' \f$
 * -# Fourier mode, \f$ \tau_k = 1/k \f$
 *
 * So, in general, min_time_scale = \f$ \min(\tau_c, \tau_b, \tau_h, \tau_k) \f$.
 *
 * However, if \f$ \tau_c \ll \tau_h \f$ and \f$ \tau_c
 * \ll \tau_k \f$, we can use the tight-coupling regime for photons
 * and write equations in such way that the time scale \f$
 * \tau_c \f$ becomes irrelevant (no effective mass term in \f$
 * 1/\tau_c \f$).  Then, the smallest
 * scale in the equations is only \f$ \min(\tau_h, \tau_k) \f$.
 * In practise, it is sufficient to use only the condition \f$ \tau_c \ll \tau_h \f$.
 * 
 * Also, if \f$ \rho_{matter} \gg \rho_{radiation} \f$ and \f$ k \gg
 * aH \f$, we can switch off radiation perturbations (i.e. switch on
 * the free-streaming approximation) and then the smallest scale is
 * simply \f$ \tau_h \f$.
 *
 * @param ppr        Input: pointer to precision structure
 * @param pba        Input: pointer to background structure
 * @param pth        Input: pointer to thermodynamics structure
 * @param ppt        Input: pointer to the perturbation structure
 * @param ppt2       Input: pointer to the perturbation2 structure
 * @param tau        Input: conformal time
 * @param ppw2       Input/Output: in output contains the approximation to be used at this time
 * @return the error status
 */

int perturb2_approximations(
         struct precision * ppr,
         struct background * pba,
         struct thermo * pth,
         struct perturbs * ppt,
         struct perturbs2 * ppt2,
         double tau,
         struct perturb2_workspace * ppw2
         )
{

  // *** Determine three important timescales

  /* (a) time scale of Fourier modes, tau_k = 1/k */  
  double tau_k1, tau_k2;
  /* (b) time scale of expansion, tau_h = a/a' */
  double tau_h;
  /* (c) time scale of recombination, tau_c = 1/kappa' */
  double tau_c;


  /* Compute the time scales associated to the Fourier modes k1 and k2, that is tau_k1 = 1/k1 and tau_k2 = 1/k2 */
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  class_test( ((k1==0.) || (k2==0.)), ppt2->error_message, "stop to avoid division by zero");

  tau_k1 = 1./k1;
  tau_k2 = 1./k2;


  /* Compute Hubble time scale tau_h = a/a' */
  class_call (background_at_tau(pba,tau, pba->normal_info, pba->inter_normal, &(ppw2->last_index_back), ppw2->pvecback),
       pba->error_message,
       ppt2->error_message);

  class_test(ppw2->pvecback[pba->index_bg_H]*ppw2->pvecback[pba->index_bg_a] == 0.,
       ppt2->error_message,
       "aH=0, stop to avoid division by zero");

  tau_h = 1./(ppw2->pvecback[pba->index_bg_H]*ppw2->pvecback[pba->index_bg_a]);

    
  /* Evaluate thermodynamical quantities. We do not directly evaluate tau_c = 1/kappa' because
    kappa' can be zero if we are after recombination */
  double a = ppw2->pvecback[pba->index_bg_a];
    
  class_call (thermodynamics_at_z(pba,
         pth,
         1./a-1.,  /* redshift z=1/a-1 */
         pth->inter_normal,
         &(ppw2->last_index_thermo),
         ppw2->pvecback,
         ppw2->pvecthermo),
       pth->error_message,
       ppt2->error_message);
  
  
  

  // *****   Tight coupling approximation   *****
  
  /* By defaul, assume TCA is off */
  ppw2->approx[ppw2->index_ap2_tca] = (int)tca_off;

  /* Flag that determines whether we are past recombination */
  short past_recombination = _TRUE_;
  
  /* Compute recombination time scale for photons, tau_c = 1/kappa' */
  if (ppw2->pvecthermo[pth->index_th_dkappa] != 0.) {

    past_recombination = _FALSE_;
    tau_c = 1./ppw2->pvecthermo[pth->index_th_dkappa];
  }

  /* We trigger the TCA only if the recombination time-scale is smaller than any other time-scale.  Important:
    the 'is_recombination' condition should be first in the list. */
  if ( (past_recombination == _FALSE_) && (ppt2->tight_coupling_approximation != tca2_none) &&
       (tau_c/tau_h < ppt2->tight_coupling_trigger_tau_c_over_tau_h) &&
       (tau_c/min(tau_k1,tau_k2) < ppt2->tight_coupling_trigger_tau_c_over_tau_k) ) {

    ppw2->approx[ppw2->index_ap2_tca] = (int)tca_on;
         
  }



  

  // *****   Free streaming approximation   *****
  
  /* By defaul, assume RSA is off */
  ppw2->approx[ppw2->index_ap2_rsa] = (int)rsa_off;

  /* Turn on the free streaming approximation only if both k1 and k2 are well inside the horizon
    and if we are after recombination */  
  if ( (tau/max(tau_k1,tau_k2) > ppt2->radiation_streaming_trigger_tau_over_tau_k) &&
       (tau > pth->tau_free_streaming) && (ppt2->radiation_streaming_approximation != rsa2_none) ) {

    ppw2->approx[ppw2->index_ap2_rsa] = (int)rsa_on;

  }
 



  // *****   Ultra-relativistic fluid approximation   *****

  /* The UFA is basically radiation streaming for neutrinos, hence the condition for triggering it
    is essentially the same: turn it on only if the mode is both k1 and k2 are well inside the
    horizon.  The difference between RSA and UFA relies in the fact that neutrinos do not care
    about recombination, hence the UFA can be turned on also during or before recombination */
  if (pba->has_ur == _TRUE_) {

    if ( (tau/max(tau_k1,tau_k2) > ppt2->ur_fluid_trigger_tau_over_tau_k) &&
         (ppt2->ur_fluid_approximation != ufa2_none)) {

      ppw2->approx[ppw2->index_ap2_ufa] = (int)ufa_on;

    }
    else {
      
      ppw2->approx[ppw2->index_ap2_ufa] = (int)ufa_off;
      
    }  
  } // end of if(pba->has_ur)



  // *****   No radiation approximation   *****
  
  /* Turn off radiation perturbations well after equality, when their contribution to the total
    density becomes negligible */
  
  /* By defaul, assume NRA is off */
  ppw2->approx[ppw2->index_ap2_nra] = (int)nra_off;

  /* Turn on the no-radiation approximation only if we are well after equality, when the matter to
    radiation density ratio becomes larger than 'ppt2->no_radiation_approximation_rho_m_over_rho_r' */  
  if ( (a/pba->a_eq > ppt2->no_radiation_approximation_rho_m_over_rho_r) &&
       (ppt2->no_radiation_approximation != nra2_none) ) {

    ppw2->approx[ppw2->index_ap2_nra] = (int)nra_on;

  }



  return _SUCCESS_;
}


























/**
  * Here we fill many useful quantities in 'ppw2' related to the system of three wavevectors k, k1, k2.
  * k is the wavevector for which we would like to ultimately compute our second-order perturbations.
  * Contrary to first order, at second order a perturbation in k is given by a convolution integral
  * over two 'mute' wavevectors, k1 and k2, that sum up to k.  That is, k1+k2=k  in the sense of:
  *    kx1 + kx2 = kx,    ky1 + ky2 = ky,     kz1 + kz2 = kz
  * Due to various symmetries, one can freely choose some constraints on the components of k1 and k2.
  * Here, we choose the following:
  *      1)  we align the k vector with the z axis, coinciding with the zenith of the spherical
  *          harmonics Y_lm (theta, phi), that is the axis with respect to which the angle 'theta'
  *          is taken.    This implies that:
  *              kx1 + kx2 = 0,    ky1 + ky2 = 0,    kz1 + kz2 = |k|
  *          where |k| is the magnitude of k.  The effect of such choise greatly simplifies the
  *          system of differential equation, effectively decoupling the evolution of multipoles with
  *          different azimuthal number 'm'.
  *
  *      2)  we impose that both k1 and k2 lie in the x-z axis, which implies:
  *              ky1 = -ky2 = 0.
  *          This also means that the azimuthal angle phi is 0 for one wavevector, and pi for the other.
  *          As an effect, all our equations are real-valued (see also last paragraph of sec. 4.2 of Pitrou 
  *          et al. 2010).
  *          
  * This function is called early on in perturb2_solve.
  * 
  */ 
int perturb2_geometrical_corner(
        struct precision * ppr,
        struct background * pba,
        struct thermo * pth,
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        int index_k1,
        int index_k2,
        int index_cosk1k2,                    
        struct perturb2_workspace * ppw2
        )
{
  

  // ***************               Store basic geometry of the wavemodes          ****************

  // *** Get the Fourier modes
  double k1 = ppw2->k1 = ppt2->k[index_k1];
  double k2 = ppw2->k2 = ppt2->k[index_k2];
  double cosk1k2 = ppw2->cosk1k2 = ppt2->cosk1k2[index_cosk1k2];
  double k_sq = ppw2->k_sq = k1*k1 + k2*k2 +2*k1*k2*cosk1k2;
  double k = ppw2->k = sqrt(k_sq);
  ppw2->index_k1 = index_k1;
  ppw2->index_k2 = index_k2;
  ppw2->index_cosk1k2 = index_cosk1k2;

  if (ppt2->perturbations2_verbose > 2)
    printf(" -> Now considering mode (k1,k2,mu) = (%.7f,%.7f,%.7f)\n", k1, k2, cosk1k2);


  // *** Get the angles (see perturbations2.h for more details)
  double cosk1k = ppw2->cosk1k = (k1 + k2*cosk1k2)/k;
  double cosk2k = ppw2->cosk2k = (k2 + k1*cosk1k2)/k;
  double k1_dot_k2 = ppw2->k1_dot_k2 = k1*k2*cosk1k2;   // scalarProduct(k1,k2)
  ppw2->k1_dot_k  = k1*k*cosk1k;                        // scalarProduct(k1,k)
  ppw2->k2_dot_k  = k2*k*cosk2k;                        // scalarProduct(k2,k)
  
  // *** Get the 'z' components of the wavevectors
  ppw2->kz1 = k1*cosk1k;
  ppw2->kz2 = k2*cosk2k;
  
  /* Get the 'x' components of the wavevectors.
    Here we should be careful.  Since we aligned k with the zenith (see big comment above), we have that:
       kx1 + kx2 = 0  .
    Which means that one between kx1 and kx2 will be negative, and the other positive.  We have the
    freedom to choose which wavemode gets a negative x component. If we arbitrary
    choose that, say, kx1 is always negative and kx2 is always positive, regardless of what are the
    current values of k1 and k2, then we break the k1 <-> k2 symmetry of our differential system.
    By this, we mean that the sources that we compute will be different for, say,
    k1=0.1, k2=0.03  and  k1=0.03, k2=0.1. (The symmetry would be restored only when setting cosk1k2=1 => kx1=kx2=0).
    Hence, here we use a trick: if k1>=k2 we set kx2 as negative, otherwise we set kx1 as negative.
    In this way, we make sure that when switching k1 <-> k2, we actually switch also kx1 and kx2, and not
    only the magnitudes k1 and k2.*/
  if(k1>=k2) {
    ppw2->kx1 = k1*sqrt(1. - cosk1k*cosk1k);
    ppw2->kx2 = -k2*sqrt(1. - cosk2k*cosk2k);
  }
  else {
    ppw2->kx1 = -k1*sqrt(1. - cosk1k*cosk1k);
    ppw2->kx2 = k2*sqrt(1. - cosk2k*cosk2k);   
  }


  // *** Fourier modes in spherical coordinates

  /* k1 */
  double k1_P1 = ppw2->k1_P1 = -ppw2->kx1/sqrt_2;  
  double k1_M1 = ppw2->k1_M1 = -ppw2->k1_P1;
  double k1_0  = ppw2->k1_0  =  ppw2->kz1;
  ppw2->k1_m[0] = k1_M1;
  ppw2->k1_m[1] = k1_0;
  ppw2->k1_m[2] = k1_P1;

  /* k2 */
  double k2_P1 = ppw2->k2_P1 = -ppw2->kx2/sqrt_2;
  double k2_M1 = ppw2->k2_M1 = -ppw2->k2_P1;
  double k2_0  = ppw2->k2_0 = ppw2->kz2;
  ppw2->k2_m[0] = k2_M1;
  ppw2->k2_m[1] = k2_0;
  ppw2->k2_m[2] = k2_P1;


  // *** Tensorial product between k1 and k2
  // This is given by X^ij_m k1_i k2_j, where the X matrix can be found in eq. A.13 of Beneke & Fidler 2010.
  ppw2->k1_ten_k2[0] = sqrt_2/sqrt_3 * k1_M1 * k2_M1;              // m = -2
  ppw2->k1_ten_k2[1] = 1/sqrt_3 * (k1_M1*k2_0 + k2_M1*k1_0);       // m = -1
  ppw2->k1_ten_k2[2] = k1_0*k2_0 - k1_dot_k2/3;                    // m =  0
  ppw2->k1_ten_k2[3] = 1/sqrt_3 * (k1_P1*k2_0 + k2_P1*k1_0);       // m =  1
  ppw2->k1_ten_k2[4] = sqrt_2/sqrt_3 * k1_P1*k2_P1;                // m =  2
                       


  /* Print some debug information about the wavemodes */
  if (ppt2->perturbations2_verbose > 4) {
    
    printf("    * Geometrical quantities associated with the mode:\n");
    printf("      %8.7s%8.7s%8.7s%8.7s%8.7s%8.7s%8.7s%8.7s%8.7s%8.7s\n",
      "k", "cosk1k", "cosk2k", "k1.k2", "k1.k", "k2.k", "kz1", "kz2", "kx1", "kx2");
    printf("      %8.3g%8.3g%8.3g%8.3g%8.3g%8.3g%8.3g%8.3g%8.3g%8.3g\n",
      k,cosk1k,cosk2k,ppw2->k1_dot_k2,ppw2->k1_dot_k,ppw2->k2_dot_k,ppw2->kz1,ppw2->kz2,ppw2->kx1,ppw2->kx2);
    printf("      In spherical coordinates:\n");
    printf("      %8.7s%8.7s%8.7s%8.7s%8.7s%8.7s\n",
      "k1_0", "k2_0", "k1_P1", "k2_P1", "k1_M1", "k2_M1");
    printf("      %8.3g%8.3g%8.3g%8.3g%8.3g%8.3g\n",
      ppw2->k1_0, ppw2->k2_0, ppw2->k1_P1, ppw2->k2_P1, ppw2->k1_M1, ppw2->k2_M1);
  }

  





  // *****************        Compute rotation coefficients        ****************************

  /*  Compute the factors needed to rotate our first-order results from perturbations.c.
   These factors depend on the lm multipole of the first-order perturbation through a
   spherical harmonic of order lm, which becomes a simple Legendre polynomial once we
   make the assumption that ky1=-ky2=0.
   For more details, see BFK 2011, eq. A.6,  or PUB 2010 eq. A.37. */
  int l, m, m2;
  
  /* The following quantities are described in the header file. */
  int l_max = ppt2->l_max;
  int m_max = ppr->m_max_2nd_order;
  int largest_l = ppt2->largest_l;
  int largest_m = ppt2->largest_m;
   
   
  // *** Fill the rotation arrays
  for(l=0; l<=largest_l; ++l) {

    /* The sqrt( 4*pi/(2*l+1) ) factor comes from the definition of the Wigner rotation we are performing
      (see Beneke & Fidler 2011, eq. A.6,  or Pitrou et al. 2010 eq. A.37). */
    double pre_factor = sqrt(4*_PI_/(2*l+1));

    for(m=0; m<=min(l,largest_m); ++m) {
 
      /* We use the convention whereby ky1 = -ky2 = 0.  Hence, one between k1 and k2 has azimuthal
        angle phi=0, while the other has phi=pi.  As we commented in the "Geometrical corner"
        section of this file, we choose that the larger between k1 and k2 gets phi=0.
        The phi=pi wavemode has a minus sign in its rotation coefficients with respect to the phi=0 one,
        coming from the phase of the exponential e^(i*m) in the definition of the spherical harmonics. */
      if(k1>=k2) {
          ppw2->rotation_1[lm_quad(l,m)] = pre_factor * plegendre(l,m,cosk1k);
          ppw2->rotation_2[lm_quad(l,m)] = alternating_sign(m) * pre_factor * plegendre(l,m,cosk2k);
      } else {
          ppw2->rotation_1[lm_quad(l,m)] = alternating_sign(m) * pre_factor * plegendre(l,m,cosk1k);
          ppw2->rotation_2[lm_quad(l,m)] = pre_factor * plegendre(l,m,cosk2k);
      }
 
      if (ppt2->perturbations2_verbose > 5) {
        if ( (ppt2->k_size==1) || ((ppt2->k_size==2)&&(k1>k2)) ) {
          printf("Rotation coefficients at (l,m)=(%3d,%3d), with lm_quad(l,m)=%3d: ", l, m, lm_quad(l,m));
          printf("rot1 = %+10.4g ,   ", ppw2->rotation_1[lm_quad(l,m)]);
          printf("rot2 = %+10.4g\n"   , ppw2->rotation_2[lm_quad(l,m)]);
        }
      }
 
    }  // end of cycle on 'm'
  } // end of cycle on 'l'

  
  // *** Compute the inner products using the coupling coefficients

  /* Define the inner products between Y(1,m)(k1) and Y(l+1,m)(k2) where the weights are given
     by the various coupling coefficients in eq. 141 of Beneke & Fidler 2010.  */

  #define rot_1(l,m) ( (((l) < 0) || (abs(m)>(l))) ? 0 : ( (m) > 0 ? ppw2->rotation_1[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotation_1[lm_quad((l),abs(m))] ) )
  #define rot_2(l,m) ( (((l) < 0) || (abs(m)>(l))) ? 0 : ( (m) > 0 ? ppw2->rotation_2[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotation_2[lm_quad((l),abs(m))] ) )
  
  int mem_count = 0;
  
  for(l=0; l<=l_max; ++l) {
    for(m=0; m<=min(l,m_max); ++m) {

      /* Initialize inner products */
      
      ppw2->c_minus_product_12[lm(l,m)] = ppw2->c_minus_product_21[lm(l,m)] = 0;
      ppw2->c_plus_product_12[lm(l,m)]  = ppw2->c_plus_product_21[lm(l,m)]  = 0;
      ppw2->c_minus_product_11[lm(l,m)] = ppw2->c_minus_product_22[lm(l,m)] = 0;
      ppw2->c_plus_product_11[lm(l,m)]  = ppw2->c_plus_product_22[lm(l,m)]  = 0;

      if (ppt2->has_polarization2) {

        ppw2->d_minus_product_12[lm(l,m)] = ppw2->d_minus_product_21[lm(l,m)] = 0;
        ppw2->d_plus_product_12[lm(l,m)]  = ppw2->d_plus_product_21[lm(l,m)]  = 0;
        ppw2->d_minus_product_11[lm(l,m)] = ppw2->d_minus_product_22[lm(l,m)] = 0;
        ppw2->d_plus_product_11[lm(l,m)]  = ppw2->d_plus_product_22[lm(l,m)]  = 0;

        ppw2->d_zero_product_12[lm(l,m)] = ppw2->d_zero_product_21[lm(l,m)] = 0;
        ppw2->d_zero_product_11[lm(l,m)] = ppw2->d_zero_product_22[lm(l,m)] = 0;
      }

        
      /* Fill the products by summing over m2 */
      
      for (m2=-1; m2<=1; ++m2) {

        int m1 = m-m2;

        /* Intensity couplings */
        ppw2->c_minus_product_12[lm(l,m)] += rot_1(1,m2) * rot_2(l-1,m1) * c_minus(l,m1,m);
        ppw2->c_minus_product_21[lm(l,m)] += rot_2(1,m2) * rot_1(l-1,m1) * c_minus(l,m1,m);
        ppw2->c_plus_product_12[lm(l,m)]  += rot_1(1,m2) * rot_2(l+1,m1) * c_plus(l,m1,m);
        ppw2->c_plus_product_21[lm(l,m)]  += rot_2(1,m2) * rot_1(l+1,m1) * c_plus(l,m1,m);
        ppw2->c_minus_product_11[lm(l,m)] += rot_1(1,m2) * rot_1(l-1,m1) * c_minus(l,m1,m);
        ppw2->c_minus_product_22[lm(l,m)] += rot_2(1,m2) * rot_2(l-1,m1) * c_minus(l,m1,m);
        ppw2->c_plus_product_11[lm(l,m)]  += rot_1(1,m2) * rot_1(l+1,m1) * c_plus(l,m1,m);
        ppw2->c_plus_product_22[lm(l,m)]  += rot_2(1,m2) * rot_2(l+1,m1) * c_plus(l,m1,m);

        if (ppt2->has_polarization2) {

          /* E-mode polarization couplings */
          ppw2->d_minus_product_12[lm(l,m)] += rot_1(1,m2) * rot_2(l-1,m1) * d_minus(l,m1,m);
          ppw2->d_minus_product_21[lm(l,m)] += rot_2(1,m2) * rot_1(l-1,m1) * d_minus(l,m1,m);
          ppw2->d_plus_product_12[lm(l,m)]  += rot_1(1,m2) * rot_2(l+1,m1) * d_plus(l,m1,m);
          ppw2->d_plus_product_21[lm(l,m)]  += rot_2(1,m2) * rot_1(l+1,m1) * d_plus(l,m1,m);
          ppw2->d_minus_product_11[lm(l,m)] += rot_1(1,m2) * rot_1(l-1,m1) * d_minus(l,m1,m);
          ppw2->d_minus_product_22[lm(l,m)] += rot_2(1,m2) * rot_2(l-1,m1) * d_minus(l,m1,m);
          ppw2->d_plus_product_11[lm(l,m)]  += rot_1(1,m2) * rot_1(l+1,m1) * d_plus(l,m1,m);
          ppw2->d_plus_product_22[lm(l,m)]  += rot_2(1,m2) * rot_2(l+1,m1) * d_plus(l,m1,m);

          /* B-mode polarization couplings. Note that there is no l-1 or l+1 here because
            the d_zero mix E and B modes. */
          ppw2->d_zero_product_12[lm(l,m)]  += rot_1(1,m2) * rot_2(l,m1) * d_zero(l,m1,m);
          ppw2->d_zero_product_21[lm(l,m)]  += rot_2(1,m2) * rot_1(l,m1) * d_zero(l,m1,m);
          ppw2->d_zero_product_11[lm(l,m)]  += rot_1(1,m2) * rot_1(l,m1) * d_zero(l,m1,m);
          ppw2->d_zero_product_22[lm(l,m)]  += rot_2(1,m2) * rot_2(l,m1) * d_zero(l,m1,m);
          
        }
      } // end of for(m2)

      /* The R couplings (eq. 142 of BF 2010) are obtained from the C ones */
      ppw2->r_minus_product_12[lm(l,m)] =  (l-1) * ppw2->c_minus_product_12[lm(l,m)];
      ppw2->r_minus_product_21[lm(l,m)] =  (l-1) * ppw2->c_minus_product_21[lm(l,m)];
      ppw2->r_plus_product_12[lm(l,m)]  = -(l+2) * ppw2->c_plus_product_12[lm(l,m)];
      ppw2->r_plus_product_21[lm(l,m)]  = -(l+2) * ppw2->c_plus_product_21[lm(l,m)];


      if (ppt2->has_polarization2) {
        
        /* The K couplings (eq. 142 of BF 2010) are obtained from the D ones */
        ppw2->k_minus_product_12[lm(l,m)] =  (l-1) * ppw2->d_minus_product_12[lm(l,m)];
        ppw2->k_minus_product_21[lm(l,m)] =  (l-1) * ppw2->d_minus_product_21[lm(l,m)];
        ppw2->k_plus_product_12[lm(l,m)]  = -(l+2) * ppw2->d_plus_product_12[lm(l,m)];
        ppw2->k_plus_product_21[lm(l,m)]  = -(l+2) * ppw2->d_plus_product_21[lm(l,m)];
        ppw2->k_minus_product_11[lm(l,m)] =  (l-1) * ppw2->d_minus_product_11[lm(l,m)];
        ppw2->k_minus_product_22[lm(l,m)] =  (l-1) * ppw2->d_minus_product_22[lm(l,m)];
        ppw2->k_plus_product_11[lm(l,m)]  = -(l+2) * ppw2->d_plus_product_11[lm(l,m)];
        ppw2->k_plus_product_22[lm(l,m)]  = -(l+2) * ppw2->d_plus_product_22[lm(l,m)];
        ppw2->k_zero_product_12[lm(l,m)]  = -ppw2->d_zero_product_12[lm(l,m)];
        ppw2->k_zero_product_21[lm(l,m)]  = -ppw2->d_zero_product_21[lm(l,m)];
        ppw2->k_zero_product_11[lm(l,m)]  = -ppw2->d_zero_product_11[lm(l,m)];
        ppw2->k_zero_product_22[lm(l,m)]  = -ppw2->d_zero_product_22[lm(l,m)];
      }

      /* Some debug */
      // if ( (index_k1 == 0) && (index_k2 == 0) && (index_cosk1k2 == 1) ) {
      //    printf("~~~~~ Inner products at (l,m)=(%3d,%3d), with lm(l,m)=%3d: \n", l, m, lm(l,m));
      //    printf("c_minus_product_12 = %+10.4g ,   ", ppw2->c_minus_product_12[lm(l,m)]);
      //    printf("c_minus_product_21 = %+10.4g\n"   , ppw2->c_minus_product_21[lm(l,m)]);
      //    printf("Produp12 = %+10.4g ,   ", ppw2->c_plus_product_12[lm(l,m)]*(2*l+3));
      //    printf("Produp21 = %+10.4g\n"   , ppw2->c_plus_product_21[lm(l,m)]*(2*l+3));
      //    printf("Proddown12 = %+10.4g ,   ", ppw2->c_minus_product_12[lm(l,m)]*(2*l-1));
      //    printf("Proddown21 = %+10.4g\n"   , ppw2->c_minus_product_21[lm(l,m)]*(2*l-1));
      //    printf("\n");
      // }

    } // end of for(m)
  } // end of for(l)
  #undef rot_1
  #undef rot_2
  
  
  



  // *************************       Perform checks on the geometry        ****************************


  /* Check that kx1 = -kx2 (follows from k1+k2 = k) */
  class_test (
    fabs(ppw2->kx1+ppw2->kx2) > _EPS_,
    ppt2->error_message,
    "kx1 != -kx2, there must be an error in the computation of the wavemodes angles.");

  /* Check that the scalar product is independent of the adopted k-coordinates */
  double k1_dot_k2_spherical = ppw2->k1_0*ppw2->k2_0 - ppw2->k1_M1*ppw2->k2_P1 - ppw2->k1_P1*ppw2->k2_M1;
  class_test (
    fabs(k1_dot_k2_spherical - ppw2->k1_dot_k2) > _EPS_,
    ppt2->error_message,
    "the scalar product k1.k2 changes between spherical and cartesian coordinates.");


  /* Simple check on the 'plegendre' routine.  The monopole is not affected by the rotation,
    hence rotation_1[0] should be equal to one regardless of the considered wavemodes. */
  class_test(fabs(ppw2->rotation_1[lm_quad(0,0)]-1.) > _EPS_,
    ppt2->error_message,
    "the l=1 rotation coefficient is different from 1. There must be a mistake in the way the geometrical quantities are computed.");

  /* Another check for 'plegendre'.  The l=1 rotation coefficients for the k-wavemode must
    be equal to unit k-vector in spherical coordinates.  This is just a property of
    spherical harmonics. */
  class_test(
    fabs(k1*ppw2->rotation_1[lm_quad(1,0)]-ppw2->k1_0) > _EPS_ || fabs(k1*ppw2->rotation_1[lm_quad(1,1)]-ppw2->k1_P1) > _EPS_ ||
    fabs(k2*ppw2->rotation_2[lm_quad(1,0)]-ppw2->k2_0) > _EPS_ || fabs(k2*ppw2->rotation_2[lm_quad(1,1)]-ppw2->k2_P1) > _EPS_,  
    ppt2->error_message,
    "the l=1 rotation coefficient is not correct. There must be a mistake in the way the geometrical quantities are computed.");

  /* Check that the the inner coupling with c_minus is zero for l=m=0.  We need this to
    be true, otherwise the monopole hierarchy would be coupled to the l=-1 moment. */
  class_test (
    (fabs(ppw2->c_minus_product_12[lm(0,0)])>_EPS_) || (fabs(ppw2->c_minus_product_21[lm(0,0)])>_EPS_),
    ppt2->error_message,
    "found wrong value for c_minus(l=0,m=0). There must be a mistake in the way the geometrical quantities are computed.");

  /* Check that the the inner product with c_minus for l=1, m=0 is equal to rot_1*rot_2. This
    has to be the case because c_minus(1,m1,0) != 0 only if m1 = 0. */
  class_test (
    (fabs(ppw2->c_minus_product_12[lm(1,0)]-ppw2->rotation_1[lm_quad(1,0)]*ppw2->rotation_2[lm_quad(0,0)])>_EPS_) 
    || (fabs(ppw2->c_minus_product_21[lm(1,0)]-ppw2->rotation_2[lm_quad(1,0)]*ppw2->rotation_1[lm_quad(0,0)])>_EPS_),
    ppt2->error_message,
    "found wrong value for c_minus(l=1,m=0). There must be a mistake in the way the geometrical quantities are computed.");

  /* Check that the d_zero-inner-product for m=0 (scalar modes) vanishes.  This is equivalent
    to test that B-mode polarization at second order is negligible for m=0, as it is clear from
    eq. 2.17 of BFK. */
  if (ppt2->has_polarization2 == _TRUE_)
    for(l=0; l<=l_max; ++l)
      class_test ( fabs(ppw2->d_zero_product_12[lm(l,0)]) > _EPS_,
          ppt2->error_message,
          "found d_zero_product(l,0) != 0. There must be a mistake in the way the geometrical quantities are computed.");

  /* There will be plenty of divisions in what follows. */
  class_test((k1==0.) || (k2==0.) || (k_sq==0.),
       ppt2->error_message,
       "stop to avoid division by zero");
  
 
  return _SUCCESS_;
  
}




/**
  * Simple function to fill the ppw2->info string with useful information about the wavemode
  * that is currently being integrated
  */
int perturb2_wavemode_info(
        struct precision * ppr,
        struct background * pba,
        struct thermo * pth,
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        struct perturb2_workspace * ppw2
        )
{

  /*  We shall write on ppw2->info line by line, commenting each line with the below
    comment style. */
  char comment[2] = "#";
  char line[1024];
  char * info = ppw2->info;
  
  sprintf(info, "");

  sprintf(line, "Cosmological parameters:");
  sprintf(info, "%s%s %s\n", info, comment, line);

  sprintf(line, "a_equality = %g, Omega_b = %g, Tcmb = %g, Omega_cdm = %g, Omega_lamda = %g, Omega_ur = %g, Omega_fld = %g, h = %g, tau0 = %g",
    pba->a_eq, pba->Omega0_b, pba->T_cmb, pba->Omega0_cdm, pba->Omega0_lambda, pba->Omega0_ur, pba->Omega0_fld, pba->h, pba->conformal_age);

  sprintf(line, "Omega_b = %g, Tcmb = %g, Omega_cdm = %g, Omega_lamda = %g, Omega_ur = %g, Omega_fld = %g",
    pba->Omega0_b, pba->T_cmb, pba->Omega0_cdm, pba->Omega0_lambda, pba->Omega0_ur, pba->Omega0_fld);
  sprintf(info, "%s%s %s\n", info, comment, line);

  sprintf(line, "h = %g, conformal_age = %g, a_equality = %g, k_equality = %g",
    pba->h, pba->conformal_age, pba->a_eq, pba->k_eq);
  sprintf(info, "%s%s %s\n", info, comment, line);
  
  double h = pba->h;
  sprintf(line, "omega_b = %g, omega_cdm = %g, omega_lamda = %g, omega_ur = %g, omega_fld = %g",
    pba->Omega0_b*h*h, pba->Omega0_cdm*h*h, pba->Omega0_lambda*h*h, pba->Omega0_ur*h*h, pba->Omega0_fld*h*h);
  sprintf(info, "%s%s %s\n", info, comment, line);

  sprintf(line, "k1 = %g, k2 = %g, cosk1k2 = %g, k = %g", ppw2->k1, ppw2->k2, ppw2->cosk1k2, ppw2->k);
  sprintf(info, "%s%s %s\n", info, comment, line);

  if (ppt->gauge == newtonian) sprintf(line, "gauge = Newtonian gauge");
  if (ppt->gauge == synchronous) sprintf(line, "gauge = synchronous gauge");
  sprintf(info, "%s%s %s\n", info, comment, line);

  return _SUCCESS_;

}






int perturb2_solve (
        struct precision * ppr,
        struct background * pba,
        struct thermo * pth,
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        int index_k1,
        int index_k2,
        int index_cosk1k2,                    
        struct perturb2_workspace * ppw2
        )
{
          

  // *********************       Update the workspace      **************************


  // *** Compute useful geometrical quantities related to the considered (k1,k2,cosk1k2) triplet.
  class_call(perturb2_geometrical_corner(
               ppr,
               pba,
               pth,
               ppt,
               ppt2,
               index_k1,
               index_k2,
               index_cosk1k2,
               ppw2),
    ppt2->error_message,
    ppt2->error_message);


  // *** Get the Fourier modes
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  double cosk1k2 = ppw2->cosk1k2;
  double k_sq = ppw2->k_sq;
  double k = ppw2->k;


  // *** Store some useful information in ppw2->info for debugging purposes
  class_call(perturb2_wavemode_info(
               ppr,
               pba,
               pth,
               ppt,
               ppt2,
               ppw2),
    ppt2->error_message,
    ppt2->error_message);
        

   // *** Should we create debug files for this particular k1,k2,cosk1k2?
  ppw2->print_function = NULL;
  if (  (ppt2->has_debug_files == _TRUE_)
           && (index_k1 == ppt2->index_k1_debug)
           && (index_k2 == ppt2->index_k2_debug)
           && (index_cosk1k2 == ppt2->index_cosk1k2_debug) )
    ppw2->print_function = perturb2_save_early_transfers;


  // *** Initialize indices relevant for back/thermo tables search
  ppw2->last_index_back=0;
  ppw2->last_index_thermo=0;
  ppw2->last_index_sources=0;  








  // **************************          Determine starting integration time        ***************************
  
  /* Variable that shall contain the starting integration time for this set of wavemodes */
  double tau;
  
  /* We automatically determine the starting integration time for this set of wavemodes only if the user
    specified 'ppt2->tau_start_evolution = 0'. */
  if (ppt2->tau_start_evolution == 0) {
  
    /* Conformal time */
    double tau_lower, tau_upper, tau_mid;

    /* Index running over time */
    int index_tau;

    /* Using bisection, compute minimum value of tau for which this wavenumber is integrated.
      The actual starting time of integration will be the minimum between the number we find
      here and ppt2->tau_sampling[0]. */

    /* Initial time will be at least the first time in the background table */
    tau_lower = pba->tau_table[0];

    /* Test that tau_lower is early enough to satisfy the conditions imposed by
      ppr->start_small_k_at_tau_c_over_tau_h_2nd_order and ppr->start_large_k_at_tau_h_over_tau_k.
      To use CLASS1 words: check that this initial time is indeed OK given imposed conditions on kappa'
      and on k/aH. */

    class_call (background_at_tau(pba,
                  tau_lower, 
                  pba->normal_info, 
                  pba->inter_normal, 
                  &(ppw2->last_index_back), 
                  ppw2->pvecback),
      pba->error_message,
      ppt2->error_message);


    class_call (thermodynamics_at_z(pba,
                  pth,
                  1./ppw2->pvecback[pba->index_bg_a]-1.,
                  pth->inter_normal,
                  &(ppw2->last_index_thermo),
                  ppw2->pvecback,
                  ppw2->pvecthermo),
      pth->error_message,
      ppt2->error_message);
  
    /* Variables that simplify the notation */
    double aH = ppw2->pvecback[pba->index_bg_a]*ppw2->pvecback[pba->index_bg_H];
    double tau_c_over_tau_h = aH/ppw2->pvecthermo[pth->index_th_dkappa];
    double tau_h_over_tau_k = max(k1,k2)/aH;
  
    class_test (tau_c_over_tau_h > ppr->start_small_k_at_tau_c_over_tau_h_2nd_order,
                ppt2->error_message,
                "your choice of initial time for integrating wavenumbers at 2nd-order is inappropriate: it corresponds to a time before that at which the background has been integrated. You should increase 'start_small_k_at_tau_c_over_tau_h_2nd_order' up to at least %g, or decrease 'a_ini_over_a_today_default'\n", 
                  tau_c_over_tau_h);
  
    class_test (tau_h_over_tau_k > ppr->start_large_k_at_tau_h_over_tau_k_2nd_order,
                ppt2->error_message,
                "your choice of initial time for integrating wavenumbers at 2nd-order is inappropriate: it corresponds to a time before that at which the background has been integrated. You should increase 'start_large_k_at_tau_h_over_tau_k_2nd_order' up to at least %g, or decrease 'a_ini_over_a_today_default'\n",
                  ppt2->k[ppt2->k_size-1]/aH);
 
    
    /* We have to start integrating the system earlier with respect to when we need the sources */
    tau_upper = ppt2->tau_sampling[0];
    tau_mid = 0.5*(tau_lower + tau_upper);
  
    /* Print the result for the bisection for these wavemodes (to be paired with
      the debug line soon out of this cycle */
    // printf("*** Bisection for k1 = %8.2g,  k2 = %8.2g,  cosk1k2 = %8.2g:   ", k1, k2, cosk1k2);
    // printf("tau_lower = %8.2g, tau_upper = %8.2g, ", tau_lower, tau_upper);




    // ==========================================
    // =         Start actual bisection         =
    // ==========================================
    
    while ((tau_upper - tau_lower)/tau_lower > ppr->tol_tau_approx) {

      /* Interpolate background quantities */
      class_call (background_at_tau(pba,
            tau_mid, 
            pba->normal_info, 
            pba->inter_normal, 
            &(ppw2->last_index_back), 
            ppw2->pvecback),
         pba->error_message,
         ppt2->error_message);

      aH = ppw2->pvecback[pba->index_bg_a]*ppw2->pvecback[pba->index_bg_H];
      tau_h_over_tau_k = max(k1,k2)/aH;

      /* Interpolate thermodynamical quantities */
      class_call (thermodynamics_at_z(pba,
              pth,
              1/ppw2->pvecback[pba->index_bg_a]-1,  /* redshift z=1./a-1 */
              pth->inter_normal,
              &(ppw2->last_index_thermo),
              ppw2->pvecback,
              ppw2->pvecthermo),
            pth->error_message,
            ppt2->error_message);

      tau_c_over_tau_h = aH/ppw2->pvecthermo[pth->index_th_dkappa];

      /* Check that the two conditions on (aH/kappa') and (aH/k) are fulfilled */
      if ((tau_c_over_tau_h > ppr->start_small_k_at_tau_c_over_tau_h_2nd_order) ||
          (tau_h_over_tau_k > ppr->start_large_k_at_tau_h_over_tau_k_2nd_order)) {

        tau_upper = tau_mid;
      }
      else {
        tau_lower = tau_mid;
      }

      tau_mid = 0.5*(tau_lower + tau_upper);
      
      /* Some debug */
      // printf("tau_lower = %g\n", tau_lower);
      // printf("tau_upper = %g\n", tau_upper);
      // printf("tau_mid = %g\n", tau_mid);
      // printf("\n");
    
    } // end of bisection
    
    tau = tau_mid;
  
  } // end of if(ppt2->tau_start_evolution==0)
  
  /* If the user specified a custom starting integration, we employ that regardless of the considered
    set of wavemodes */
  else {
  
    /* The initial integration time should be smaller than the lowest time were we need to sample
      the line-of-sight sources */
    tau = min (ppt2->tau_start_evolution, ppt2->tau_sampling[0]);
  
  } // end of if(ppt2->tau_start_evolution!=0)


  /* Print information on the starting integration time */
  if (ppt2->perturbations2_verbose > 3)
    printf("    * we shall start to evolve this wavemode at tau=%g\n", tau);

  /* The starting integration time should be larger than the minimum time for which we sampled the first-order system */
  class_test (tau < ppt->tau_sampling_quadsources[0],
              ppt2->error_message,
              "tau_ini for the second-order system should be larger than the time where we start to sample the 1st-order quantities");



  // ***********************         Determine final integration time        **********************
  
  /* When should we stop to evolve the equations? This is controlled by the last element in the
    ppt2->tau_sampling array, which is determined according to the needed line-of-sight sources
    (i.e. on has_metric_in_los and has_lensing_in_los)  */
  double taumax = ppt2->tau_sampling[ppt2->tau_size-1];    /* maximum value of conformal time for current wavenumber */
  int tau_actual_size = ppt2->tau_size;                    /* number of values in the ppt2->tau_sampling array that should be considered for a given mode */









  // ***************************          Deal with approximations      ***************************

  /* Number of time intervals where the approximation scheme is uniform */
  int interval_number;

  /* Index running over such time intervals */
  int index_interval;

  /* Number of time intervals where each particular approximation is uniform.  It is either equal to one
    (when the approximation never changes its state i.e. it is always turned ON or OFF), or equal to two
    (when the approximation changes its state from ON to OFF or from OFF to ON).  */
  int * interval_number_of;

  /* Edge of intervals where approximation scheme is uniform: tau_ini, tau_switch_1, ..., tau_end */
  double * interval_limit;

  /* Array of approximation scheme within each interval: interval_approx[index_interval][index_ap].
    It is used inside the loop on the approximation interval to determine which approximation is
    active for each interval */
  int ** interval_approx;

  /* Index running over approximations */
  int index_ap;

  /* Approximation scheme within previous interval: previous_approx[index_ap] */
  int * previous_approx;





  /* Find the number of intervals over which approximation scheme is constant */
  
  class_alloc(interval_number_of, ppw2->ap2_size*sizeof(int), ppt2->error_message);
  
  ppw2->inter_mode = pba->inter_normal;
  
  class_call(perturb2_find_approximation_number(
               ppr,
               pba,
               pth,
               ppt,
               ppt2,
               ppw2,
               tau,
               ppt2->tau_sampling[tau_actual_size-1],
               &interval_number,
               interval_number_of),
    ppt2->error_message,
    ppt2->error_message);
  
  class_alloc(interval_limit,(interval_number+1)*sizeof(double),ppt2->error_message);
  
  /* We shall use the 'interval_approx' array to determine what is the active approximation 
    for each interval */
  class_alloc(interval_approx,interval_number*sizeof(int*),ppt2->error_message);
  
  for (index_interval=0; index_interval < interval_number; index_interval++)
    class_alloc(interval_approx[index_interval], ppw2->ap2_size*sizeof(int), ppt2->error_message);
  
  class_call (perturb2_find_approximation_switches(ppr,
                pba,
                pth,
                ppt,
                ppt2,
                ppw2,
                tau,
                ppt2->tau_sampling[tau_actual_size-1],
                ppr->tol_tau_approx,
                interval_number,
                interval_number_of,
                interval_limit,
                interval_approx),
    ppt2->error_message,
    ppt2->error_message);
  
  free(interval_number_of);





  // **************************          Pre-compute quadratic sources        ***************************
  
  
  if (ppt2->has_quadratic_sources == _TRUE_) {
  
    if (ppt2->perturbations2_verbose > 3)
      printf("    * computing quadratic sources for the considered mode\n");
  
    class_call(perturb2_quadratic_sources_for_k1k2mu(
              ppr,
              pba,
              pth,            
              ppt,
              ppt2,
              ppw2
              ),
          ppt2->error_message,
          ppt2->error_message);
  }


  
  /* Instantiate and fill the structure containing all fixed parameters, indices
      and workspaces needed by perturb2_derivs */
  struct perturb2_parameters_and_workspace ppaw2;
  ppaw2.ppr = ppr;
  ppaw2.pba = pba;
  ppaw2.pth = pth;
  ppaw2.ppt = ppt;
  ppaw2.ppt2 = ppt2;
  ppaw2.ppw2 = ppw2;
  
  /* Reset the counter that keeps track of the number of calls of the function perturb2_derivs */
  ppw2->derivs_count = 0;







  // ***************************          Integrate the system      ***************************

  /* Loop over the time intervals over which approximation scheme is uniform. For each interval,
    solve the differential system using either the Runge-Kutta evolver or the implicit one. */
  
  for (index_interval=0; index_interval < interval_number; index_interval++) {

    /* Determine which are the approximations that are turned on over the considered time 
      interval */
    for (index_ap=0; index_ap < ppw2->ap2_size; index_ap++)
      ppw2->approx[index_ap] = interval_approx[index_interval][index_ap];


    /* Get the previous approximation scheme. If the current interval starts from the initial
      time tau_ini, the previous approximation is set to be a NULL pointer, so that the function
      perturb_vector_init() knows that perturbations must be initialized with primordial initial
      conditions */

    if (index_interval==0)
      previous_approx = NULL;

    else
      previous_approx = interval_approx[index_interval-1];




    // ********      Set initial conditions      **********

    /* Define the vector of perturbations to be integrated over. If the current interval starts
    from the initial time tau_ini, fill the vector with initial conditions. If it starts from
    an approximation switching point, redistribute correctly the perturbations from the previous
    to the new vector of perturbations. */

    class_call(perturb2_vector_init(
                 ppr,
                 pba,
                 pth,
                 ppt,
                 ppt2,
                 interval_limit[index_interval],
                 ppw2,
                 previous_approx),                  /* We are just looking for initial conditions here */
     ppt2->error_message,
     ppt2->error_message);
 



    // ********      Evolve the system      **********

    /* Function pointer to ODE evolver and names of possible evolvers */
    extern int evolver_rk();
    extern int evolver_ndf15();   
    int (*generic_evolver)();

    if(ppr->evolver == rk)
      generic_evolver = evolver_rk;
    else
      generic_evolver = evolver_ndf15;

    class_call(generic_evolver(
                 perturb2_derivs,
                 interval_limit[index_interval],
                 interval_limit[index_interval+1],
                 ppw2->pv->y,
                 ppw2->pv->used_in_sources,
                 ppw2->pv->pt2_size,
                 &ppaw2,
                 ppr->tol_perturb_integration_2nd_order,
                 ppr->smallest_allowed_variation,
                 perturb2_timescale,     /* Not needed when using the ndf15 integrator */
                 ppr->perturb_integration_stepsize,
                 ppt2->tau_sampling,
                 tau_actual_size,
                 perturb2_source_terms,
                 /* next entry = 'NULL' in standard
              runs; = 'perturb2_print_variables' if
              you want to output perturbations at
              each integration step for testing
              purposes; = 'perturb2_save_early_transfers'
              if you want to save to file the steps;
              = 'ppw2->print_function' if you want
              to automatically select which function
              to use according to the 'ppt2->has_debug_files
              option.  */
                 // NULL,
                 // perturb2_print_variables,
                 // perturb2_save_early_transfers,
                 ppw2->print_function,
                 /* Exit strategy */
                 what_if_ndf15_fails,
                 ppt2->error_message),
      ppt2->error_message,
      ppt2->error_message);


  } // end of for(index_interval)



  /* Free quantitites allocated at the beginning of the routine */  
  class_call(perturb2_vector_free(ppw2->pv),
     ppt2->error_message,
     ppt2->error_message);


  /* Add to the sources the effects that depend on the time derivative of perturbations (e.g. the ISW effect) */
  class_call (perturb2_sources (
                ppt2,
                ppw2),
    ppt2->error_message,
    ppt2->error_message);


  return _SUCCESS_;
          
}
          
          
          
          









/**
  * This function is called in the innermost cycle of our code.  Here we allocate the pt2 indices
  * and set the initial conditions for every single k1,k2,cosk1k2 configuration.
  *
  * IMPORTANT:  do not break the hierarchies.  If you have to add another variable to be evolved, make sure that you
  * associate to it a pt2 index that is not in the middle of a Boltzmann hierarchy.  For example, if you put your 
  * new variable between 'index_pt2_monopole_g' and 'index_pt2_monopole_g+1', you will break the hierarchy and generate
  * unpredictable numerical errors.  This happens because the dy vector is filled assuming that the dipole follows
  * the monopole, the shear follows the dipole, l3 follows the shear, and all the other l_max-3 moments follow
  * l3 in a sequential way.
  */
int perturb2_vector_init(
      struct precision * ppr,
      struct background * pba,
      struct thermo * pth,
      struct perturbs * ppt,
      struct perturbs2 * ppt2,
      double tau,
      struct perturb2_workspace * ppw2, /* ppw2->pv unallocated if pa_old = NULL, allocated and filled otherwise */
      int * pa_old 
      )
{


  /* Create a temporary perturb2_vector structure that we shall fill, and eventually place
    into ppw2->pv will point at the end of this function */
  struct perturb2_vector * ppv;
  class_alloc (ppv, sizeof(struct perturb2_vector), ppt2->error_message);

  // *** Shorcuts
  ppv->m_max = ppr->m_max_2nd_order;
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;  
  double cosk1k2 = ppw2->cosk1k2;
  int m;




  // **********************         Find out what has to be evolved        *******************

  int index_pt = 0;


  /* Make sure we are integrating at least 3 moments in the hierarchy */
  class_test (ppr->l_max_g_2nd_order < 2,
    ppt2->error_message,
    "ppr->l_max_g_2nd_order should be at least 3, i.e. we must integrate at least over photon density, velocity, shear and third moment.");


  /* To compute the second-order multipoles up to l_max, we need the first-order ones up to l_max + n,
    with n=1 in Newtonian gauge and n=3 in synchronous gauge. */
  class_test (ppr->l_max_g_2nd_order + ppt2->lm_extra > ppr->l_max_g,
              ppt2->error_message,
              "to solve the second-order photon hierarchy up to l=%d, you need to specify l_max_g > %d",
              ppr->l_max_g_2nd_order, ppr->l_max_g_2nd_order+3);




  /* IMPORTANT ANNOUNCEMENT :-) Make sure you do not interrupt the ordering inside each of
    the hierarchies, because throughout the code we shall make assumptions on such ordering.
    In particular, we shall index the (l,m) moment by 'index_pt2_monopole + lm(l,m)'.  */




  // *****   Find the number of equations to evolve    ******


  /* By default, the number of equations evolved for the radiation species is determined directly
    by the parameter file.  */
  ppv->l_max_g = ppr->l_max_g_2nd_order;
  ppv->n_hierarchy_g = lm_number_of_elements(ppv->l_max_g, ppv->m_max);

  /* The E and B-mode hierarchies start from the quadrupole, hence the number of equations is reduced.
    However, we treat the polarization hierarchy as if it started from the monopole, as it is simpler
    to implement it inside the code.  In this way we introduce a fake monopole and dipole that are not
    really evolved but are taken to be always zero */
  if (ppt2->has_polarization2 == _TRUE_) {
    ppv->l_max_pol_g = ppr->l_max_pol_g_2nd_order;
    ppv->n_hierarchy_pol_g = lm_number_of_elements(ppv->l_max_pol_g, ppv->m_max);
  }
  
  if (pba->has_ur == _TRUE_) {
    ppv->l_max_ur = ppr->l_max_ur_2nd_order; 
    ppv->n_hierarchy_ur = lm_number_of_elements(ppv->l_max_ur, ppv->m_max);
  }


  /* If the no_radiation_approximation is turned on, we need to evolve fewer equations */
  if (ppw2->approx[ppw2->index_ap2_nra] == (int)nra_on) {

    /* Do not evolve relativistic species at all if we are adopting 'nra2_all'.  We take the
      l_max's to be equal to -1 so that a cycle starting from zero on 'l' will not even enter
      the first iteration. */
    if (ppt2->no_radiation_approximation == (int)nra2_all) {

      ppv->l_max_g = -1;
      ppv->n_hierarchy_g = 0;
      
      ppv->l_max_pol_g = -1;
      ppv->n_hierarchy_pol_g = 0;
      
      ppv->l_max_ur = -1;
      ppv->n_hierarchy_ur = 0;
    }
    /* Treat the relativistic species as perfect fluid if we are adopting 'nra2_fluid' */
    else if (ppt2->no_radiation_approximation == (int)nra2_fluid) {

      ppv->l_max_g = 1;
      ppv->n_hierarchy_g = lm_number_of_elements(ppv->l_max_g, ppv->m_max);

      ppv->l_max_pol_g = 1;
      ppv->n_hierarchy_pol_g = lm_number_of_elements(ppv->l_max_pol_g, ppv->m_max);
      
      ppv->l_max_ur = 1; 
      ppv->n_hierarchy_ur = lm_number_of_elements(ppv->l_max_ur, ppv->m_max);
    }

  } // end of if (nra_on)



  // =======================================
  // =          Photon temperature         =
  // =======================================

  if (ppt2->perturbations2_verbose > 4)
    printf("    * photon temperature hierarchy: we shall evolve %d equations (l_max_g = %d).\n", ppv->n_hierarchy_g, ppv->l_max_g);

  /* The first moment of the hierarchy is the monopole l=0, m=0.  The other equations follow
    it in the order given by lm_offset. */
  ppv->index_pt2_monopole_g = index_pt;
  index_pt += ppv->n_hierarchy_g;


  // ========================================
  // =          Photon polarization         =
  // ========================================

  if (ppt2->has_polarization2 == _TRUE_) {

    if (ppt2->perturbations2_verbose > 4)
      printf("    * photon E-mode & B-mode hierarchies: we shall evolve %d equations (l_max_pol_g = %d).\n", 2*ppv->n_hierarchy_pol_g, ppv->l_max_pol_g);

    // *** Photon E-mode polarization
    ppv->index_pt2_monopole_E = index_pt;
    index_pt += ppv->n_hierarchy_pol_g;

    // *** Photon B-mode polarization
    /* TODO: No need to evolve the B-modes if m==0 */
    ppv->index_pt2_monopole_B = index_pt;
    index_pt += ppv->n_hierarchy_pol_g;
    
  } // end of if(has_polarization2)


  // =======================================================
  // =              Ultra Relativistic Neutrinos           =
  // =======================================================
  if (pba->has_ur == _TRUE_) {

    /* Reject inconsistent values of the number of mutipoles in ultra relativistic neutrino hierachy */
    class_test(ppr->l_max_ur_2nd_order < 4,
      ppt2->error_message,
      "ppr->l_max_ur_2nd_order should be at least 4, i.e. we must integrate at least over neutrino/relic density, velocity, shear, third and fourth momentum");

    /* To compute the second-order multipoles up to l_max, we need the first-order ones up to l_max + n,
      with n=1 in Newtonian gauge and n=3 in synchronous gauge. */
    class_test(ppr->l_max_ur_2nd_order+ppt2->lm_extra > ppr->l_max_ur,
      ppt2->error_message,
      "to solve the second-order neutrino hierarchy up to l=%d, you need to specify l_max_ur > %d",
        ppr->l_max_ur_2nd_order, ppr->l_max_ur_2nd_order+3);


    if ((pba->has_ur) && (ppt2->perturbations2_verbose > 4))
      printf("    * neutrino hierarchy: we shall evolve %d equations (l_max_ur = %d).\n", ppv->n_hierarchy_ur, ppr->l_max_ur_2nd_order);

    ppv->index_pt2_monopole_ur = index_pt;
    index_pt += ppv->n_hierarchy_ur;

  } // end of if(has_ur)



  // =======================================
  // =                Baryons              =
  // =======================================

  /* We treat baryons as a fluid with pressure and anisotropic stresses.  In terms of
    of beta-moments (i.e. the 3-indices generalization of multipoles whereby the first
    index 'n' is the momentum hierarchy, and the last two are the angular hierarchy),
    we keep only those beta-moments with n<=2.
    As for photons, do not interrupt the hierarchies!  If you want to add differential
    equations to the system, do it before or after this group of initializations.
    We shall index the (n,l,m) moment of the hierarchy by 'index_pt2_monopole_b + nlm_b(n,l,m)'.
  */
  int n_max_b = 2;
  int l_max_b = 2;
  ppv->n_hierarchy_b = nlm_constrained_number_of_elements(n_max_b, l_max_b, ppv->m_max);        

  if (ppt2->perturbations2_verbose > 4)
    printf("    * baryon hierarchy: we shall evolve %d equations (n_max = %d, l_max = %d).\n", ppv->n_hierarchy_b, n_max_b, l_max_b);

  ppv->index_pt2_monopole_b = index_pt;
  index_pt += ppv->n_hierarchy_b;    


  // ==============================================
  // =               Cold Dark Matter             =
  // ==============================================
  if (pba->has_cdm == _TRUE_) {

    int n_max_cdm = 2;
    int l_max_cdm = 2;
    ppv->n_hierarchy_cdm = nlm_constrained_number_of_elements(n_max_cdm, l_max_cdm, ppv->m_max);        

    if (ppt2->perturbations2_verbose > 4)
      printf("    * cold dark matter hierarchy: we shall evolve %d equations (n_max = %d, l_max = %d).\n", ppv->n_hierarchy_cdm, n_max_cdm, l_max_cdm);

    ppv->index_pt2_monopole_cdm = index_pt;
    index_pt += ppv->n_hierarchy_cdm;    
  }




  // ===================================================
  // =                 Metric Perturbations            =
  // ===================================================

  /* Remember that here should go only the quantitites to be integrated, not those
   obeying constraint equations */
   
  // **** Newtonian gauge
  /* We shall evolve the curvature potential phi, too */
  if (ppt->gauge == newtonian) {
    ppv->index_pt2_phi = index_pt++;       /* Phi, curvature potential */
  }

  // *** Synchronous gauge
  if (ppt->gauge == synchronous) {
    ppv->index_pt2_eta = index_pt++;       /* eta as in Ma & Berschinger (1995) */
  }


  /* Finally, the number of differential equations to solve */
  ppv->pt2_size = index_pt;

  if (ppt2->perturbations2_verbose > 3)
    printf("    * we shall evolve %d equations\n", ppv->pt2_size);





  // **********************         Allocate arrays        *******************

  /* Allocate vectors for storing the values of all these quantities and their time-derivatives
    at a given time. Note that the allocation for y is made with calloc, so that in the following we
    shall only need to specify the non-vanishing initial conditions. Note alsto that, while the pv->y
    vector has the purpose of setting the initial conditions, the pv->dy vector does not really serve
    any purpose. */
  class_calloc (ppv->y, ppv->pt2_size, sizeof(double), ppt2->error_message);
  class_alloc (ppv->dy, ppv->pt2_size*sizeof(double), ppt2->error_message);
  class_calloc (ppv->dy_quadsources, ppv->pt2_size, sizeof(double), ppt2->error_message);  
  class_calloc (ppv->dy_quadcollision, ppv->pt2_size, sizeof(double), ppt2->error_message);    
  class_alloc (ppv->used_in_sources, ppv->pt2_size*sizeof(int), ppt2->error_message);





  // **********************         Find out what has to be saved        *******************

  /* Each time the evolver gets close to a time that is in ppt2->tau_sampling, the code will
    interpolate the pv->y array at the exact time.  This may be time consuming, hence it is
    a good idea to specify a list of those values that are actually needed.  Such list is
    ppv->used_in_sources. */ 

  /* As in the 1st-order case, here we should fill the ppv->used_in_sources array according to which of the
    evolved quantities are actually needed to compute the sources.  For simplicity, we just take of all of the
    evolved perturbations.  This is not a big deal, as interp_from_dif, the routine used in evolver_ndf15.c
    to interpolate pv->y, is very fast in its job (especially if we are not sampling many time values).  */

  for (index_pt=0; index_pt < ppv->pt2_size; index_pt++)
    ppv->used_in_sources[index_pt] = _TRUE_;





  // **********************         Set initial conditions        *******************



  // *****     Set primordial initial conditions for a new wavenumber   ****** 
  if (pa_old == NULL) {

    /* Get background quantities so to print a useful debug message */
    class_call (background_at_tau(
                 pba,
                 tau, 
                 pba->normal_info, 
                 pba->inter_closeby,
                 &(ppw2->last_index_back), 
                 ppw2->pvecback),
      pba->error_message,
      ppt2->error_message);

    double a = ppw2->pvecback[pba->index_bg_a];
    double Y = log10(a/pba->a_eq);  

    if (ppt2->perturbations2_verbose > 3)
      fprintf(stdout, "    * setting primordial initial conditions at tau=%g, a=%g, y=%g\n",
        tau, a, Y);


    /* Check that current approximation scheme is consistent with primordial initial conditions */
    class_test (ppw2->approx[ppw2->index_ap2_rsa] == (int)rsa_on,
                ppt2->error_message,
                "the primordial initial conditions that we use assume that the radiation streaming approximation is turned off");
      
    if (pba->has_ur == _TRUE_)
      class_test (ppw2->approx[ppw2->index_ap2_ufa] == (int)ufa_on,
                  ppt2->error_message,
                  "the primordial initial conditions that we use assume that the ultra-relativistic fluid approximation is turned off");

    class_test (ppw2->approx[ppw2->index_ap2_nra] == (int)nra_on,
                ppt2->error_message,
                "the primordial initial conditions that we use assume that the no-radiation approximation is turned off");


    /* Let ppw2->pv points towards the perturb2_vector structure that we created and filled above */
    ppw2->pv = ppv;

    /* Fill the vector ppw2->pv->y with appropriate initial conditions */
    class_call(perturb2_initial_conditions(ppr,
                 pba,
                 pth,
                 ppt,
                 ppt2,
                 tau,
                 ppw2),
      ppt2->error_message,
      ppt2->error_message);
        
  } // end of if (pa_old == NULL)
    
    

  // *****     Switch approximation while a wavenumber is being integrated   ******
  else {

    /* Check that the change of approximation scheme makes sense */
    class_test ((pa_old[ppw2->index_ap2_tca] == (int)tca_off) && (ppw2->approx[ppw2->index_ap2_tca] == (int)tca_on),
                ppt2->error_message,
                "at tau=%g: the tight-coupling approximation can be switched off, not on",tau);



    /* Some variables (b, cdm, fld, ...) are not affected by any approximation. They need to be reconducted whatever
      the approximation switching is. We treat them here. Below we will treat other variables case by case.
      IMPORTANT: make sure that ppv->y is addressed with ppv indices and that pp2->pv->y is addressed with ppw2->pv
      indices. */


    // *** Baryons ***
    ppv->y[ppv->index_pt2_monopole_b + nlm_b(0,0,0)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_b + nlm_b(0,0,0)];
    ppv->y[ppv->index_pt2_monopole_b + nlm_b(1,1,0)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_b + nlm_b(1,1,0)];
    
    if (ppv->m_max > 0)
      ppv->y[ppv->index_pt2_monopole_b + nlm_b(1,1,1)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_b + nlm_b(1,1,1)];
    
    ppv->y[ppv->index_pt2_monopole_b + nlm_b(2,0,0)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_b + nlm_b(2,0,0)];
    
    for (m=0; m <= min(2,ppv->m_max); ++m)  
      ppv->y[ppv->index_pt2_monopole_b + nlm_b(2,2,m)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_b + nlm_b(2,2,m)];
      
    
    
    // *** Cold dark matter ***      
    if (pba->has_cdm == _TRUE_) {  
                                                            
      ppv->y[ppv->index_pt2_monopole_cdm + nlm_cdm(0,0,0)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(0,0,0)];
                                                            
      if (ppt->gauge != synchronous) {                      
                                                            
        ppv->y[ppv->index_pt2_monopole_cdm + nlm_cdm(1,1,0)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(1,1,0)];
                                                            
        if (ppv->m_max > 0)                                 
          ppv->y[ppv->index_pt2_monopole_cdm + nlm_cdm(1,1,1)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(1,1,1)];
      }                                                     
                                                            
      ppv->y[ppv->index_pt2_monopole_cdm + nlm_cdm(2,0,0)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(2,0,0)];
                                                            
      for (m=0; m <= min(2,ppv->m_max); ++m)                
        ppv->y[ppv->index_pt2_monopole_cdm + nlm_cdm(2,2,m)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_cdm + nlm_cdm(2,2,m)];
                                                            
    } // end of if(has_cdm)
      
    
    
    
    // *** Fluid component ***
    if (pba->has_fld == _TRUE_) { 
    }
      
    
    
    // *** Metric variables ***
    if (ppt->gauge == synchronous)
      ppv->y[ppv->index_pt2_eta] = ppw2->pv->y[ppw2->pv->index_pt2_eta];
    
    else if (ppt->gauge == newtonian)
      ppv->y[ppv->index_pt2_phi] = ppw2->pv->y[ppw2->pv->index_pt2_phi];




    // =====================================
    // = Switch on the no-radiation approx =
    // =====================================
     
    if (ppt2->perturbations2_verbose > 3)
      printf("    * switching on no-radiation approximation at tau=%g with a/a_eq=%g\n", tau, ppw2->pvecback[pba->index_bg_a]/pba->a_eq);


    if ( (pa_old[ppw2->index_ap2_nra] == (int)nra_off) && (ppw2->approx[ppw2->index_ap2_nra] == (int)nra_on)) {
      
      /* In the full NRA we do not evolve radiation at all.  Hence, we do not set initial conditions for
        photons and neutrinos because there are no equations for them. */ 
      if (ppt2->no_radiation_approximation == (int)nra2_all ) {
        
      }
      /* In the fluid NRA we do evolve only the moments up to ppv->l_max, which we set previously in this function */
      else if (ppt2->no_radiation_approximation == (int)nra2_fluid) {
        
        int l, m;
        
        /* Temperature hierarchy */
        for (l=0; l<=ppv->l_max_g; ++l)
          for (m=0; m<=min(l,ppv->m_max); ++m)
            ppv->y[ppv->index_pt2_monopole_g + lm(l,m)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_g + lm(l,m)];

        
        /* Polarization hierarchies */
        if (ppt2->has_polarization2 == _TRUE_) {

          for (l=0; l<=ppv->l_max_pol_g; ++l)
            for (m=0; m<=min(l,ppv->m_max); ++m) 
              ppv->y[ppv->index_pt2_monopole_E + lm(l,m)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_E + lm(l,m)];

          for (l=0; l<=ppv->l_max_pol_g; ++l)
            for (m=0; m<=min(l,ppv->m_max); ++m) 
              ppv->y[ppv->index_pt2_monopole_B + lm(l,m)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_B + lm(l,m)];
        }


        /* Neutrino hierarchy */
        if (pba->has_ur == _TRUE_)
          for (l=0; l<=ppv->l_max_ur; ++l)
            for (m=0; m<=min(l,ppv->m_max); ++m)
              ppv->y[ppv->index_pt2_monopole_ur + lm(l,m)] = ppw2->pv->y[ppw2->pv->index_pt2_monopole_ur + lm(l,m)];
        
      } // end of if(no_radiation_approximation)
      
      
    } // end of if(nra_on)



    /* Free the previous vector of perturbations */
    class_call(perturb2_vector_free(ppw2->pv),
         ppt2->error_message,
         ppt2->error_message);


    /* Let ppw2->pv points towards the perturb2_vector structure that we just created */
    ppw2->pv = ppv;

  } // end of if(pba_old != NULL)



  /* Print the initial conditions we just computed for the considered interval */
  // printf ("%20.10g\n", tau);
  // 
  // for (index_pt=0; index_pt < ppw2->pv->pt2_size; ++index_pt)
  //   printf("%20.10g\n", ppw2->pv->y[index_pt]);


  return _SUCCESS_;

}



/// ========================
/// = perturb2_vector_free =
/// ========================
int perturb2_vector_free(
      struct perturb2_vector * pv
      )
{

  free(pv->y);
  free(pv->dy);
  free(pv->dy_quadsources);  
  free(pv->dy_quadcollision);    
  free(pv->used_in_sources);
  free(pv);
  
  return _SUCCESS_;
}







int perturb2_free(
     struct perturbs2 * ppt2
     )
{

  int index_type,index_k1,index_k2,index_cosk1k2;

  if ((ppt2->has_perturbations2 == _TRUE_) && (ppt2->has_early_transfers1_only == _FALSE_)) {
    
    int k1_size = ppt2->k_size;
    
    for (index_type = 0; index_type < ppt2->tp2_size; index_type++) {

      /* Free the k1 level only if we are neither loading nor storing the sources to disk.  The memory
        management in those two cases is handled separately, so that the sources are freed as soon
        as they are not needed anymore. */
      if ((ppt2->store_sources_to_disk==_FALSE_) && (ppt2->load_sources_from_disk==_FALSE_))
        for (index_k1 = 0; index_k1 < k1_size; index_k1++) {

          /* If the transfer2 module was loaded, ppt2->sources had already been freed  */
          if (ppt2->has_allocated_sources[index_k1] == _TRUE_)
            class_call(perturb2_free_k1_level(ppt2, index_k1), ppt2->error_message, ppt2->error_message); 
        }
        
      free(ppt2->sources[index_type]);
      free(ppt2->tp2_labels[index_type]);

    } // End of for index_type

    free(ppt2->sources);
    
    free(ppt2->tau_sampling);
           
    free(ppt2->k);
    free(ppt2->cosk1k2);
    
    free(ppt2->tp2_labels);

    free(ppt2->lm_array);
    free(ppt2->lm_array_quad);


    /* Close sources files */
    if (ppt2->store_sources_to_disk == _TRUE_) {
    
      fclose(ppt2->sources_status_file);
    
      for(index_k1=0; index_k1<ppt2->k_size; ++index_k1)
        free (ppt2->sources_run_paths[index_k1]);

      free (ppt2->sources_run_files);
      free (ppt2->sources_run_paths);

    } // end of if(ppt2->store_sources_to_disk)


    /* Close the debug files */
    if(ppt2->has_debug_files) {
      fclose(ppt2->transfers_file);
      fclose(ppt2->quadsources_file);
      fclose(ppt2->quadliouville_file);
      fclose(ppt2->quadcollision_file);
    }

  } // end of if(has_perturbations2)

  return _SUCCESS_;

}















int perturb2_derivs(
       double tau,
       double * y,
       double * dy,
       void * parameters_and_workspace,
       ErrorMsg error_message
       )
{
  
  
  
  /* Define shortcuts to avoid heavy notation */
  struct perturb2_parameters_and_workspace * pppaw2 = parameters_and_workspace;
  struct precision * ppr = pppaw2->ppr;
  struct background * pba = pppaw2->pba;
  struct thermo * pth = pppaw2->pth;
  struct perturbs * ppt = pppaw2->ppt;
  struct perturbs2 * ppt2 = pppaw2->ppt2;
  struct perturb2_workspace * ppw2 = pppaw2->ppw2;
  double * pvecback = ppw2->pvecback;
  double * pvecthermo = ppw2->pvecthermo;
  double * pvecmetric = ppw2->pvecmetric;
  double k_sq = ppw2->k_sq;
  double k = ppw2->k;

  /* Update counter of calls */
  ppw2->derivs_count++;
  
  /* Shortcuts related to the angular hierarchies */
  int m_max = ppw2->pv->m_max;
  int lm_extra = ppt2->lm_extra;  
  int l, m;  
  


  // **********************             Interpolate needed quantities      ********************


  // *** Interpolate background-related quantities (pvecback) ***
  class_call (background_at_tau(
             pba,
             tau, 
             pba->normal_info, 
             pba->inter_closeby,
             &(ppw2->last_index_back), 
             ppw2->pvecback),
       pba->error_message,
       error_message);

  double a = pvecback[pba->index_bg_a];
  double Hc = pvecback[pba->index_bg_H] * a;
  double z = 1./a-1.;


  // *** Interpolate thermodynaics-related quantities (pvecthermo) ***
  class_call (thermodynamics_at_z(
             pba,
             pth,
             1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1./a-1 */
             pth->inter_closeby,
             &(ppw2->last_index_thermo),
             ppw2->pvecback,
             ppw2->pvecthermo),
       pth->error_message,
       error_message);

  /* Photon to baryon ratios */
  double r = pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_b];
  double R = 4/3. * r;

  /* Derivative of r = rho_g/rho_b, assuming that r is proportional to 1/a. */
  double r_dot = -Hc*r;
    
  /* Interaction rate */
  double kappa_dot = pvecthermo[pth->index_th_dkappa];


  // *** Interpolate quadratic sources ***

  /* The following functions fills
       - ppw2->pvec_metric_quadsources
       - ppw2->pvec_liouville_quadsources
       - ppw2->pvec_collision_quadsources */

  if (ppt2->has_quadratic_sources == _TRUE_) {
    class_call(perturb2_quadratic_sources_at_tau(
              ppt,
              ppt2,
              tau,            
              ppw2
              ),
          ppt2->error_message,
          error_message);
  }


  // *** Interpolate Einstein equations (pvecmetric)
  /* Note that perturb2_einstein relies on ppw2->pvecback, ppw2->pvecthermo, and ppw2->pvec_metric_quadsources
    as calculated above.  Therefore, it should always be called after the functions background_at_tau,
    thermodynamics_at_tau, and perturb2_quadratic_sources. */
  class_call(perturb2_einstein(
             ppr,
             pba,
             pth,
             ppt,
             ppt2,
             tau,
             y,
             ppw2),            /* We shall store the metric variables in ppw2->pvecmetric */
         ppt2->error_message,
         error_message);


  /* Assign shortcuts for metric variables */

  double phi_prime, psi, phi;

  if (ppt->gauge == newtonian) {
    phi_prime = pvecmetric[ppw2->index_mt2_phi_prime];
    phi = y[ppw2->pv->index_pt2_phi];
    psi = pvecmetric[ppw2->index_mt2_psi];
  }


  /* Split each equations for CDM and baryons into a metric (gauge dependenent) part
    and a matter (gauge independent) part.  The procedure is the same as in the first-
    order case.  Note, however, that here (1) metric_euler is different, because now we are
    integrating 'v_0' rather than theta, and (2) the metric term is present only for the 
    scalar m=0 equations. */
  double metric_continuity=0, metric_euler=0, metric_shear=0, metric_shear_prime=0;

  if (ppt->gauge == synchronous) {

    // metric_continuity = 0.5*pvecmetric[ppw2->index_mt2_h_prime];
    // metric_euler = 0.;
    // metric_shear = (pvecmetric[ppw2->index_mt2_h_prime] + 6. * pvecmetric[ppw2->index_mt2_eta_prime])/2.;
  }

  if (ppt->gauge == newtonian) {

    metric_continuity = -3.*phi_prime;
    metric_euler = k*psi;  
    metric_shear = 0.;
  }
        





  // *******************        Smart dipole       *****************
  
  /*  The collision term for the baryon dipole is very large before recombination (much
    larger than the photon one).  This is numerically unstable, as it leads to numerical
    cancellations.  In order to avoid them, we evolve a different dipole equation. That
    is, instead of the baryon dipole b_11m , we evolve the quantity
        s_11m = b_11m + r*I_1m .
    s_11m, by construction, has vanishing collision term and hence it is numerically
    more stable to evolve.  We evolve s_11m instead of b_11m only if the flag
    'ppt2->has_smart_dipole' is true.  We shall index both b_11m and s_11m by using
    the same index 'ppw2->pv->index_pt2_monopole_b + nlm_b(1,1,0)', as we shall
    never activate both perturbations at the same time.
  */
  double b_110, s_110, b_111, s_111;
  if (ppt2->has_smart_dipole == _TRUE_) {

    s_110 = b(1,1,0);
    b_110 = s_110 - r*I(1,0);
    if (m_max > 0) {
      s_111 = b(1,1,1);
      b_111 = s_111 - r*I(1,1);        
    }
  }
  else {

    b_110 = b(1,1,0);
    if (m_max > 0)
      b_111 = b(1,1,1); 
  }


  // **************************               Write the hierarchies                **********************



  int l_max_g = ppw2->pv->l_max_g;
  int l_max_pol_g = ppw2->pv->l_max_pol_g;
  int l_max_ur = ppw2->pv->l_max_ur;
  

  // =======================================
  // =          Photon temperature         =
  // =======================================

  for (l=0; l<=(l_max_g); ++l) {
    for (m=0; m<=min(l,m_max); ++m) {

      // *** Monopole
      if (l==0) {
        dI(0,0) = -4/3.*(k*I(1,0)/4. + metric_continuity);
      }
      // *** Dipole
      else if (l==1) {
        if (m==0)
          dI(1,0) = k*(I(0,0) - 2/5.*I(2,0)) + 4*metric_euler + kappa_dot * (4/3.*b_110 - I(1,0));
        if (m==1)
          dI(1,1) = -k * sqrt_3/5. * I(2,1) + kappa_dot * (4/3.*b_111 - I(1,1));
      }
      // *** Quadrupole
      else if (l==2) {
        double Pi = 1/10.* ( I(2,m) - sqrt_6*E(2,m) );
        dI(2,m) = k*(c_minus(2,m,m)*I(1,m) - c_plus(2,m,m)*I(3,m))  - kappa_dot*(I(2,m) - Pi);
      }
      // *** Photon temperature, l>=3 moments
      else {
        /* Higher moments are all tight coupling suppressed. Note that c_minus is always
          positive, while c_plus is always negative (at least in this case where m1==m). */
        dI(l,m) = k*(c_minus(l,m,m)*I(l-1,m) - c_plus(l,m,m)*I(l+1,m)) - kappa_dot * I(l,m);
      }
        
    } // end of for(m)
  } // end of for(l)




  // *** Photon temperature closure relation

  /* We apply the closure relation only when there is no approximation scheme active, i.e. when
    the number of equations evolved is equal to the default number */
  if (l_max_g == ppw2->l_max_g) {
  
    l = l_max_g;
  
    /* We take the closure relation from eq. D.1 of Pitrou et al. 2010. */
    for (m=0; m<=min(l,m_max); ++m) {
  
      double c_pre =  (m==0 ?  (2*l+1)/(2*l-1.) : sqrt((double)(l + abs(m))/(l - abs(m))) * (2*l+1)/(2*l-1.) );
      double c     =  (l+1+abs(m))/(k*tau);
  
      dI(l,m) = k*(c_pre*I(l-1,m) - c*I(l,m)) - kappa_dot*I(l,m);
    }
  } // end of if(l_max_g == ppw2->l_max_g)


  // *** Add photon temperature quadratic terms
  if (ppt2->has_quadratic_sources == _TRUE_) {
    for (l=0; l<=min(ppr->l_max_g_quadsources,l_max_g); ++l) {
      for (m=0; m<=min(l,m_max); ++m) {

        dI_quad(l,m) = 0;
        if (ppt2->has_quadratic_liouville == _TRUE_) dI_quad(l,m) += dI_ql(l,m);
        if (ppt2->has_quadratic_collision == _TRUE_) dI_quad(l,m) += kappa_dot*dI_qc(l,m);
        dI(l,m) += dI_quad(l,m);
        
      } // end of if(has_quadratic_sources)
    } // end of for(m)
  } // end of for(l)




  // ========================================
  // =          Photon polarization         =
  // ========================================

  if (ppt2->has_polarization2 == _TRUE_) {
  
    /* E-mode and B-mode polarization do not have monopole nor dipole */
    dE(0,0) = dE(1,0) = 0;
    dB(0,0) = dB(1,0) = 0;
    if (m_max>0) dE(1,1) = dB(1,1) = 0;



    // ********  Photon E-mode polarization hierarchy *******
  
    /* We are going to use the equation in the first two lines of eq. 2.19
      in Beneke, Fidler & Klingmuller (2011), hereafter BFK */

    for (l=2; l<=(l_max_pol_g); ++l) {
      for (m=0; m<=min(l,m_max); ++m) {


        // *** Quadrupole
        /* The quadrupole needs to be treated separately because it has an extra contribution
          in its collision term that couples polarization to temperature, which we call Pi. */
        if (l==2) {
          double Pi = 1/10.* ( I(2,m) - sqrt_6*E(2,m) );
          dE(2,m) = k * ( -d_plus(2,m,m)*E(3,m) - d_zero(2,m,m)*B(2,m) ) - kappa_dot*(E(2,m) + sqrt_6*Pi);
        }
        // *** l>2 moments
        /* First line of eq. 2.19 of BFK.  Note that the B(l,m) term that couples E-modes and
          B-modes is non-zero only for m!=0. */
        else {
          dE(l,m) = k*(d_minus(l,m,m)*E(l-1,m) - d_plus(l,m,m)*E(l+1,m) - d_zero(l,m,m)*B(l,m)) - kappa_dot*E(l,m);
        }



        // ********  Photon B-mode polarization hierarchy *********
  
        /* We are going to use the equation in the first line of eq. 2.20 in BFK.
          Note that the B-modes are always zero for m=0, and that they only couple to E-modes. */

        // *** All moments
        dB(l,m) = k*(d_minus(l,m,m)*B(l-1,m) - d_plus(l,m,m)*B(l+1,m) + d_zero(l,m,m)*E(l,m)) - kappa_dot*B(l,m);


      } // end of for(m)
    } // end of for(l)




    // *** B-modes and E-modes closure relation

    /* We apply the closure relation only when there is no approximation scheme active, i.e. when
      the number of equations evolved is equal to the default number */
    if (l_max_pol_g == ppw2->l_max_pol_g) {

      l = l_max_pol_g;
      
      /* We take the closure relation from the real & imaginary parts of eq. D.2 of Pitrou et al. (2010), hereafter P2010 */
      for (m=0; m<=min(l,m_max); ++m) {

        double c_pre =  sqrt(1-(((double)m)*m)/(l*l) * (l+2)/(l-2.)) * (2*l+1)/(2*l-1.);
        double c     =  (l+3)/(k*tau);
        double c_mix =  ((double)m)/l;

        dE(l,m) = k*( c_pre*E(l-1,m) - c*E(l,m) - c_mix*B(l,m) ) - kappa_dot*E(l,m);
        dB(l,m) = k*( c_pre*B(l-1,m) - c*B(l,m) + c_mix*E(l,m) ) - kappa_dot*B(l,m);
      }
    } // end of if(l_max_pol_g == ppw2->l_max_pol_g)




    // *** Add E-mode and B-mode quadratic terms.
    if (ppt2->has_quadratic_sources == _TRUE_) {
      for (l=2; l<=min(ppr->l_max_pol_g_quadsources,l_max_pol_g); ++l) {
        for (m=0; m<=min(l,m_max); ++m) {

          dE_quad(l,m) = 0;
          if (ppt2->has_quadratic_liouville == _TRUE_) dE_quad(l,m) += dE_ql(l,m);
          if (ppt2->has_quadratic_collision == _TRUE_) dE_quad(l,m) += kappa_dot*dE_qc(l,m);
          dE(l,m) += dE_quad(l,m);
                
          dB_quad(l,m) = 0;
          if (ppt2->has_quadratic_liouville == _TRUE_) dB_quad(l,m) += dB_ql(l,m);
          if (ppt2->has_quadratic_collision == _TRUE_) dB_quad(l,m) += kappa_dot*dB_qc(l,m);
          dB(l,m) += dB_quad(l,m);
        
        } // end of for(m)
      } // end of for(l)
    } // end of if(has_quadratic_sources)

  }  // end of if(has_polarization2)



      
      
  // =======================================================
  // =              Ultra Relativistic Neutrinos           =
  // =======================================================
  if (pba->has_ur == _TRUE_) {

    /* The neutrinos obey the same Boltzmann hierarchy as the photons' one, with kappa_dot set to zero */
    for (l=0; l<=(l_max_ur); ++l) {
      for (m=0; m<=min(l,m_max); ++m) {

        // *** Monopole
        if (l==0) {
          dN(0,0) = -4./3.*(k*N(1,0)/4. + metric_continuity);
        }
        // *** Dipole
        else if (l==1) {
          if (m==0)
            dN(1,0) = k*(N(0,0) - 2/5.*N(2,0)) + 4*metric_euler;
          if (m==1)
            dN(1,1) = - k * sqrt_3/5. * N(2,1);
        }
        else {
          // *** Neutrino higher moments
          dN(l,m) = k* ( c_minus(l,m,m)*N(l-1,m) - c_plus(l,m,m)*N(l+1,m) );
        }
    
      } // end of for(m)
    } // end of for(l)
  



    // *** Neutrino closure relation

    /* We apply the closure relation only when there is no approximation scheme active, i.e. when
      the number of equations evolved is equal to the default number */
    if (l_max_ur == ppw2->l_max_ur) {

      l = l_max_ur;
      
      /* Again, we take the closure relation from eq. D.1 of Pitrou et al. 2010. */
      for (m=0; m<=min(l,m_max); ++m) {
      
        double c_pre =  (m==0 ?  (2*l+1)/(2*l-1.) : sqrt((double)(l + abs(m))/(l - abs(m))) * (2*l+1)/(2*l-1.) );
        double c     =  (l+1+abs(m))/(k*tau);

        dN(l,m) = k*(c_pre*N(l-1,m) - c*N(l,m));
      }
    } // end of if(l_max_ur == ppw2->l_max_ur)



    // *** Add neutrino quadratic terms
    if (ppt2->has_quadratic_sources == _TRUE_) {
      for (l=0; l<=min(ppr->l_max_ur_quadsources,l_max_ur); ++l) {
        for (m=0; m<=min(l,m_max); ++m) {
      
          dN_quad(l,m) = 0;
          if (ppt2->has_quadratic_liouville == _TRUE_) dN_quad(l,m) += dN_ql(l,m);
          dN(l,m) += dN_quad(l,m);
          
        } // end of for(l)
      } // end of for(m)
    } // end of if(has_quadratic_sources)
  
  
  }  // end of if(has_ur)







  // =======================================
  // =                Baryons              =
  // =======================================

  
  // *** Baryon monopole
  db(0,0,0) = - (k*b_110/3 + metric_continuity) - Hc*b(2,0,0);

  /* Sort out quadratic sources */
  if (ppt2->has_quadratic_sources == _TRUE_) {
    db_quad(0,0,0) = 0;
    if (ppt2->has_quadratic_liouville == _TRUE_) db_quad(0,0,0) += db_ql(0,0,0);
    if (ppt2->has_quadratic_collision == _TRUE_) db_quad(0,0,0) += kappa_dot*db_qc(0,0,0);
    db(0,0,0) += db_quad(0,0,0);
  }
  
  // *** Baryon dipole
  /*  We write the collision term for the baryon monopole and dipole very simply by enforcing
    the conservation of the energy and momentum, expressed through the energy momentum tensor:
    
    d T00_b / d tau = - d T00_g / d tau
    d T0i_b / d tau = - d T0i_g / d tau        
    
    where the the time derivative accounts only for the variations due to the Thomson
    scattering, and where the right hand side is just minus the collision term of
    photons.

    We describe the distribution function of baryons through its expansion in beta-moments,
    which are conceptually the same as the photon multipoles.  We do so because we want to
    treat baryons and photons on the same ground.  One of the advantages of this approach
    is manifest here.  Since the first two beta-moments are just T00/rho (monopole) and
    T0i/rho (dipole), we have that the collision term for the baryons is given by the one
    from the photons times -rho_g/rho_b.  */
  if (ppt2->has_smart_dipole == _FALSE_) {

    db(1,1,0) = - Hc*b_110 + 3*metric_euler + k*(b(2,0,0) - 2/5.*b(2,2,0))
                + r*kappa_dot*(I(1,0) - 4/3.*b_110);
  }
  else {

    /* Derivative of the baryon & photon dipoles, without collision term or quadratic sources */
    double db_110, dI_10;
    db_110 = - Hc*b_110 + 3*metric_euler + k*(b(2,0,0) - 2/5.*b(2,2,0));
    dI_10 = 4*metric_euler + k*(I(0,0) - 2/5.*I(2,0));
    
    /* Derivative of s_110 = b_110 + r*I_10 */
    db(1,1,0) = db_110 + r*dI_10 + r_dot*I(1,0);
  }

  /* Sort out quadratic sources */
  if (ppt2->has_quadratic_sources == _TRUE_) {
    db_quad(1,1,0) = 0;
    if (ppt2->has_quadratic_liouville == _TRUE_) db_quad(1,1,0) += db_ql(1,1,0);
    if (ppt2->has_quadratic_collision == _TRUE_) db_quad(1,1,0) += kappa_dot*db_qc(1,1,0);
    db(1,1,0) += db_quad(1,1,0);
  }


  // *** Vector parts of baryon dipole
  if (m_max > 0) {

    if (ppt2->has_smart_dipole == _FALSE_) {

      db(1,1,1) = - Hc*b_111 - sqrt_3/5*k*b(2,2,1) 
                  + R*kappa_dot * (3/4.*I(1,1) - b_111);

    }
    else {
      
      /* Derivative of the baryon & photon dipoles, without collision term or quadratic sources */
      double db_111, dI_11;        
      db_111 = - Hc*b_111 - sqrt_3/5*k*b(2,2,1);
      dI_11 = - sqrt_3/5*k*I(2,1);
    
      /* Derivative of s_111 = b_111 + r*I_11 */
      db(1,1,1) = db_111 + r*dI_11 + r_dot*I(1,1);
    }

    if (ppt2->has_quadratic_sources == _TRUE_) {
      db_quad(1,1,1) = 0;
      if (ppt2->has_quadratic_liouville == _TRUE_) db_quad(1,1,1) += db_ql(1,1,1);
      if (ppt2->has_quadratic_collision == _TRUE_) db_quad(1,1,1) += kappa_dot*db_qc(1,1,1);
      db(1,1,1) += db_quad(1,1,1);
    }

  
  } // end of if(m_max>0)



  // *** Baryon "pressure"
  if (ppt2->has_perfect_baryons == _FALSE_)
    db(2,0,0) = - 2.*Hc*b(2,0,0);
  else
    /* In the perfect fluid approximation, b(2,0,0) is not a dynamical quantity
      and its derivative is defined so that the baryon pressure is constant.
      Hence, the derivative contains only quad. terms involving the 1st-order velocity. */
    db(2,0,0) = 0;


  /* Sort out quadratic sources */
  if (ppt2->has_quadratic_sources == _TRUE_) {
    db_quad(2,0,0) = 0;
    if (ppt2->has_quadratic_liouville == _TRUE_) db_quad(2,0,0) += db_ql(2,0,0);
    db(2,0,0) += db_quad(2,0,0);
  }
  
  
  // *** Baryon quadrupole
  if (ppt2->has_perfect_baryons == _FALSE_)
    for (m=0; m <= min(2,m_max); ++m)
      db(2,2,m) = - 2.*Hc*b(2,2,m);
  else
    /* In the perfect fluid approximation, b(2,2,m) is not a dynamical quantity
      and its derivative is defined so that the baryon stresses are constant.
      Hence, the derivative contains only quad. terms involving the 1st-order velocity. */
    for (m=0; m <= min(2,m_max); ++m)  
      db(2,2,m) = 0;

  /* Sort out quadratic sources */
  for (m=0; m <= min(2,m_max); ++m)  
    if (ppt2->has_quadratic_sources == _TRUE_) {
      db_quad(2,2,m) = 0;
      if (ppt2->has_quadratic_liouville == _TRUE_) db_quad(2,2,m) += db_ql(2,2,m);
      db(2,2,m) += db_quad(2,2,m);
    }



  
  

  // ==============================================
  // =               Cold Dark Matter             =
  // ==============================================
  if (pba->has_cdm == _TRUE_) {

    // *** CDM monopole
    dcdm(0,0,0) = - (k*cdm(1,1,0)/3 + metric_continuity) - Hc*cdm(2,0,0);

    /* Sort out quadratic sources */
    if (ppt2->has_quadratic_sources == _TRUE_) {
      dcdm_quad(0,0,0) = 0;
      if (ppt2->has_quadratic_liouville == _TRUE_) dcdm_quad(0,0,0) += dcdm_ql(0,0,0);
      dcdm(0,0,0) += dcdm_quad(0,0,0);
    }


  
    // *** CDM dipole (scalar part)
    if (ppt->gauge != synchronous) {

      dcdm(1,1,0) =
        - Hc*cdm(1,1,0) + 3*metric_euler
        + k*(cdm(2,0,0) - 2/5.*cdm(2,2,0));

      /* Sort out quadratic sources */
      if (ppt2->has_quadratic_sources == _TRUE_) {
        dcdm_quad(1,1,0) = 0;
        if (ppt2->has_quadratic_liouville == _TRUE_) dcdm_quad(1,1,0) += dcdm_ql(1,1,0);
        dcdm(1,1,0) += dcdm_quad(1,1,0);
      }
    }


    // *** Vector parts of CDM dipole
    if (m_max > 0)
      if (ppt->gauge != synchronous) {
        
        dcdm(1,1,1) = - Hc*cdm(1,1,1) - sqrt_3/5*k*cdm(2,2,1);
        
        /* Sort out quadratic sources */
        if (ppt2->has_quadratic_sources == _TRUE_) {
          dcdm_quad(1,1,1) = 0;
          if (ppt2->has_quadratic_liouville == _TRUE_) dcdm_quad(1,1,1) += dcdm_ql(1,1,1);
          dcdm(1,1,1) += dcdm_quad(1,1,1);
        }      
      }


    // *** CDM "pressure"
    if (ppt2->has_perfect_cdm == _FALSE_)
      dcdm(2,0,0) = - 2.*Hc*b(2,0,0);
    else
      /* In the perfect fluid approximation, cdm(2,0,0) is not a dynamical quantity
        and its derivative is defined so that the CDM pressure is constant.
        Hence, the derivative contains only quad. terms involving the 1st-order velocity. */
      dcdm(2,0,0) = 0;

    /* Sort out quadratic sources */
    if (ppt2->has_quadratic_sources == _TRUE_) {
      dcdm_quad(2,0,0) = 0;
      if (ppt2->has_quadratic_liouville == _TRUE_) dcdm_quad(2,0,0) += dcdm_ql(2,0,0);
      dcdm(2,0,0) += dcdm_quad(2,0,0);
    }      


  
    // *** CDM quadrupole
    if (ppt2->has_perfect_cdm == _FALSE_)
      for (m=0; m <= min(2,m_max); ++m)    
        dcdm(2,2,m) = - 2.*Hc*b(2,2,m);
    else
      /* In the perfect fluid approximation, cdm(2,2,m) is not a dynamical quantity
        and its derivative is defined so that the CDM stresses are constant.
        Hence, the derivative contains only quad. terms involving the 1st-order velocity. */
      for (m=0; m <= min(2,m_max); ++m)  
        dcdm(2,2,m) = 0;
        
    /* Sort out quadratic sources */
    for (m=0; m <= min(2,m_max); ++m)  
      if (ppt2->has_quadratic_sources == _TRUE_) {
        dcdm_quad(2,2,m) = 0;
        if (ppt2->has_quadratic_liouville == _TRUE_) dcdm_quad(2,2,m) += dcdm_ql(2,2,m);
        dcdm(2,2,m) += dcdm_quad(2,2,m);
      }      


  } // end of if(cdm)
  









  // ===================================================
  // =                 Metric Perturbations            =
  // ===================================================

  // **** Newtonian gauge
  if (ppt->gauge == newtonian) {
    /* No need to add the quadsources here since this was already done in perturb2_einstein */
    dy[ppw2->pv->index_pt2_phi] = pvecmetric[ppw2->index_mt2_phi_prime];
  }

  // *** Synchronous gauge
  if (ppt->gauge == synchronous) {
    /* No need to add the quadsources here since this was already done in perturb2_einstein */
    dy[ppw2->pv->index_pt2_eta] = pvecmetric[ppw2->index_mt2_eta_prime];
  }




  // *** Print some debug information
  // if ( (1==0) || (ppw2->derivs_count == 793) || (ppw2->derivs_count == 794)) {
  //   if ((ppw2->index_k1==0) && (ppw2->index_k2==1)) {
  // 
  //     printf(" *** Leaving derivs for the %d time; tau = %.16f\n", ppw2->derivs_count, tau);
  // 
  //     /* Show content of y, dy and dy_quadsources */
  //     int index_pt;
  //     for(index_pt=0; index_pt<ppw2->pv->pt2_size; ++index_pt)
  //       printf("y[%3d] = %+12.3g,  dy[%3d] = %+12.3g,   dy_quadsources[%3d] = %+12.3g\n",
  //         index_pt, y[index_pt], index_pt, dy[index_pt], index_pt, ppw2->pv->dy_quadsources[index_pt]);
  // 
  //   }  
  // }


  // *** Print some debug information as a function of time
  // if ((ppw2->index_k1==0) && (ppw2->index_k2==1)) {
  //   fprintf (stderr, "%17.7g %17.7g %17.7g\n", tau, y[ppw2->pv->index_pt2_phi], dy[ppw2->pv->index_pt2_phi]);
  // }

  return _SUCCESS_;  
  
  
}   // end of perturb2_derivs





/**
 * Before calling this function, remember to compute the quadratic sources using
 * perturb2_quadratic_sources.  The result of such computation is stored in the
 * array ppw2->pvec_metric_quadsources, while the single first-order perturbations
 * at time tau are in ppw2->pvec_sources1 and ppw2->pvec_sources2.
 * This function also relies on ppw2->pvecback and ppw2->pvecthermo, which
 * should have already been filled.  This is done in perturb2_derivs.
 */
int perturb2_einstein(
       struct precision * ppr,
       struct background * pba,
       struct thermo * pth,
       struct perturbs * ppt,
       struct perturbs2 * ppt2,
       double tau,
       double * y,
       struct perturb2_workspace * ppw2
       )
{

  // ***  Shortcuts for matter variables

  /* Contribution of the single species */
  double rho_g=0, rho_b=0, rho_cdm=0, rho_ur=0;
  int m_max = ppw2->pv->m_max;
  
  /* Variables that will accumulate the contribution from all species */
  double rho_monopole=0, rho_dipole=0, rho_quadrupole=0;


  /* Geometrical and background quantities */
  double k_sq = ppw2->k_sq;
  double k = ppw2->k; 
  double a = ppw2->pvecback[pba->index_bg_a];
  double a2 = a*a;
  double Hc = ppw2->pvecback[pba->index_bg_H]*a;
  double r = ppw2->pvecback[pba->index_bg_rho_g]/ppw2->pvecback[pba->index_bg_rho_b];





  // *********************        Energy momentum tensor         ***************************

  /* We shall compute the monopole, dipole and quadrupole of the distribution function
    of all species.  At first order these would be the energy density, velocity divergence
    and anisotropic stresses of the total fluid.  This interpretation does not hold at
    second order, where the fluid variables are related to the distribution function
    by terms quadratic in the first order velocities and densities */
    

  // *** Photon contribution.
  rho_g = ppw2->pvecback[pba->index_bg_rho_g];
  rho_monopole           =  rho_g*I(0,0);
  rho_dipole             =  rho_g*I(1,0);
  rho_quadrupole         =  rho_g*I(2,0);

  /* Some debug */
  // printf("rho_monopole after g = %g\n", rho_monopole);




  // *** Baryons contribution

  /* First, set the smart dipole variables */
  double b_110 = b(1,1,0), s_110 = 0;
  if (ppt2->has_smart_dipole == _TRUE_) {
    s_110  = b(1,1,0);
    b_110  = s_110 - r*I(1,0);
  }

  rho_b = ppw2->pvecback[pba->index_bg_rho_b];
  rho_monopole           +=  rho_b*b(0,0,0);
  rho_dipole             +=  rho_b*b_110;
  /* Note that when using the beta-moments, we have to take into account the n=2 moments also
    for baryons and CDM. */
  rho_quadrupole         +=  rho_b*b(2,2,0);

  /* Some debug */
  // printf("rho_monopole after b = %g\n", rho_monopole);

  // *** CDM contribution
  if (pba->has_cdm == _TRUE_) {

    rho_cdm = ppw2->pvecback[pba->index_bg_rho_cdm];
    rho_monopole          +=  rho_cdm*cdm(0,0,0);
    rho_dipole            +=  rho_cdm*cdm(1,1,0);
    rho_quadrupole        +=  rho_cdm*cdm(2,2,0);
  }

  /* Some debug */
  // printf("rho_monopole after c = %g\n", rho_monopole);
  
  // *** Ultra-relativistic neutrino/relics contribution
  if (pba->has_ur == _TRUE_) {

    rho_ur = ppw2->pvecback[pba->index_bg_rho_ur];
    rho_monopole           +=  rho_ur*N(0,0);
    rho_dipole             +=  rho_ur*N(1,0);
    rho_quadrupole         +=  rho_ur*N(2,0);
  }

  /* Some debug */
  // printf("rho_monopole after ur = %g\n", rho_monopole);
  
  
  // *******************           Einstein equations          ************************


  // =============================================
  // =              Newtonian Gauge              =
  // =============================================

  if (ppt->gauge == newtonian) {


    // *** Constraint equation for psi
    
    /* This is just the anisotropic stresses Einstein equation.  If you consider that
      (w+1)*shear = 2/15 quadrupole, this matches the equation in the original CLASS */
    ppw2->pvecmetric[ppw2->index_mt2_psi] =
      y[ppw2->pv->index_pt2_phi]
      - 3/5. * (a2/k_sq) * rho_quadrupole
      + ppw2->pvec_metric_quadsources[ppw2->index_qm2_psi];

    /* Dissect psi */
    // if (ppw2->approx[ppw2->index_ap2_nra]==(int)nra_on) {
    //   if (ppw2->index_k1==0) {
    //     if (ppw2->index_k2==1) {
    //       printf("y[ppw2->pv->index_pt2_phi] = %g\n", y[ppw2->pv->index_pt2_phi]);
    //       printf("ppw2->pvecmetric[ppw2->index_mt2_psi] = %g\n", ppw2->pvecmetric[ppw2->index_mt2_psi]);
    //       printf("-3/5. * (a2/k_sq) * rho_quadrupole = %g\n", - 3/5. * (a2/k_sq) * rho_quadrupole);
    //       printf("ppw2->pvec_metric_quadsources[ppw2->index_qm2_psi] = %g\n", ppw2->pvec_metric_quadsources[ppw2->index_qm2_psi]);
    //     }
    //   }
    // }


    // =====================
    // = Equation for phi' =
    // =====================

    /* Phi' from the Einstein time-time equation */
    ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson] = 
      - Hc*ppw2->pvecmetric[ppw2->index_mt2_psi]
      - k_sq/(3*Hc)*y[ppw2->pv->index_pt2_phi]
      - a2 * rho_monopole/(2*Hc)
      + ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_poisson];

    /* Dissect phi_prime_poisson */
    // if (ppw2->index_k1==0) {
    //   if (ppw2->index_k2==1) {        
    //     if (ppw2->approx[ppw2->index_ap2_nra]==(int)nra_on)
    //       printf("~~~~~~~~~~~~~ ");
    // 
    //     printf("y[ppw2->pv->index_pt2_phi] = %g\n", y[ppw2->pv->index_pt2_phi]);
    //     printf("ppw2->pvecmetric[ppw2->index_mt2_psi] = %g\n", ppw2->pvecmetric[ppw2->index_mt2_psi]);
    //     printf("ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson] = %g\n", ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson]);
    //     printf("- Hc*ppw2->pvecmetric[ppw2->index_mt2_psi] = %g\n", - Hc*ppw2->pvecmetric[ppw2->index_mt2_psi]);
    //     printf("- k_sq/(3*Hc)*y[ppw2->pv->index_pt2_phi] = %g\n", - k_sq/(3*Hc)*y[ppw2->pv->index_pt2_phi]);
    //     printf("a2 * rho_monopole/(2*Hc) = %g\n", a2 * rho_monopole/(2*Hc));
    //     printf("ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_poisson] = %g\n", ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_poisson]);
    //     printf("rho_g*I(0,0)/rho_cdm*cdm(0,0,0) = %g\n", (rho_g*I(0,0))/(rho_cdm*cdm(0,0,0)));
    //     printf("\n");
    //   }
    // }


    /* Check against nan's */
    // char buffer[64];
    // sprintf(buffer, "%g", ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_poisson]);
    // if (strcmp(buffer, "nan") == 0)
    //   fprintf(stderr, "#### found NAN for index_k1=%d, index_k2=%d, index_cosk1k2=%d, tau=%g\n",
    //     ppw2->index_k1, ppw2->index_k2, ppw2->index_cosk1k2, tau);

    

    /* Phi' from the longitudinal Einstein equation.  If you consider that
      (w+1)*theta = k*dipole/3, you recover the equation in the original CLASS. */
    ppw2->pvecmetric[ppw2->index_mt2_phi_prime_longitudinal] = 
      - Hc*ppw2->pvecmetric[ppw2->index_mt2_psi]
      + 0.5 * (a2/k) * rho_dipole
      + ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_longitudinal];


    /* Dissect phi_prime_longitudinal */
    // if (ppw2->index_k1==0) {
    //   if (ppw2->index_k2==1) {        
    //     if (ppw2->approx[ppw2->index_ap2_nra]==(int)nra_on)
    //       printf("~~~~~~~~~~~~~ ");
    // 
    //     printf("tau = %g\n", tau);
    //     printf("y[ppw2->pv->index_pt2_phi] = %g\n", y[ppw2->pv->index_pt2_phi]);
    //     printf("ppw2->pvecmetric[ppw2->index_mt2_psi] = %g\n", ppw2->pvecmetric[ppw2->index_mt2_psi]);
    //     printf("ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson] = %g\n", ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson]);
    //     printf("ppw2->pvecmetric[ppw2->index_mt2_phi_prime_longitudinal] = %g\n", ppw2->pvecmetric[ppw2->index_mt2_phi_prime_longitudinal]);
    //     printf("- Hc*ppw2->pvecmetric[ppw2->index_mt2_psi] = %g\n", - Hc*ppw2->pvecmetric[ppw2->index_mt2_psi]);
    //     printf("+ 0.5 * (a2/k) * rho_dipole = %g\n", + 0.5 * (a2/k) * rho_dipole);
    //     printf("+ ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_longitudinal] = %g\n", + ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_longitudinal]);
    //     printf("\n");
    //   }
    // }


    /* Choose which equation to use */
    if (ppt2->phi_prime_eq == poisson)  {

      ppw2->pvecmetric[ppw2->index_mt2_phi_prime] =  ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson];

      /* Update the dy_quadsources for debug purposes */
      ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_phi] = ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_poisson];
    }
    else if (ppt2->phi_prime_eq == longitudinal) {

      ppw2->pvecmetric[ppw2->index_mt2_phi_prime] =  ppw2->pvecmetric[ppw2->index_mt2_phi_prime_longitudinal];

      /* Update the dy_quadsources for debug purposes */
      ppw2->pv->dy_quadsources[ppw2->pv->index_pt2_phi] = ppw2->pvec_metric_quadsources[ppw2->index_qm2_phi_prime_longitudinal];
    }

    /* Some debug */
    // if (ppw2->index_k1==0) {
    //   if (ppw2->index_k2==1) {
    //     fprintf (stderr, "%17.7g %17.7g %17.7g %17.7g %17.7g %17.7g\n", log10(a/pba->a_eq),
    //       ppw2->pvecmetric[ppw2->index_mt2_phi_prime],
    //       ppw2->pvecmetric[ppw2->index_mt2_phi_prime_poisson],
    //       ppw2->pvecmetric[ppw2->index_mt2_phi_prime_longitudinal],
    //       0.5 * (a2/k) * rho_g*I(1,0),
    //       0.5 * (a2/k) * rho_b*b_110
    //       );
    //   }
    // }


  } // end of if(newtonian)




  // ===============================================
  // =              Synchronous Gauge              =
  // ===============================================

  if (ppt->gauge == synchronous) {

    // // =========================================
    // // = h_prime - TIME-TIME EINSTEIN EQUATION =
    // // =========================================
    // // Eq. 21a of Ma & Berty
    // /* first equation involving total density fluctuation */
    // ppw2->pvecmetric[ppw2->index_mt2_h_prime] =
    //        ( k_sq * y[ppw2->pv->index_pt2_eta] + 1.5 * a2 * delta_rho)/(0.5*Hc)
    //        + ppw2->pvec_metric_quadsources[ppw2->index_mt2_h_prime];
    // 
    // /* infer streaming approximation for gamma and
    //         correct the total velocity */
    // // Skipped 47 lines of rsa approximation
    //     
    // 
    // // ==============================================
    // // = eta_prime - LONGITUDINAL EINSTEIN EQUATION =
    // // ==============================================
    // // Eq. 21b of Ma & Berty
    // /* second equation involving total velocity */
    // ppw2->pvecmetric[ppw2->index_mt2_eta_prime] = 1.5 * (a2/k_sq) * rho_plus_p_theta
    //   + ppw2->pvec_metric_quadsources[ppw2->index_mt2_eta_prime];
    // 
    // 
    // 
    // // ==============================================
    // // = h_prime_prime - TRACE OF EINSTEIN EQUATION =
    // // ==============================================
    // // Eq. 21c of Ma & Berty
    // /* third equation involving total pressure */
    // ppw2->pvecmetric[ppw2->index_mt2_h_prime_prime] = 
    //        -2.*Hc*ppw2->pvecmetric[ppw2->index_mt2_h_prime]
    //        +2.*k_sq*y[ppw2->pv->index_pt2_eta]
    //        -9.*a2*delta_p
    //        + ppw2->pvec_metric_quadsources[ppw2->index_mt2_h_prime_prime];
    // 
    // /* intermediate quantity: alpha = (h'+6eta')/2k^2 */
    // double alpha = (ppw2->pvecmetric[ppw2->index_mt2_h_prime] + 6.*ppw2->pvecmetric[ppw2->index_mt2_eta_prime])/2./k_sq;
    // 
    // /* eventually, infer first-order tight-coupling approximation for photon
    //        shear, then correct the total shear */
    // // Skipped 7 lines of tca
    // 
    // 
    // 
    // // ===============================================
    // // = alpha_prime - ANISOTROPIC STRESSES EQUATION =
    // // ===============================================
    // // Eq. 21d of Ma & Berty    
    // /* fourth equation involving total shear */
    // /* alpha' = (h''+6eta'')/2k_sq */      
    // ppw2->pvecmetric[ppw2->index_mt2_alpha_prime] = 
    //        - 4.5 * (a2/k_sq) * rho_plus_p_shear + y[ppw2->pv->index_pt2_eta] - 2.*Hc*alpha
    //        + ppw2->pvec_metric_quadsources[ppw2->index_mt2_alpha_prime];
    // 
    // /* getting phi here is an option */
    // /* phi=y[ppw2->pv->index_pt2_eta]-0.5 * (Hc/k_sq) * (h_plus_six_eta_prime); */   
    // /* phi from gauge transformation (from synchronous to newtonian) */

  } // end of if(synchronous)


  return _SUCCESS_;

}  // end of perturb2_einstein








/**
  * Compute the quadratic sources for the given set of wavemodes (k1,k2,mu), where mu = cosk1k2,
  * at all times contained in ppt->tau_sampling_quadsources.
  *
  * At the end of the routine, the following (double **) arrays will be filled:
  *  - ppw2->metric_quadsources_table
  *  - ppw2->liouville_quadsources_table
  *  - ppw2->collision_quadsources_table
  *
  */
int perturb2_quadratic_sources_for_k1k2mu(
      struct precision * ppr,
      struct background * pba,
      struct thermo * pth,            
      struct perturbs * ppt,
      struct perturbs2 * ppt2,
      struct perturb2_workspace * ppw2
      )
{

  int index_tau;

  for(index_tau=0; index_tau<ppt->tau_size_quadsources; ++index_tau) {
    
    double tau = ppt->tau_sampling_quadsources[index_tau];

    // *** Interpolate background-related quantities (pvecback)
    class_call (background_at_tau(
                 pba,
                 tau, 
                 pba->normal_info, 
                 pba->inter_closeby,
                 &(ppw2->last_index_back), 
                 ppw2->pvecback),
      pba->error_message,
      ppt2->error_message);


    // *** Interpolate thermodynaics-related quantities (pvecthermo)
    class_call (thermodynamics_at_z(
                 pba,
                 pth,
                 1./ppw2->pvecback[pba->index_bg_a]-1.,  /* redshift z=1./a-1 */
                 pth->inter_closeby,
                 &(ppw2->last_index_thermo),
                 ppw2->pvecback,
                 ppw2->pvecthermo),
      pth->error_message,
      ppt2->error_message);
    
    
    // *** Compute the value of the quadratic sources at index_tau
    class_call(perturb2_quadratic_sources(
                 ppr,
                 pba,
                 pth,            
                 ppt,
                 ppt2,
                 index_tau,
                 ppw2
                 ),
      ppt2->error_message,
      ppt2->error_message);
          
          
    /* Print to screen the collisional quadratic sources */
    // if ((ppw2->index_k1==0) && (ppw2->index_k2==1))
    //   printf("%g ", tau);
    //   
    // int index_qc;
    // if ((ppw2->index_k1==0) && (ppw2->index_k2==1))
    //   printf("%g ", ppw2->collision_quadsources_table[ppw2->index_qc2_monopole_g][index_tau]);
    // 
    // if ((ppw2->index_k1==0) && (ppw2->index_k2==1))
    //   printf("\n");

  }



  /* Compute second-order derivatives of the quadratic sources in view of spline interpolation */
  if (ppt->quadsources_interpolation == cubic_quadsources_interpolation) {

    class_call (spline_sources_derivs_two_levels(
                  ppt->tau_sampling_quadsources, /* vector of size tau_size_quadsources */
                  ppt->tau_size_quadsources,
                  ppw2->metric_quadsources_table,
                  ppw2->qm2_size,
                  ppw2->dd_metric_quadsources_table,
                  _SPLINE_EST_DERIV_,
                  // _SPLINE_NATURAL_,
                  ppt2->error_message
                  ),
      ppt2->error_message,
      ppt2->error_message);

    class_call (spline_sources_derivs_two_levels(
                  ppt->tau_sampling_quadsources, /* vector of size tau_size_quadsources */
                  ppt->tau_size_quadsources,
                  ppw2->liouville_quadsources_table,
                  ppw2->ql2_size,
                  ppw2->dd_liouville_quadsources_table,
                  _SPLINE_EST_DERIV_,
                  // _SPLINE_NATURAL_,
                  ppt2->error_message
                  ),
      ppt2->error_message,
      ppt2->error_message);

    class_call (spline_sources_derivs_two_levels(
                  ppt->tau_sampling_quadsources, /* vector of size tau_size_quadsources */
                  ppt->tau_size_quadsources,
                  ppw2->collision_quadsources_table,
                  ppw2->qc2_size,
                  ppw2->dd_collision_quadsources_table,
                  _SPLINE_EST_DERIV_,
                  // _SPLINE_NATURAL_,
                  ppt2->error_message
                  ),
      ppt2->error_message,
      ppt2->error_message);

  } // end of if(cubic_quadsources_interpolation)

  
    
  return _SUCCESS_;

}






int perturb2_quadratic_sources(
      struct precision * ppr,
      struct background * pba,
      struct thermo * pth,            
      struct perturbs * ppt,
      struct perturbs2 * ppt2,
      int index_tau,
      struct perturb2_workspace * ppw2
      )
{
        

  // **********************               Shortcuts and constants               *******************
 
 
  /* Cycle variables */
  int l,m;
 
  /* Alleviate notation */
  double * pvecback = ppw2->pvecback;
  double * pvecthermo = ppw2->pvecthermo;
  double * pvecmetric = ppw2->pvecmetric;
  
 
  /* Considered wavemodes, and relative shortcuts */
  double k = ppw2->k;
  double k_sq = ppw2->k_sq; 
  double cosk1k = ppw2->cosk1k; 
  double cosk2k = ppw2->cosk2k; 
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  double mu = ppw2->cosk1k2;
  double mu_sq = mu*mu;
  double kx1 = ppw2->kx1, kx2 = ppw2->kx2;
  double kz1 = ppw2->kz1, kz2 = ppw2->kz2;
  double k1_dot_k2 = ppw2->k1_dot_k2;
  double k1_sq = k1*k1;
  double k2_sq = k2*k2;  
  double k_pow4 = k_sq*k_sq;
  double k1_pow3 = k1_sq*k1;
  double k2_pow3 = k2_sq*k2;
  double k1_pow4 = k1_sq*k1_sq;
  double k2_pow4 = k2_sq*k2_sq;  
  double * k1_m = ppw2->k1_m;
  double * k2_m = ppw2->k2_m;  
 
  /* Variables related to the multipole expansion */
  int l_max_g, l_max_pol_g, l_max_ur;
  int m_max = ppw2->m_max;
  int lm_extra = ppt2->lm_extra;  

 
 
  /* Shortcuts to background and thermodynamics quantities */
  double a = ppw2->pvecback[pba->index_bg_a];
  double a2 = a*a;
  double Hc = ppw2->pvecback[pba->index_bg_H]*a;
  double kappa_dot = ppw2->pvecthermo[pth->index_th_dkappa];     /* Interaction rate */
  double r = ppw2->pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_b];
  double Y = log10 (a/pba->a_eq);
 
 
 
 
 
 
  // *********************              Get first order quantites               ***********************
 
 
 
  /* Copy the first-order quantities, indexed by ppt->index_qs_XXX, into the vectors
    pvec_sources1 and pvec_sources2 of the ppw2 structure. */
  int index_type;
  
  /* Number of elements to be copied into the arrays */
  int qs_size = ppt->qs_size[ppt2->index_mode];
  
  /* Loop over types */
  for (index_type=0; index_type<qs_size; ++index_type) {
 
    /* First-order sources in k1 */
    ppw2->pvec_sources1[index_type] =
      ppt->quadsources[ppt2->index_mode][ppt2->index_ic*qs_size + index_type][index_tau*ppt->k_size[ppt2->index_mode] + ppw2->index_k1];
 
    /* First-order sources in k2 */
    ppw2->pvec_sources2[index_type] =
      ppt->quadsources[ppt2->index_mode][ppt2->index_ic*qs_size + index_type][index_tau*ppt->k_size[ppt2->index_mode] + ppw2->index_k2];
    
  }
 
  /* Define shorthands */
  double * pvec_sources1 = ppw2->pvec_sources1;
  double * pvec_sources2 = ppw2->pvec_sources2;
 
 
 
  /* Print first-order variables to stderr (save to file with ./class params.ini params.pre 2> file.txt ) */

  // if ((ppw2->index_k1==0) && (ppw2->index_k2==0)) {
  //   fprintf (stderr, "%17.7g %17.7g %17.7g %17.7g %17.7g\n",
  //     ppt->tau_sampling_quadsources[index_tau],
  //     a,
  //     Y,
  //     ppw2->pvec_sources1[ppt->index_qs_delta_g],
  //     ppw2->pvec_sources2[ppt->index_qs_delta_g]
  //   );
  // }
 
 
 
  // ******************             Rotation of the first-order quantities               ********************
 
 
  
  /* We computed the evolution of the 1st-order perturbations in the module perturbations.c.  We
    shall now use those results because the 1st-order quantities appear on the right-hand side
    of the 2nd-order equations.  First, however, we need to rotate these quantities, since
    when we computed them, we assumed that their wavemode was aligned with the zenith axis (for
    more details, see eq. A.37 of Pitrou et al. 2010).
    
     The rotations are the same regardless of the considered species.  Relativistic species (photons
    and neutrinos), however, will have high moments and the rotation of such moments can be complicated.
    We do rotate them immediately below, and store the rotated multipoles into the arrays
    ppw2->rotated_multipoles_g_1, ppw2->rotated_multipoles_g_2, ppw2->rotated_multipoles_ur_1 and
    ppw2->rotated_multipoles_ur_2.  To do so we use the previously computed rotation coefficients
    ppw2->rotation_1  and  ppw2->rotation_2.  
    
     For CDM and baryons, we only need to rotate the velocity because (i) the energy density is a monopole
    and is invariant under rotations, and (ii) higher moments are suppressed at first-order. We already
    incorporate the rotation in the equations for these two species. The rotation of the first-order velocity
    is given by this simple formula:
       v_m(k) = -k_m * v,
    where v(k) is the scalar part of the irrotational velocity, obtained as v=-theta/k^2 with theta given
    by the first-order differential system. The formula is equivalent to eq. A.38 of Pitrou et
    al. 2010, even though we use a different notation.  (Note that our left hand side is the velocity
    multiplied by the imaginary factor.)
    
     Also for Einstein equations we include the rotations of the quadratic sources directly in the equations. */
    
    
  // *** Rotation of first-order photon multipoles
 
  /* We compute the rotated multipoles up to l_max+lm_extra and m_max+lm_extra.  The
    'tilde' suffix denotes any 1st-order quantity which is computed with
    the symmetry axis aligned with its wavemode.  For example, I_1_tilde(l) is
    the (l,0) 1st-order moment in k1, computed with k1 aligned with the z-axis. */
  l_max_g = ppw2->l_max_g;  
  for(l=0; l<=(l_max_g+lm_extra); ++l) {
    for(m=0; m<=min(l,m_max+lm_extra); ++m) {
      ppw2->rotated_multipoles_g_1[lm_quad(l,m)] = ppw2->rotation_1[lm_quad(l,m)] * I_1_tilde(l);
      ppw2->rotated_multipoles_g_2[lm_quad(l,m)] = ppw2->rotation_2[lm_quad(l,m)] * I_2_tilde(l);
    }
  }
 
  // *** Photon polarization
  if (ppt2->has_polarization2 == _TRUE_) {
    
    l_max_pol_g = ppw2->l_max_pol_g;  
  
    // We assume there are no B-modes at first-order, hence we compute only the rotated E-modes
    for(l=2; l<(l_max_pol_g+lm_extra); ++l) {
      for(m=0; m<=min(l,m_max+lm_extra); ++m) {
        ppw2->rotated_multipoles_E_1[lm_quad(l,m)] = ppw2->rotation_1[lm_quad(l,m)] * E_1_tilde(l);
        ppw2->rotated_multipoles_E_2[lm_quad(l,m)] = ppw2->rotation_2[lm_quad(l,m)] * E_2_tilde(l);
      }
    }
  } // end of if(has_polarization2)
 
  
  // *** Rotation of first-order neutrino multipoles  
  if (pba->has_ur == _TRUE_) {
    l_max_ur = ppw2->l_max_ur;
    for(l=0; l<=(l_max_g+lm_extra); ++l) {
      for(m=0; m<=min(l,m_max+lm_extra); ++m) {
        ppw2->rotated_multipoles_ur_1[lm_quad(l,m)] = ppw2->rotation_1[lm_quad(l,m)] * N_1_tilde(l);
        ppw2->rotated_multipoles_ur_2[lm_quad(l,m)] = ppw2->rotation_2[lm_quad(l,m)] * N_2_tilde(l);
      }
    }
  } // end of if(has_ur)
 
  // *** Shortcurts to access the rotated multipoles
  /* We set the multipoles to zero when they are accessed with abs(m)>l.  Furthermore, to allow
     for negative 'm' multipoles, we automatically include the -1^m factor.  The E-modes are
     set to be different from zero only if polarization is requested.  We have no need for
     the rotated B-modes because they vanish at 1st order.  */
  #define I_1(l,m) ( abs(m) > (l) ? 0. : ((m) > 0 ? ppw2->rotated_multipoles_g_1[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotated_multipoles_g_1[lm_quad((l),abs(m))]))
  #define I_2(l,m) ( abs(m) > (l) ? 0. : ((m) > 0 ? ppw2->rotated_multipoles_g_2[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotated_multipoles_g_2[lm_quad((l),abs(m))]))
 
  #define E_1(l,m) ( ((abs(m) > (l))||(ppt2->has_polarization2==_FALSE_)) ? 0. : ((m) > 0 ? ppw2->rotated_multipoles_E_1[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotated_multipoles_E_1[lm_quad((l),abs(m))]))
  #define E_2(l,m) ( ((abs(m) > (l))||(ppt2->has_polarization2==_FALSE_)) ? 0. : ((m) > 0 ? ppw2->rotated_multipoles_E_2[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotated_multipoles_E_2[lm_quad((l),abs(m))]))
 
  #define N_1(l,m) ( abs(m) > (l) ? 0. : ((m) > 0 ? ppw2->rotated_multipoles_ur_1[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotated_multipoles_ur_1[lm_quad((l),abs(m))]))
  #define N_2(l,m) ( abs(m) > (l) ? 0. : ((m) > 0 ? ppw2->rotated_multipoles_ur_2[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotated_multipoles_ur_2[lm_quad((l),abs(m))]))
  
  
  
  /* Test that I_1(1,-1) = -I_1(1,1) and that I_2(1,-1) = -I_2(1,1). This is a test on our definition of I_1 and I_2. */
  class_test (
    abs(I_1(1,-1)+I_1(1,1))>_EPS_ || abs(I_2(1,-1)+I_2(1,1))>_EPS_,
    ppt2->error_message,
    "I_1(1,-1) != -I_1(1,1), there must be an error in the definition of the rotated first-order multipoles.");
   
   
 



  // ******************             Compute QS for Einstein equations               ********************
 



   
  // =====================================================
  // =               Energy momentum tensor              =
  // =====================================================
 
  /* The matter variables appearing in the energy momentum tensor (i.e. the right
    hand side of Einstein equations), have to be summed over the different species.
    In the beta-moments approach the only quadratic contribution comes from the
    tetrad transformation of the g_0i components, that is from the dipole of the
    distribution function.  We shall sum it over the various species below. */
 
  // *** Shortcuts realated to the matter variables
 
  /* Contribution of the single species */
  double rho_g=0, rho_b=0, rho_cdm=0, rho_ur=0;
  double dipole_b_1=0, dipole_b_2=0;
  double dipole_cdm_1=0, dipole_cdm_2=0;
  double dipole_ur_1=0, dipole_ur_2=0;  
 
  /* Variables that will accumulate the contribution from all species */
  double rho_dipole_1 = 0;                    /* rho*dipole(k1) */
  double rho_dipole_2 = 0;                    /* rho*dipole(k2) */
 
  /* CDM & baryons variables at first-order.  These are just convenient shortcuts to avoid specifying
    every time _b or _cdm .Note that there is no shear or pressure because we are assuming that
    they both vanish at first order. */
  double delta_1=0, v_1=0, v_1_prime=0;
  double delta_2=0, v_2=0, v_2_prime=0;
 
 
 
  // *******      Photon contribution       ********
  rho_g = pvecback[pba->index_bg_rho_g];        
  rho_dipole_1         =  rho_g*I_1_tilde(1);
  rho_dipole_2         =  rho_g*I_2_tilde(1);
 
 
  // *******      Baryon contribution       ********
  rho_b = pvecback[pba->index_bg_rho_b];
  rho_dipole_1         +=  rho_b*pvec_sources1[ppt->index_qs_dipole_b];
  rho_dipole_2         +=  rho_b*pvec_sources2[ppt->index_qs_dipole_b];
 
 
  // *******      CDM contribution       ********
  if (pba->has_cdm == _TRUE_) {
 
    rho_cdm = pvecback[pba->index_bg_rho_cdm];
    rho_dipole_1         +=  rho_cdm*pvec_sources1[ppt->index_qs_dipole_cdm];
    rho_dipole_2         +=  rho_cdm*pvec_sources2[ppt->index_qs_dipole_cdm];
  }
 
  // *******      Neutrinos/UR relics contribution       ********
  if (pba->has_ur == _TRUE_) {
 
    rho_ur = pvecback[pba->index_bg_rho_ur];
    rho_dipole_1         +=  rho_ur*N_1_tilde(1);
    rho_dipole_2         +=  rho_ur*N_2_tilde(1);
  }
 
 
 
  // =====================================================
  // =                   Einstein tensor                 =
  // =====================================================
  
  /* Shortcuts */
  double phi_1, phi_2, psi_1, psi_2, phi_prime_1, phi_prime_2;
  double eta_1, eta_2, eta_prime_1, eta_prime_2, eta_prime_prime_1, eta_prime_prime_2;
  double h_1, h_2, h_prime_1, h_prime_2, h_prime_prime_1, h_prime_prime_2; 
 
  // ***************           Synchronous gauge             ***************
 
  if (ppt->gauge == synchronous) {
 
    // *** Define shorthands for the metric variables
    
    /* eta */
    eta_1 =  pvec_sources1[ppt->index_qs_eta];
    eta_2 =  pvec_sources2[ppt->index_qs_eta];
    /* eta' */
    eta_prime_1 =  pvec_sources1[ppt->index_qs_eta_prime];
    eta_prime_2 =  pvec_sources2[ppt->index_qs_eta_prime];
    /* eta'' */
    eta_prime_prime_1 =  pvec_sources1[ppt->index_qs_eta_prime_prime];
    eta_prime_prime_2 =  pvec_sources2[ppt->index_qs_eta_prime_prime];
    /* h */
    h_1 =  pvec_sources1[ppt->index_qs_h];
    h_2 =  pvec_sources2[ppt->index_qs_h];
    /* h' */
    h_prime_1 =  pvec_sources1[ppt->index_qs_h_prime];
    h_prime_2 =  pvec_sources2[ppt->index_qs_h_prime];
    /* h'' */
    h_prime_prime_1 =  pvec_sources1[ppt->index_qs_h_prime_prime];
    h_prime_prime_2 =  pvec_sources2[ppt->index_qs_h_prime_prime];
    
    
    /* Code the Einstein tensor for synchronous gauge, TODO! */
    
 
  }
 
 
 
  // ***************           Newtonian gauge             ***************
 
  if (ppt->gauge == newtonian) {
 
    // *** Define shorthands for the metric variables
    
    /* phi */
    phi_1 =  pvec_sources1[ppt->index_qs_phi];
    phi_2 =  pvec_sources2[ppt->index_qs_phi];
    
    /* psi */
    psi_1 =  pvec_sources1[ppt->index_qs_psi];
    psi_2 =  pvec_sources2[ppt->index_qs_psi];

    /* phi' */
    phi_prime_1 = pvec_sources1[ppt->index_qs_phi_prime];
    phi_prime_2 = pvec_sources2[ppt->index_qs_phi_prime];
 
 
    // *** psi constraint equation
    #include "newt/einstein/psi_quad.c"
 
    // *** phi_prime constraint equation, using Poisson equation
    #include "newt/einstein/phi_prime_poisson_quad.c"
    
    // *** phi_prime constraint equation, using the Longitudinal (g_0i) equation
    #include "newt/einstein/phi_prime_longitudinal_quad.c"        
 
    /* Choose between Poisson and longitudinal equations */
    if (ppt2->phi_prime_eq == poisson)
      ppw2->metric_quadsources_table[ppw2->index_qm2_phi_prime][index_tau] =
        ppw2->metric_quadsources_table[ppw2->index_qm2_phi_prime_poisson][index_tau];
 
    else if (ppt2->phi_prime_eq == longitudinal)
      ppw2->metric_quadsources_table[ppw2->index_qm2_phi_prime][index_tau] =
        ppw2->metric_quadsources_table[ppw2->index_qm2_phi_prime_longitudinal][index_tau];        
 
  
  } // end of if(newtonian)
 
 
 
  // ******************             Compute QS for the Liouville operator               ********************
 
 
 
  if (ppt2->has_quadratic_liouville == _TRUE_) {
 
 
    // ***************           Newtonian gauge             ***************
 
    if (ppt->gauge == newtonian) {
 
 
      // ================================================
      // =               Photon temperature             =
      // ================================================
      for (l=0; l<=l_max_g; ++l) {      
        for (m=0; m<=min(l,m_max); ++m) {
      
          /* We shall increment the dI_quad array, hence we set it to zero. */
          dI_ql_table(l,m) = 0;
          
          // *** Monopole specific contribution
          if (l==0)
            dI_ql_table(0,0) = - 8*phi_1*phi_prime_2 - 8*phi_2*phi_prime_1;
      
      
          // *** Dipole specific contribution
          if (l==1)
            dI_ql_table(1,m) = 4 * ( k1_m[m+1]*psi_1*(psi_2-phi_2) + k2_m[m+1]*psi_2*(psi_1-phi_1) );
          
      
          // *** Time-delay and lensing contributions
          /* Here we write down the 3rd and 4th row of eq. 143 of BF2010, equivalent to eqs. A.43 and
             A.44 of P2010. The coupling coefficients R are basically equal to l*C, hence the associated
             terms are important also for very high l's. All the R-terms come from the lensing part of
             Boltzmann equation and will need a special treatment in the line-of-sight integral. */
          dI_ql_table(l,m) += - 4*phi_prime_1*I_2(l,m) 
                          + I_2_tilde(l+1) * ( r_plus_12(l,m)*k1*(phi_1+psi_1)   +  c_plus_22(l,m)*k2*(phi_1+psi_1)  +  4*c_plus_12(l,m)*k1*psi_1  )
                          - I_2_tilde(l-1) * ( r_minus_12(l,m)*k1*(phi_1+psi_1)  +  c_minus_22(l,m)*k2*(phi_1+psi_1) +  4*c_minus_12(l,m)*k1*psi_1 );
        
          /* Symmetrization */
          dI_ql_table(l,m) += - 4*phi_prime_2*I_1(l,m)
                          + I_1_tilde(l+1) * ( r_plus_21(l,m)*k2*(phi_2+psi_2)   +  c_plus_11(l,m)*k1*(phi_2+psi_2)  +  4*c_plus_21(l,m)*k2*psi_2  )
                          - I_1_tilde(l-1) * ( r_minus_21(l,m)*k2*(phi_2+psi_2)  +  c_minus_11(l,m)*k1*(phi_2+psi_2) +  4*c_minus_21(l,m)*k2*psi_2 );
      
          /* Account for the fact that in BF2010 the Liouville operator appears on the left-hand-side */
          dI_ql_table(l,m) *= -1;
      
      
        } // end of for(m)
      } // end of for(l)
 

      // // *** Brute force approach
      // // Take care of the rotation of the photon first-order multipoles.
      // // Also define the variables for the I_l_m multipoles at first order.
      // #include "newt/radiation/lmax100_mmax2_g/multipoles_g_quad.c"
      // // Quadratic sources in the photon hierarchy
      // #include "newt/radiation/lmax100_mmax2_g/hierarchy_g_quad.c"        




      /* Print results for both positive and negative m, in order to check that they are related by a
        -1^m factor. This must be the case with our choice of aligning the k vector with z, and of
        make k1 and k2 lie in the zx plane. */
      // {
      //   int l = 2;
      //   int m = -1;
      // 
      //   double I_plus = dI_ql_table(l,abs(m));
      //   double I_minus = 0;
      // 
      //   if (I_plus != 0) {
      // 
      //     double cosk1k = ppw2->cosk1k;
      //     double cosk2k = ppw2->cosk2k;
      // 
      //     #define rot_1(l,m) ( (((l) < 0) || (abs(m)>(l))) ? 0 : ( (m) > 0 ? ppw2->rotation_1[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotation_1[lm_quad((l),abs(m))] ) )
      //     #define rot_2(l,m) ( (((l) < 0) || (abs(m)>(l))) ? 0 : ( (m) > 0 ? ppw2->rotation_2[lm_quad((l),(m))] : alternating_sign(m)*ppw2->rotation_2[lm_quad((l),abs(m))] ) )
      // 
      //     int m2;
      //     double c_plus_product_22=0, c_plus_product_12=0, c_minus_product_22=0, c_minus_product_12=0;
      //     double c_plus_product_11=0, c_plus_product_21=0, c_minus_product_11=0, c_minus_product_21=0;
      //     double r_plus_product_12=0, r_minus_product_12=0, r_plus_product_21=0, r_minus_product_21=0;
      //   
      //     for (m2=-1; m2<=1; ++m2) {
      // 
      //       int m1 = m-m2;
      // 
      //       c_minus_product_12 += rot_1(1,m2) * rot_2(l-1,m1) * c_minus(l,m1,m);
      //       c_minus_product_21 += rot_2(1,m2) * rot_1(l-1,m1) * c_minus(l,m1,m);
      //       c_plus_product_12  += rot_1(1,m2) * rot_2(l+1,m1) * c_plus(l,m1,m);
      //       c_plus_product_21  += rot_2(1,m2) * rot_1(l+1,m1) * c_plus(l,m1,m);
      //       c_minus_product_11 += rot_1(1,m2) * rot_1(l-1,m1) * c_minus(l,m1,m);
      //       c_minus_product_22 += rot_2(1,m2) * rot_2(l-1,m1) * c_minus(l,m1,m);
      //       c_plus_product_11  += rot_1(1,m2) * rot_1(l+1,m1) * c_plus(l,m1,m);
      //       c_plus_product_22  += rot_2(1,m2) * rot_2(l+1,m1) * c_plus(l,m1,m);
      //   
      //     }
      // 
      //     #undef rot_1
      //     #undef rot_2
      // 
      //     r_minus_product_12 =  (l-1) * c_minus_product_12;
      //     r_minus_product_21 =  (l-1) * c_minus_product_21;
      //     r_plus_product_12  = -(l+2) * c_plus_product_12;
      //     r_plus_product_21  = -(l+2) * c_plus_product_21;
      // 
      // 
      //     // *** Monopole specific contribution
      //     if (l==0)
      //       I_minus = - 8*phi_1*phi_prime_2 - 8*phi_2*phi_prime_1;
      // 
      // 
      //     // *** Dipole specific contribution
      //     if (l==1)
      //       I_minus = 4 * ( k1_m[m+1]*psi_1*(psi_2-phi_2) + k2_m[m+1]*psi_2*(psi_1-phi_1) );
      // 
      //     I_minus += - 4*phi_prime_1*I_2(l,m) 
      //                       + I_2_tilde(l+1) * ( r_plus_product_12*k1*(phi_1+psi_1)   +  c_plus_product_22*k2*(phi_1+psi_1)  +  4*c_plus_product_12*k1*psi_1  )
      //                       - I_2_tilde(l-1) * ( r_minus_product_12*k1*(phi_1+psi_1)  +  c_minus_product_22*k2*(phi_1+psi_1) +  4*c_minus_product_12*k1*psi_1 );
      // 
      // 
      //     /* Symmetrization */
      //     I_minus += - 4*phi_prime_2*I_1(l,m)
      //                       + I_1_tilde(l+1) * ( r_plus_product_21*k2*(phi_2+psi_2)   +  c_plus_product_11*k1*(phi_2+psi_2)  +  4*c_plus_product_21*k2*psi_2  )
      //                       - I_1_tilde(l-1) * ( r_minus_product_21*k2*(phi_2+psi_2)  +  c_minus_product_11*k1*(phi_2+psi_2) +  4*c_minus_product_21*k2*psi_2 );
      //     
      //     /* Account for the fact that in BF2010 the Liouville operator appears on the left-hand-side */
      //     I_minus *= -1;
      // 
      //     printf("I_quadliouville(%d,%+d) = %20.16f\nI_quadliouville(%d,%d) = %20.16f\n\n", l, abs(m), I_plus, l, m, I_minus);
      //     
      //   } // end of if(I_plus!=0)
      // 
      // }
  
 
 
 
      // ========================================
      // =          Photon polarization         =
      // ========================================
      if (ppt2->has_polarization2 == _TRUE_) {
 
        for (l=2; l<=l_max_pol_g; ++l) {      
          for (m=0; m<=min(l,m_max); ++m) {
 
            // *** E-modes ****
            
            /* Second and third row of eq. 145 of BF2010, without the first-order B-modes. */
            dE_ql_table(l,m)  = - 4*phi_prime_1*E_2(l,m) 
                            + E_2_tilde(l+1) * ( k_plus_12(l,m)*k1*(phi_1+psi_1)   +  d_plus_22(l,m)*k2*(phi_1+psi_1)  +  4*d_plus_12(l,m)*k1*psi_1  )
                            - E_2_tilde(l-1) * ( k_minus_12(l,m)*k1*(phi_1+psi_1)  +  d_minus_22(l,m)*k2*(phi_1+psi_1) +  4*d_minus_12(l,m)*k1*psi_1 );
            
            /* Symmetrization */
            dE_ql_table(l,m) += - 4*phi_prime_2*E_1(l,m)
                            + E_1_tilde(l+1) * ( k_plus_21(l,m)*k2*(phi_2+psi_2)   +  d_plus_11(l,m)*k1*(phi_2+psi_2)  +  4*d_plus_21(l,m)*k2*psi_2  )
                            - E_1_tilde(l-1) * ( k_minus_21(l,m)*k2*(phi_2+psi_2)  +  d_minus_11(l,m)*k1*(phi_2+psi_2) +  4*d_minus_21(l,m)*k2*psi_2 );
 
            /* Account for the fact that in BF2010 the Liouville operator appears on the left-hand-side */
            dE_ql_table(l,m) *= -1;
 
 
 
            // *** B-modes ****
 
            /* Fourth and fifth row of eq. 146 of BF2010 (the other rows contain first-order B-modes) */
            dB_ql_table(l,m)  = - E_2_tilde(l) * ( k_zero_12(l,m)*k1*(phi_1+psi_1) + d_zero_22(l,m)*k2*(phi_1+psi_1) + 4*d_zero_12(l,m)*k1*psi_1 );
            
            /* Symmetrization */
            dB_ql_table(l,m) += - E_1_tilde(l) * ( k_zero_21(l,m)*k2*(phi_2+psi_2) + d_zero_11(l,m)*k1*(phi_2+psi_2) + 4*d_zero_21(l,m)*k2*psi_2 );
 
            /* Account for the fact that in BF2010 the Liouville operator appears on the left-hand-side */
            dB_ql_table(l,m) *= -1;
 
          } // end of for(m)
        } // end of for(l)
      } // end of if(has_polarization2)
 
 
 
      // =======================================
      // =                Baryons              =
      // =======================================
 
      /* Define shorthands for the baryon fluid variables */
      delta_1    =   pvec_sources1[ppt->index_qs_delta_b];
      delta_2    =   pvec_sources2[ppt->index_qs_delta_b];  
      v_1        =   pvec_sources1[ppt->index_qs_v_b];
      v_2        =   pvec_sources2[ppt->index_qs_v_b];
 
      // *** Monopole
      db_ql_table(0,0,0) =
          2*k1_dot_k2*(psi_1-phi_1)*v_2 + k2_sq*(phi_1+psi_1)*v_2 + 3*phi_prime_1*(delta_2 + 2*phi_2)
        + 2*k1_dot_k2*(psi_2-phi_2)*v_1 + k1_sq*(phi_2+psi_2)*v_1 + 3*phi_prime_2*(delta_1 + 2*phi_1);
 
 
      // *** Dipole
      for (m=0; m <= min(1,m_max); ++m) 
        db_ql_table(1,1,m) = 3*k1_m[m+1]*(delta_2*psi_1 - 4*v_1*phi_prime_2 + phi_2*psi_1)
                           + 3*k2_m[m+1]*(delta_1*psi_2 - 4*v_2*phi_prime_1 + phi_1*psi_2)
                           - 3*psi_1*psi_2*(k1_m[m+1] + k2_m[m+1]);
 
 
      /* If we are evolving s_11m instead of b_11m, then its quadratic sources are given
        by the sum db_ql_table(1,1,m) + r*dI_ql_table(1,m), without a collision contribution */
      if (ppt2->has_smart_dipole == _TRUE_)
        for (m=0; m <= min(1,m_max); ++m)    
          db_ql_table(1,1,m) += r*dI_ql_table(1,m);
 
 
      // *** Pressure & Quadrupole
      if (ppt2->has_perfect_baryons == _FALSE_) {
 
        db_ql_table(2,0,0) = 2*k1_dot_k2*(psi_1*v_2 + psi_2*v_1);
 
        for (m=0; m <= min(2,m_max); ++m)
          db_ql_table(2,2,m) = -15*ppw2->k1_ten_k2[m+2]*(psi_1*v_2 + psi_2*v_1);
      }
      else {
 
        v_1_prime  =  pvec_sources1[ppt->index_qs_v_b_prime];
        v_2_prime  =  pvec_sources2[ppt->index_qs_v_b_prime];
 
        /* Enforce zero pressure */
        db_ql_table(2,0,0) = -2*k1_dot_k2*(v_1_prime*v_2 + v_2_prime*v_1);
 
        /* Enforce zero anisotropic stresses */
        for (m=0; m <= min(2,m_max); ++m)
          db_ql_table(2,2,m) = 15*ppw2->k1_ten_k2[m+2]*(v_1_prime*v_2 + v_2_prime*v_1);
          
      } // end of if(has_perfect_baryons)

 
      // // *** Brute force approach
      // // Definition of the first order multipoles 
      // #include "newt/cold_matter/multipoles_b_quad.c"     
      // // Quadratic sources baryon fluid equations
      // #include "newt/cold_matter/hierarchy_b_quad.c"
      
 
 
      // ==============================================
      // =               Cold Dark Matter             =
      // ==============================================
 
      if (pba->has_cdm == _TRUE_) {     
        
        /* Define shorthands for the cdm fluid variables */
        delta_1   =   pvec_sources1[ppt->index_qs_delta_cdm];
        delta_2   =   pvec_sources2[ppt->index_qs_delta_cdm];  
        v_1       =   pvec_sources1[ppt->index_qs_v_cdm];
        v_2       =   pvec_sources2[ppt->index_qs_v_cdm];
 
 
        // *** Monopole
        dcdm_ql_table(0,0,0) =
            2*k1_dot_k2*(psi_1-phi_1)*v_2 + k2_sq*(phi_1+psi_1)*v_2 + 3*phi_prime_1*(delta_2 + 2*phi_2)
          + 2*k1_dot_k2*(psi_2-phi_2)*v_1 + k1_sq*(phi_2+psi_2)*v_1 + 3*phi_prime_2*(delta_1 + 2*phi_1);
 
 
        // *** Dipole
        /* Note that the last contribution vanishes for m=1 since k1_[1] + k2_[1] = 0. */
        for (m=0; m <= min(1,m_max); ++m) 
          dcdm_ql_table(1,1,m) = 3*k1_m[m+1]*(delta_2*psi_1 - 4*v_1*phi_prime_2 + phi_2*psi_1)
                           + 3*k2_m[m+1]*(delta_1*psi_2 - 4*v_2*phi_prime_1 + phi_1*psi_2)
                           - 3*psi_1*psi_2*(k1_m[m+1] + k2_m[m+1]);
 
 
        // *** Pressure & Quadrupole
        if (ppt2->has_perfect_cdm == _FALSE_) {
                  
          dcdm_ql_table(2,0,0) = 2*k1_dot_k2*(psi_1*v_2 + psi_2*v_1);
 
          for (m=0; m <= min(2,m_max); ++m)
            dcdm_ql_table(2,2,m) = -15*ppw2->k1_ten_k2[m+2]*(psi_1*v_2 + psi_2*v_1);
        }
        else {
 
          v_1_prime  =  pvec_sources1[ppt->index_qs_v_cdm_prime];
          v_2_prime  =  pvec_sources2[ppt->index_qs_v_cdm_prime];
 
          /* Enforce zero pressure */
          dcdm_ql_table(2,0,0) = -2*k1_dot_k2*(v_1_prime*v_2 + v_2_prime*v_1);
 
          /* Enforce zero anisotropic stresses */
          for (m=0; m <= min(2,m_max); ++m)
            dcdm_ql_table(2,2,m) = 15*ppw2->k1_ten_k2[m+2]*(v_1_prime*v_2 + v_2_prime*v_1);
 
        } // end of if(has_perfect_cdm)
 
      } // end of if(has_cdm)
 
 
      // *** Brute force approach
      // if (pba->has_cdm == _TRUE_) {
      // // Definition of the first order multipoles 
      //   #include "newt/cold_matter/multipoles_cdm_quad.c"      
      //   // Quadratic sources for CDM fluid equations
      //   #include "newt/cold_matter/hierarchy_cdm_quad.c"
      // }
 
        
 
      // =======================================================
      // =              Ultra Relativistic Neutrinos           =
      // =======================================================
 
      /* This is exactly the same hierarchy as the one above for photons. */
      if (pba->has_ur == _TRUE_) {
        
        for (l=0; l<=l_max_ur; ++l) {      
          for (m=0; m<=min(l,m_max); ++m) {
      
            /* We shall increment the dN_quad array, hence we set it to zero. */
            dN_ql_table(l,m) = 0;
          
            // *** Monopole specific contribution
            if (l==0)
              dN_ql_table(0,0) = - 8*phi_1*phi_prime_2 - 8*phi_2*phi_prime_1;
      
      
            // *** Dipole specific contribution
            if (l==1)
              dN_ql_table(1,m) = 4 * ( k1_m[m+1]*psi_1*(psi_2-phi_2) + k2_m[m+1]*psi_2*(psi_1-phi_1) );
          
 
            // *** Time-delay and lensing contributions
            dN_ql_table(l,m) += - 4*phi_prime_1*N_2(l,m) 
                            + N_2_tilde(l+1) * ( r_plus_12(l,m)*k1*(phi_1+psi_1)   +  c_plus_22(l,m)*k2*(phi_1+psi_1)+4*c_plus_12(l,m)*k1*psi_1  )
                            - N_2_tilde(l-1) * ( r_minus_12(l,m)*k1*(phi_1+psi_1)  +  c_minus_22(l,m)*k2*(phi_1+psi_1)+4*c_minus_12(l,m)*k1*psi_1 );
          
            /* Symmetrization */
            dN_ql_table(l,m) += - 4*phi_prime_2*N_1(l,m)
                            + N_1_tilde(l+1) * ( r_plus_21(l,m)*k2*(phi_2+psi_2)   +  c_plus_11(l,m)*k1*(phi_2+psi_2)+4*c_plus_21(l,m)*k2*psi_2  )
                            - N_1_tilde(l-1) * ( r_minus_21(l,m)*k2*(phi_2+psi_2)  +  c_minus_11(l,m)*k1*(phi_2+psi_2)+4*c_minus_21(l,m)*k2*psi_2 );
 
      
            /* Account for the fact that in BF2010 the Liouville operator appears on the left-hand-side */
            dN_ql_table(l,m) *= -1;
      
      
          } // end of for(m)
        } // end of for(l)
      } // end of if(has_ur)
 
      
      // // *** Brute force approach
      // if (pba->has_ur == _TRUE_) {
      //   l_max_ur = ppw2->l_max_ur;
      //   // Rotation of the photon first-order multipoles.
      //   #include "newt/radiation/lmax100_mmax2_ur/multipoles_ur_quad.c"      
      //   // Quadratic sources in the photon hierarchy
      //   #include "newt/radiation/lmax100_mmax2_ur/hierarchy_ur_quad.c"        
      // }        
 
    }  // end of if(newtonian)
 
    } // end of if(has_quadratic_liouville)
 
 
 
 
 
 
  // ******************             Compute QS for the collision term               ********************  
 
  /* We now compute the quadratic part of the collision term for the various species.  
    As in the purely second order part, the collision term is multiplied by the Compton scattering
    rate, kappa_dot.  We do not include kappa_dot here, as it is strongly time-dependent and it
    would make interpolation much more difficult.  Whenever we need the collision term, we
    first interpolate it from 'ppw2->collision_quadsources_table' and, only then, include the
    kappa_dot factor. */
    
 
 
  if (ppt2->has_quadratic_collision == _TRUE_) {
     
 
 
    // *******      Shortcuts      ********
  
    // *** Metric part
 
    /* The collision term doesn't involve metric variables, because it is computed
      in the tetrad gauge frame, where Minkowski reigns.
      However, if we use conformal time, the collision term appears on the right hand
      side of Boltzmann equation divided by the photon energy in the gauge frame, P_0.
      The metric terms creep in when expressing P_0 in terms of tetrad frame variables.
      We call such contribution A.  In Newtonian gauge, A is simply the Newtonian potential,
      as can be seen in eq. A.55 of Pitrou et al. 2010 and eq. 2.18 of Beneke and Fidler
      2011. In synchronous gauge P_0 = E, where E is the tetrad frame energy, and thus
      we can set A to zero. */
      
    double A_1=0., A_2=0.;
    if(ppt->gauge == newtonian) {
      A_1 = pvec_sources1[ppt->index_qs_psi];
      A_2 = pvec_sources2[ppt->index_qs_psi];        
    }
 
 
    // *** First order collision term in k1 and k2
    double c_1=0, c_2=0;
  
      
    // *** Baryon velocity
    
    /*  Scalar part of the (irrotational) baryon velocity at first-order.
       This is related to the spherical components of the velocity by:
         v_m(k) = -k_m * v_tilde(k),
       where tilde means that the variable was computed with k aligned with the zenith. */
    double v_tilde_b_1    =   ppw2->pvec_sources1[ppt->index_qs_v_b];
    double v_tilde_b_2    =   ppw2->pvec_sources2[ppt->index_qs_v_b];
    double v_0_1 = -k1*v_tilde_b_1;
    double v_0_2 = -k2*v_tilde_b_2;
 
 
    /* Spherical components of the rotated baryon velocity. */
    double v_b_1[3] = {-ppw2->k1_M1*v_tilde_b_1, -ppw2->k1_0*v_tilde_b_1, -ppw2->k1_P1*v_tilde_b_1};
    double v_b_2[3] = {-ppw2->k2_M1*v_tilde_b_2, -ppw2->k2_0*v_tilde_b_2, -ppw2->k2_P1*v_tilde_b_2};
 
    /* Arrays must be indexed with positive integers, hence whenever we index the arrays
      v_b_1 and v_b_2 we add 1 to the azimuthal indices, which run from -1 to 1.  Here, we
      define the V_1 and V_2 shorthands to allievate the notation. */
    #define V_1(m) v_b_1[(m)+1]
    #define V_2(m) v_b_2[(m)+1]      
          
 
 
    // *******      Perturbed recombination      ********
 
    /* For the time being, we just use the approximated formula in 3.23 of
      Senatore, Tassev, Zaldarriaga (STZ, http://arxiv.org/abs/0812.3652),
      which is valid for k < 1 in Newtonian gauge.
      'delta_e' is the density contrast of free electrons, which we
      assume to be equal to 'delta_b' if perturbed recombination is not
      requested.  Otherwise, we define a 'delta_e_over_delta_b' variable
      according to the formalism used in STZ. */
    double delta_e_1=0, delta_e_2=0, xe=0, xe_dot=0;
    double delta_b_1 = pvec_sources1[ppt->index_qs_delta_b];
    double delta_b_2 = pvec_sources2[ppt->index_qs_delta_b];
    xe = pvecthermo[pth->index_th_xe];
 
    /* By default, we assume no perturbed recombination */
    double delta_e_over_delta_b = 1;
 
    // *** Compute perturbed recombination
    if (ppt->has_perturbed_recombination == _TRUE_) {
 
      xe_dot = pvecthermo[pth->index_th_dxe];
      delta_e_over_delta_b = 1. - 1/(3*Hc)*(xe_dot/xe);
    }
 
    delta_e_1 = delta_b_1 * delta_e_over_delta_b;
    delta_e_2 = delta_b_2 * delta_e_over_delta_b;     
 
  
 
    // ================================================
    // =               Photon temperature             =
    // ================================================
  
    /* We shall write down the collision term in Beneke, Fidler & Klingmuller 2011, eq. 2.18.
      This is equivalent to the collision term in Pitrou et al 2010, eq. A.55.
    
      The (l,m) quadratic collision term has two contributions:
    
    
      1)  A part that does not depend on the neighbouring multipoles, i.e. lines 3 and 4 of
          Beneke & Fidler 2011, eq. 2.17.  Such term involves the collision term at first
          order and has the form:
    
            (A_1 + delta_e_1) * collision_term_2   +   (A_2 + delta_e_2) * collision_term_1 
      
    
      2)  Several terms involving the neighbouring moments l+-1, m+-1.  We deal with these by
          defining a sum over the variable m2=-1,0,1, as in eq. 2.17 of Beneke & Fidler 2011.
  
  
      We symmetrize the quadratic terms, but we never write down the 1/2 factor that stems
      from the symmetrization.  In fact, the latter is canceled by the 2 factor that
      multiplies the quadratic part of the collision term, as in Pitrou et al. 2010,
      eq. A.55.  The 2 factor is not present in Beneke & Fidler 2011, eq. 2.17 because
      they adopt a different convention for the perturbative expansion.
  
    */
 
 
    // *** Monopole
 
    /* The monopole has a particularly simple form.  We write it down explicitely
      as it is also more stable numerically when k1=k2.
      The monopole term is tight-coupling suppressed, as it contains the difference
      between the photon and baryon velocities at first order, which are almost equal.
      This cancelation leads to a numerical instability, which could be solved by using
      the tight coupling approximation at first order, and by storing v_b - v_g in the
      ppt->quadsources array.  However, if I use the TCA at first order, I get a wierd shape
      for the shear_g at first order, and in general the whole second-order system is
      slowed down.  Hence, the best strategy so far is to just avoid the TCA at first
      order and evolve the first-order system with unsanely high precision by lowering
      the parameter tol_perturb_integration (1e-10 works perfectly, even though already
      with 1e-6 the results are good). */
 
    double v_tilde_g_1    =   ppw2->pvec_sources1[ppt->index_qs_v_g];
    double v_tilde_g_2    =   ppw2->pvec_sources2[ppt->index_qs_v_g];
    dI_qc_table(0,0) =   four_thirds * ppw2->k1_dot_k2
                              *( v_tilde_b_1*(v_tilde_g_2 - v_tilde_b_2) + v_tilde_b_2*(v_tilde_g_1 - v_tilde_b_1) );
 
    // *** All other moments
    double cacahuete=0, dipole=0, quadrupole=0, octupole=0;
    
    for (l=1; l<=l_max_g; ++l) {      
      for (m=0; m<=min(l,m_max); ++m) {
  
        /* We shall increment the quadcollision array */
        dI_qc_table(l,m) = 0;
        cacahuete=0; dipole=0; quadrupole=0; octupole=0;
        
        /* Fifth line of equation 2.18. This is the same for every l-moment.
         In the tight coupling regime, this contribution should be O(1) for l>=3
         because all first-order multipoles with l>=2 are strongly suppressed.
         The contributions to the dipole and the quadrupole are of order O(kappa_dot). */
        cacahuete = c_minus_12(l,m) * v_0_1 * I_2_tilde(l-1)   +   c_minus_21(l,m) * v_0_2 * I_1_tilde(l-1)
                  - c_plus_12(l,m)  * v_0_1 * I_2_tilde(l+1)   -   c_plus_21(l,m)  * v_0_2 * I_1_tilde(l+1);
 
        dI_qc_table(l,m) += cacahuete;          
 
      
        // *** Dipole
        if (l==1) {
  
          c_1 = 4*V_1(m) - I_1(l,m);
          c_2 = 4*V_2(m) - I_2(l,m);
          dipole += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
 
          /* The term below is different from zero only for m==0, due to the symmetries of the
            coupling factors */
          if (m==0)
            dipole += 3 * ( c_minus_12(1,m) * v_0_1 * I_2_tilde(0)  
                          + c_minus_21(1,m) * v_0_2 * I_1_tilde(0) );
            
          /* The collision term for the dipole has an extra quadratic contribution that 
            comes from the purely second-order part of the collision term, namely from:
                  kappa_dot*4*v_0_b
            We use the collision term in Beneke & Fidler, but we adopt a different
            definition of velocity. Our velocity is actually the dipole of the baryon
            distribution divided by 3, while the velocity in B&F is the fluid limit
            velocity. The twos are related by the following relation:
                  v_m(B&F) = v_m - 2*delta(k1)*v_m(k2)
            Since we are using B&F's collision term, we need to perform the substitution
                  kappa_dot*4*v_0_b(B&F)  =  kappa_dot*4*(v_m - 2*delta(k1)*v_m(k2))  ,
            which implies that we need to add to the quadratic sources an extra
                  -kappa_dot*8*delta(k1)*v_m(k2)
            that, symmetrized, yields
                  -kappa_dot*4*(delta(k1)*v_m(k2) + delta(k2)*v_m(k1)) .
            You can check that without this contribution, the tight coupling is lost. */
          dipole += -4*(delta_b_1*V_2(m) + delta_b_2*V_1(m));
 
          dI_qc_table(l,m) += dipole;
        }
  
 
  
        // *** Quadrupole
        if (l==2) {
          
          double Pi_1 = 1/10.* (I_1(2,m) - sqrt_6*E_1(2,m));
          double Pi_2 = 1/10.* (I_2(2,m) - sqrt_6*E_2(2,m));
          c_1 = - I_1(2,m) + Pi_1;
          c_2 = - I_2(2,m) + Pi_2;
          
          quadrupole += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
  
          quadrupole += c_minus_12(2,m) * v_0_1 * ( 7*v_0_2 - 0.5*I_2_tilde(1) )
                      + c_minus_21(2,m) * v_0_2 * ( 7*v_0_1 - 0.5*I_1_tilde(1) );
 
          dI_qc_table(l,m) += quadrupole;
        }
  
  
        // *** Octupole
        if (l==3) {
            
          c_1 = - I_1(l,m);
          c_2 = - I_2(l,m);
          octupole += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
            
          octupole += 0.5 * ( c_minus_12(3,m) * v_0_1 * ( I_2_tilde(2) - sqrt_6*E_2_tilde(2) )
                            + c_minus_21(3,m) * v_0_2 * ( I_1_tilde(2) - sqrt_6*E_1_tilde(2) ) );
        
          dI_qc_table(l,m) += octupole;
        }
  
  
        // *** Higher moments
        if (l>3) {
            
          c_1 = - I_1(l,m);
          c_2 = - I_2(l,m);
            
          /* Given that we already summed the cacahuete term above, we only need to add
            the part with the first-order collision term. */
          dI_qc_table(l,m) += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
        }
        
        /* Multiply the collision term by kappa_dot */
        // dI_qc_table(l,m) *= kappa_dot;
 
      } // end of for(m)
    } // end of for(l)
 
 
 
 
    // *** A note on  1/2 factors and symmetrization
    
    /*   We wrote down the collision term using the equations given in Beneke & Fidler 2011.
      They use the convention whereby the perturbative expansion of the variable X is
      X=X^0 + X^1 +  X^2, while we use X=X^0 + X^1 +  1/2*X^2.  Hence, we should include
      a 2 factor when we add the quadratic collision term to the other quadratic sources.
      However, when we symmetrized the collision term wrt k1<->k2 we did not include
      the 1/2 factor; by doing so, we already implicitely included the 2 factor, hence
      we do not need to do it now.  */
  
 
 
 
 
    // ===========================================
    // =        Photon E-mode polarization       =
    // ===========================================
 
    if (ppt2->has_polarization2 == _TRUE_) {
 
      /* We write down the collision term for E-mode polarization from eq. 2.19 of BFK 2011.
        Note that, since for E-mode polarization there is no monopole nor dipole, we fill the
        dy_quadcollision array only starting from the quadrupole (l=2). */
  
      // ** Moments with l>=2
      for (l=2; l<=l_max_pol_g; ++l) {
        for (m=0; m<=min(l,m_max); ++m) {
          
          /* We shall increment the quadcollision array */
          dE_qc_table(l,m) = 0;
          cacahuete=0; dipole=0; quadrupole=0; octupole=0;
        
          /* Fourth line of equation 2.19 */
          cacahuete = d_minus_12(l,m) * v_0_1 * E_2_tilde(l-1) + d_minus_21(l,m) * v_0_2 * E_1_tilde(l-1)
                    - d_plus_12(l,m)  * v_0_1 * E_2_tilde(l+1) - d_plus_21(l,m)  * v_0_2 * E_1_tilde(l+1);
 
          dE_qc_table(l,m) += cacahuete;          
      
          
          // *** Quadrupole
          if (l==2) {
          
            double Pi_1 = 1/10.* (I_1(2,m) - sqrt_6*E_1(2,m));
            double Pi_2 = 1/10.* (I_2(2,m) - sqrt_6*E_2(2,m));
            c_1 = - E_1(2,m) - sqrt_6*Pi_1;
            c_2 = - E_2(2,m) - sqrt_6*Pi_2;
          
            quadrupole += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
          
            quadrupole += sqrt_6/2 * ( c_minus_12(2,m) * v_0_1 * (I_2_tilde(1) - 2*v_0_2 )
                                     + c_minus_21(2,m) * v_0_2 * (I_1_tilde(1) - 2*v_0_1 ) );
      
            dE_qc_table(2,m) += quadrupole;
          }
          
          
          // *** Octupole
          if (l==3) {
            
            c_1 = - E_1(l,m);
            c_2 = - E_2(l,m);
            octupole += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
 
            octupole += - sqrt_6/2 * ( d_minus_12(3,m) * v_0_1 * ( I_2_tilde(2) - sqrt_6*E_2_tilde(2) )
                                     + d_minus_21(3,m) * v_0_2 * ( I_1_tilde(2) - sqrt_6*E_1_tilde(2) ) );
 
            dE_qc_table(3,m) += octupole;
          }
          
          
          // *** Higher moments
          if (l>3) {
            
            c_1 = - E_1(l,m);
            c_2 = - E_2(l,m);
            
            dE_qc_table(l,m) += (A_1 + delta_e_1)*c_2  +  (A_2 + delta_e_2)*c_1;
          }
      
          // *** Multiply the collision term by kappa_dot
          // dE_qc_table(l,m) *= kappa_dot;
      
        } // end of for(m)
      } // end of for(l)
      
      
 
 
      // ===========================================
      // =        Photon B-mode polarization       =
      // ===========================================
 
      /* We write down the collision term for B-mode polarization from eq. 2.20 of BFK 2011.
        Note that, since for B-mode polarization there is no monopole nor dipole, we fill the
        dy_quadcollision array only starting from the quadrupole (l=2). */
  
      // ** Moments with l>=2
      for (l=2; l<=l_max_pol_g; ++l) {      
        for (m=0; m<=min(l,m_max); ++m) {
          
          /* We shall increment the quadcollision array */
          dB_qc_table(l,m) = 0;
          cacahuete=0; quadrupole=0;
        
          /* Second line of equation 2.20 */
          cacahuete = d_zero_12(l,m) * v_0_1 * E_2_tilde(l) + d_zero_21(l,m) * v_0_2 * E_1_tilde(l);
          dB_qc_table(l,m) += cacahuete;
          
 
          // *** Quadrupole
          if (l==2) {
      
            quadrupole += - sqrt_6/5 * ( d_zero_12(2,m) * v_0_1 * (I_2_tilde(2) - sqrt_6*E_2_tilde(2))
                                       + d_zero_21(2,m) * v_0_2 * (I_1_tilde(2) - sqrt_6*E_1_tilde(2)) );
 
            dB_qc_table(2,m) += quadrupole;
          }
          
          // *** Multiply the collision term by kappa_dot
          // dB_qc_table(l,m) *= kappa_dot;
 
        } // end of for(m)
      } // end of for(l)
 
 
    } // end of if(has_polarization2)
 
 
 
 
    // =======================================
    // =                Baryons              =
    // =======================================
 
    /*  We write the collision term for the baryon monopole and dipole very simply by enforcing
      the conservation of the energy and momentum, expressed through the energy momentum tensor:
      
      d T00_b / d tau = - d T00_g / d tau
      d T0i_b / d tau = - d T0i_g / d tau        
      
      where the the time derivative accounts only for the variations due to the Thomson
      scattering, and where the right hand side is just minus the collision term of
      photons.
 
      We describe the distribution function of baryons through its expansion in beta-moments,
      which are conceptually the same as the photon multipoles.  We do so because we want to
      treat baryons and photons on the same ground.  One of the advantages of this approach
      is manifest here.  Since the first two beta-moments are just T00/rho (monopole) and
      T0i/rho (dipole), we have that the collision term for the baryons is given by the one
      from the photons times -rho_g/rho_b.
  
      Note that the smart dipole 's_11m' does not have a collision term by construction
      (see comment in perturb2_derivs).   */
 
 
    // *** Monopole
    db_qc_table(0,0,0) = - r * dI_qc_table(0,0);
 
    // *** Dipole
    if (ppt2->has_smart_dipole == _FALSE_) {  /* s_11m has no collision term */
 
      db_qc_table(1,1,0) = - r * dI_qc_table(1,0);
      if (m_max>0) db_qc_table(1,1,1) = - r * dI_qc_table(1,1);

    }
          
 
    // *** Pressure and quadrupole
    if (ppt2->has_perfect_baryons == _TRUE_) {
 
      /* We already added the collision term for the perfect baryons
        implicitely, when we included the v_prime factors in the definition of
        db_quad(2,0,0) and db_quad(2,2,m).  Hence, here we do not need to 
        add anything. */

      /* Pressure */
      db_qc_table(2,0,0) = 0;
      
      /* Quadrupole */
      for (m=0; m <= min(2,m_max); ++m)
        db_qc_table(2,2,m) = 0;

    }
    else {
 
      /* TODO: Derive baryon pressure & quadrupole collision terms!!!!
        For now, we set them to zero */

      /* Pressure */
      db_qc_table(2,0,0) = 0;

      /* Quadrupole */
      for (m=0; m <= min(2,m_max); ++m)
        db_qc_table(2,2,m) = 0;

 
    }
    
 
    // // For the n=2 beta-moments, we could choose the collision term that "kills" the
    // // quadratic sources for pressure and anisotropic stresses.  This is not needed
    // // if you already suppress them using ad hoc beta-moments 
    // c_1 = 4/3.*(v_tilde_g_1 - v_tilde_b_1);
    // c_2 = 4/3.*(v_tilde_g_2 - v_tilde_b_2);
    // db_qc_table(2,0,0) = - 2* k1_dot_k2 * r * (c_1*v_tilde_b_2 + c_2*v_tilde_b_1);
    // // db_quad(2,0,0)  += kappa_dot*db_qc_table(2,0,0);
 
  }  // end of if(has_quadratic_collision)


  return _SUCCESS_; 
        
}











/**
  * Get the sources terms from the solutions of the second-order system of equations at a fixed tau and k.
  * This function is going to be used inside the evolver to get the 2nd-order quantities as they are computed.
  * Remember that 'y' is the vector that contains the instantaneous value of the evolved perturbations,
  * i.e. those that are indexed with index_pt2
  */
int perturb2_source_terms(
              double tau,
              double * y,
              double * dy,
              int index_tau,
              void * parameters_and_workspace,
              ErrorMsg error_message
       )
{


  // *** Alleviate notation
  
  struct perturb2_parameters_and_workspace * pppaw2 = parameters_and_workspace;
  
  struct precision * ppr = pppaw2->ppr;
  struct background * pba = pppaw2->pba;
  struct thermo * pth = pppaw2->pth;
  struct perturbs * ppt = pppaw2->ppt;
  struct perturbs2 * ppt2 = pppaw2->ppt2;
  
  struct perturb2_workspace * ppw2 = pppaw2->ppw2;
  double * pvecback = ppw2->pvecback;
  double * pvecthermo = ppw2->pvecthermo;
  double * pvecmetric = ppw2->pvecmetric;
  double * pvec_metric_quadsources = ppw2->pvec_metric_quadsources;
  
  int index_k1 = ppw2->index_k1;
  int index_k2 = ppw2->index_k2;
  int index_cosk1k2 = ppw2->index_cosk1k2;
  
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  double cosk1k2 = ppw2->cosk1k2;  
  double k1_sq = k1*k1;
  double k2_sq = k2*k2;
  double k1_dot_k2 = ppw2->k1_dot_k2;
  double k = ppw2->k;
  double k_sq = ppw2->k_sq;
  double kz1 = ppw2->kz1;
  double kz2 = ppw2->kz2;
  double * k1_m = ppw2->k1_m;
  double * k2_m = ppw2->k2_m;
  int tp2_size = ppt2->tp2_size;
  int l,m;
  int m_max = ppw2->pv->m_max;
  
  
  
  
  // **********************             Interpolate needed quantities         ********************  
  
  /* Call functions that will fill pvec___ arrays with useful quantities.  Do not alter the order
    in which these functions are called, since they all rely on the quantities computed by the
    previous ones. */
         
  
  // *** Interpolate background-related quantities (pvecback)
  class_call (background_at_tau(
               pba,
               tau,
               pba->normal_info, 
               pba->inter_closeby, 
               &(ppw2->last_index_back),
               ppw2->pvecback),
    pba->error_message,
    error_message);
  
  double a = pvecback[pba->index_bg_a];
  double a_sq = a*a;
  double Hc = pvecback[pba->index_bg_H]*a;
  double Hc_sq = Hc*Hc;
  double H = pvecback[pba->index_bg_H];
  double Y = log10(a/pba->a_eq);  
  
  // *** Interpolate thermodynaics-related quantities (pvecthermo)
  class_call (thermodynamics_at_z(
               pba,
               pth,
               1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
               pth->inter_closeby,
               &(ppw2->last_index_thermo),
               ppw2->pvecback,
               ppw2->pvecthermo),
    pth->error_message,
    error_message);
  
  double r = pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_b];  
  double kappa_dot = pvecthermo[pth->index_th_dkappa];
  double exp_minus_kappa = pvecthermo[pth->index_th_exp_m_kappa];
  double g = pvecthermo[pth->index_th_g];
  
  // *** Interpolate quadratic sources
  
  /* The following functions fills
       - ppw2->pvec_metric_quadsources
       - ppw2->pvec_liouville_quadsources
       - ppw2->pvec_collision_quadsources */
  
  if (ppt2->has_quadratic_sources == _TRUE_) {
    class_call(perturb2_quadratic_sources_at_tau(
                 ppt,
                 ppt2,
                 tau,            
                 ppw2
                 ),
      ppt2->error_message,
      error_message);
  }
  
  // *** Interpolate first-order quantities (ppw2->psources_1)
  class_call(perturb_quadsources_at_tau_for_all_types(
                 ppt,
                 ppt2->index_mode,
                 ppt2->index_ic,
                 ppw2->index_k1,
                 tau,
                 ppt->inter_normal,
                 &(ppw2->last_index_sources),
                 ppw2->pvec_sources1),
             ppt->error_message,
             error_message);
  
  // *** Interpolate first-order quantities (ppw2->psources_2)  
  class_call(perturb_quadsources_at_tau_for_all_types(
                 ppt,
                 ppt2->index_mode,
                 ppt2->index_ic,
                 ppw2->index_k2,
                 tau,
                 ppt->inter_normal,
                 &(ppw2->last_index_sources),                 
                 ppw2->pvec_sources2),
             ppt->error_message,
             error_message);
  
  /* Define shorthands */
  double * pvec_sources1 = ppw2->pvec_sources1;
  double * pvec_sources2 = ppw2->pvec_sources2;
  
  // *** Interpolate Einstein equations (pvecmetric)
  class_call(perturb2_einstein(
             ppr,
             pba,
             pth,
             ppt,
             ppt2,
             tau,
             y,
             ppw2),       /* We shall store the metric variables in ppw2->pvecmetric */
         ppt2->error_message,
         error_message);
  
  
  
  // *** Shortcuts to Newtonian gauge quantities
  double phi, psi, psi_1, psi_2, phi_1, phi_2, phi_prime, psi_prime, phi_prime_1, phi_prime_2;
  
  if (ppt->gauge == newtonian) {
  
    psi = pvecmetric[ppw2->index_mt2_psi];
    phi = y[ppw2->pv->index_pt2_phi];
    phi_prime = pvecmetric[ppw2->index_mt2_phi_prime];

    psi_1 = pvec_sources1[ppt->index_qs_psi];
    psi_2 = pvec_sources2[ppt->index_qs_psi];
  
    phi_1 = pvec_sources1[ppt->index_qs_phi];
    phi_2 = pvec_sources2[ppt->index_qs_phi];
  
    phi_prime_1 = pvec_sources1[ppt->index_qs_phi_prime];
    phi_prime_2 = pvec_sources2[ppt->index_qs_phi_prime];
  }
  
  
  // /* Check against nan's */
  // char buffer[64];
  // sprintf(buffer, "%g", phi_prime);
  // if (strcmp(buffer, "nan") == 0)
  //   fprintf(stderr, "#### found NAN for index_k1=%d, index_k2=%d, index_cosk1k2=%d, index_tau=%d, index_type=%d\n",
  //     index_k1, index_k2, index_cosk1k2, index_tau, ppt2->index_tp2_t + lm(l,m));
  
  
  
  // **********    Smart dipole   **********
  
  /* We cannot rely on ppw2->pv->b_110 because it is updated only after a call of perturb_derivs */
  double b_110 = b(1,1,0), s_110=0;
  double b_111 = 0, s_111 = 0;
  if (m_max > 0) b_111 = b(1,1,1);
  
  if (ppt2->has_smart_dipole == _TRUE_) {
    s_110  = b(1,1,0);
    b_110  = s_110 - r*I(1,0);
    if (m_max > 0)  {
      s_111  = b(1,1,1);
      b_111  = s_111 - r*I(1,1);
    }
  }
  
    
    
    
  // ************************                Fill ppw2->source_term_table             ***************************
    
  /* In order to compute the sources, we may need to derive some quantities with respect to time. Doing it at this 
    stage is not possible, as this function only knows only about the perturbations at the time index_tau.

    We store the quantities that need to be derived in the array ppw2->source_term_table. We shall derive them
    after the evolution of the system ended, inside the perturb2_sources function. */
  
  ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_exp_minus_kappa] = exp_minus_kappa;
  
  
  /* Store the gravitational potentials, needed to compute the ISW line-of-sight source */
  if ((ppt2->has_source_t == _TRUE_) && (ppt2->has_integrated_sachs_wolfe_in_los == _TRUE_)) {

    ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_psi] = psi;
    ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_phi_prime] = phi_prime;
  }
  
  
  
  // ************************                Fill ppt2->sources             ***************************
    
  /* We are now going to fill ppt2->sources, the multi-array containing the line-of-sight source functions for each
    value of k1,k2,cosk1k2 and tau. This is the main product of the whole perturbations2.c module.
    
    The sources arrayt should be addressed as:
    
     ppt2->sources [index_type]
                   [index_k1]
                   [index_k2-index_k1]
                   [index_cosk1k2]
                   [index_tau]
  
     Important: Due to symmetry properties, 'index_k2' runs from 0 to ppt2->k_size - index_k1.  */


  /* We shall break down the line of sight sources in different contribution */
  double source, source_pure_scattering, source_quad_scattering, source_sachs_wolfe, source_lensing, source_quad_metric;  
  
  /* Shortcut to access the ppt2->sources array (will be undefined after ppt2->sources is filled) */
  #define sources(index_type) ppt2->sources[(index_type)][index_k1][index_k2-index_k1][index_cosk1k2][index_tau]
  
  
  
  // ================================================
  // =               Photon temperature             =
  // ================================================
  
  for(l=0; l<=ppr->l_max_t_los; ++l) {
    for(m=0; m<=min(l,m_max); ++m) {
    
      /* We split the sources for the line of sight (LOS) integration in three parts:
  
          - the lensing terms, that is the quadratic terms where a metric perturbation multiplies
            a multipole,
          - the metric terms, that is the the terms that involve metric perturbations only (only up to l=2),
          - the scattering part, that is everything that is multiplied by the interaction rate 'kappa_dot'. 
  
         The sum of the lensing and metric terms yields the Liouville operator (minus the purely second-order
        part of the free-streaming, which is on the left-hand-side of the LOS formula).  While the lensing terms
        are always quadratic in the perturbations, the metric terms can contain purely-second order metric variables
        (which come from the redshift term of the Liouville operator). This is the case for the Sachs-Wolfe (SW)
        effect and for the integrated SW effect.
        
         As the metric variables do not usually vanish after recombination, if we include them in the LOS
        integration, then we have to compute the LOS sources all the way to today.  The same applies
        to the lensing terms, with the added complication that they do not vanish for l>2.  If we want to include
        the lensing terms, we need to compute the sources up to today, for as many l's as we want to compute.
        
         The scattering part of the LOS sources is given by the multipole decomposition of the quadratic part of
        the collision term.  For the monopole, which lacks a purely second-order collision term, there is an extra
        kappa_dot*I(0,0) contribution.  The scattering part is the simplest part to treat, as it is strongly suppressed after
        recombination.  When all other sources are turned off, the sources of the LOS integration need to be computed
        only up to shortly after recombination.  Furthermore, the (l,m) contribution from the quadratic sources is
        is suppressed for l>2 multipoles by tight coupling.
        
        */

      source = 0;
      source_pure_scattering = 0;
      source_quad_scattering = 0;
      source_sachs_wolfe = 0;
      source_lensing = 0;
      source_quad_metric = 0;

  
      // *** Monopole source
  
      if (l==0) {
  
        /* Since the monopole doesn't have a purely second-order collision term, we have to include a
          kappa_dot*I_00 term to compensate the same term present in the line of sight formula. This
          term does should always be present. */
        // source = kappa_dot * I(0,0);
      
        /* Compute the Sachs-Wolfe effect, but do not add it yet */
        source_sachs_wolfe = 4 * kappa_dot * psi;
        
        /* If you want not to split the SW from the ISW, comment the above line, uncomment the below one
          and disable the ISW from the parameter file. The comparison with the split case is possible
          only when integrating up to today, otherwise the surface term in the integration by parts will
          change all angular scales. */
        // source_sachs_wolfe = 4 * phi_prime;
        
        /* Compute the quadratic Liouville contribution to the metric sources, but do not add it yet */
        source_quad_metric = 8*(phi_1*phi_prime_2 + phi_2*phi_prime_1);        
        
      }
  
  
  
      // *** Dipole source
  
      if (l==1) {
  
        /* Compute purely second-order scattering, but do not add it yet */
        if (m == 0) source_pure_scattering = 4/3. * kappa_dot * b_110;
        if (m == 1) source_pure_scattering = 4/3. * kappa_dot * b_111;
  
        /* Compute the quadratic Liouville contribution to the metric sources, but do not add it yet */
        source_quad_metric = - 4 * ( k1_m[m+1]*psi_1*(psi_2-phi_2) + k2_m[m+1]*psi_2*(psi_1-phi_1) );

        /* If you want not to split the SW from the ISW, uncomment the below line and disable the
          ISW from the parameter file */
        // if (m==0) source_sachs_wolfe = 4 * k * psi;
 
      }
  
  
      // *** Quadrupole source
  
      if (l==2) {
  
        /* Compute purely second-order scattering, but do not add it yet */
        double Pi = 1/10.* ( I(2,m) - sqrt_6*E(2,m) );
        source_pure_scattering = kappa_dot * Pi;
      }
  
  
      // *** Contributions valid for all multipoles

      /* Scattering from purely second-order sources */
      if (ppt2->has_pure_scattering_in_los == _TRUE_)
        source += source_pure_scattering;

      /* Scattering from quadratic sources of the form multipole times baryon_velocity */
      source_quad_scattering = kappa_dot*dI_qc(l,m);
      if (ppt2->has_quad_scattering_in_los == _TRUE_)
        source += source_quad_scattering;

      /* Sachs-Wolfe effect. Note that we shall compute the integrated SW in perturb2_sources, as to do so
        we need the time derivative of psi. */
      if (ppt2->has_sachs_wolfe_in_los == _TRUE_)
        source += source_sachs_wolfe;

      /* Lensing from quadratic sources of the form multipole times metric */
      source_lensing = dI_ql(l,m) - source_quad_metric;
      if (ppt2->has_lensing_in_los == _TRUE_)
        source += source_lensing;

      /* Lensing from quadratic sources of the form metric times metric */
      if (ppt2->has_quad_metric_in_los == _TRUE_)
        source += source_quad_metric;

      /* All the sources in the line of sight integration are multiplied by exp(-kappa(tau,tau0)),
        which is extremely small before recombination. */
      source *= exp_minus_kappa;
  
      /* Fill the ppt2->sources array, and assign the labels */
      sources(ppt2->index_tp2_t + lm(l,m)) = source;      
      if (index_tau==0) sprintf(ppt2->tp2_labels[ppt2->index_tp2_t + lm(l,m)], "T_%d_%d", l, m);
      #pragma omp atomic
      ++ppt2->count_memorized_sources;
  
    }  // end for(m)
  } // end for(l)

  #undef sources
  
  /* Some debug */
  // printf("ppt2->count_memorized_sources = %d\n", ppt2->count_memorized_sources);
  
  return _SUCCESS_;

}








int perturb2_sources(
  struct perturbs2 * ppt2,
  struct perturb2_workspace * ppw2)
{


  int index_tau;
    
  /* Shortcut to access the ppt2->sources array (will be undefined after ppt2->sources is filled) */
  #define sources(index_type) ppt2->sources[(index_type)][ppw2->index_k1][ppw2->index_k2-ppw2->index_k1][ppw2->index_cosk1k2][index_tau]    
      

      
  /* Take the derivative of the graviational potential psi in order to compute the integrated Sachs-Wolfe effect */
  if ( (ppt2->has_source_t) && (ppt2->has_integrated_sachs_wolfe_in_los == _TRUE_) ) {
    
    class_call( array_derive1_order2_table_line_to_line (
                  ppt2->tau_sampling,
                  ppt2->tau_size,
                  ppw2->source_term_table,
                  ppw2->st2_size,
                  ppw2->index_st2_psi,
                  ppw2->index_st2_psi_prime,
                  ppt2->error_message),
      ppt2->error_message,
      ppt2->error_message);

    /* Add the ISW contribution to the S00 source function for the temperature */    
    for (index_tau=0; index_tau < ppt2->tau_size-1; ++index_tau) {

      /* Opacity factor */
      double exp_minus_kappa = ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_exp_minus_kappa];

      /* Potentials derivatives */
      double psi_prime = ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_psi_prime];
      double phi_prime = ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_phi_prime];

      /* ISW contribution */
      sources(ppt2->index_tp2_t + lm(0,0)) += 4*exp_minus_kappa*(psi_prime + phi_prime);

      /* Some debug of the ISW effect */
      // if ( (ppw2->index_k1==0) && (ppw2->index_k2==1) && (ppw2->index_cosk1k2==25)) {
      //   double tau = ppt2->tau_sampling[index_tau];
      //   double psi = ppw2->source_term_table[index_tau*ppw2->st2_size + ppw2->index_st2_psi];
      //   fprintf (stderr, "%20f %20f %20f %20f %20f %20f\n", tau, 4*exp_minus_kappa*(psi_prime + phi_prime), psi, psi_prime, phi_prime, exp_minus_kappa);
      // }

    } // end of for(index_tau)

  } // end of if(has_ISW)


  #undef sources  
    
  return _SUCCESS_;   
    
}













int perturb2_print_variables(double tau,
          double * y,
          double * dy,
          int index_tau,          
          void * parameters_and_workspace,
          ErrorMsg error_message
          )
{
  
  
  /* Define shortcuts to avoid heavy notations */
  struct perturb2_parameters_and_workspace * pppaw2 = parameters_and_workspace;
  struct precision * ppr = pppaw2->ppr;
  struct background * pba = pppaw2->pba;
  struct thermo * pth = pppaw2->pth;
  struct perturbs * ppt = pppaw2->ppt;
  struct perturbs2 * ppt2 = pppaw2->ppt2;  
  struct perturb2_workspace * ppw2 = pppaw2->ppw2;
  double k1 = ppt2->k[ppw2->index_k1];  
  double k2 = ppt2->k[ppw2->index_k2];
  double * pvecback = ppw2->pvecback;
  double * pvecthermo = ppw2->pvecthermo;
  double * pvecmetric = ppw2->pvecmetric;


  if (ppw2->index_k1==0) {

      fprintf(stdout,"%e   %e   %e   %e  ",
        k1,
        k2,
        tau,
        pvecmetric[ppw2->index_mt2_psi]
      );

      fprintf(stdout,"\n");
  }
  
  return _SUCCESS_;

}





int what_if_ndf15_fails(int (*derivs)(double x, 
          double * y, 
          double * dy, 
          void * parameters_and_workspace,
          ErrorMsg error_message),
        double x_ini,
        double x_end,
        double * y, 
        int * used_in_output,
        int y_size,
        void * parameters_and_workspace_for_derivs,
        double tolerance, 
        double minimum_variation,
        int (*evaluate_timescale)(double x, 
          void * parameters_and_workspace,
          double * timescale,
          ErrorMsg error_message),
        double timestep_over_timescale,
        double * x_sampling,
        int x_size,
        int (*output)(double x,
          double y[],
          double dy[],
          int index_x,
          void * parameters_and_workspace,
          ErrorMsg error_message),
        int (*print_variables)(double x,
             double y[], 
             double dy[],
             void * parameters_and_workspace,
             ErrorMsg error_message),
        ErrorMsg error_message)
{
          
  
  // *** Alleviate notation
  
  struct perturb2_parameters_and_workspace * pppaw2 = parameters_and_workspace_for_derivs;
  struct perturbs2 * ppt2 = pppaw2->ppt2;
  struct perturb2_workspace * ppw2 = pppaw2->ppw2;
  
  int index_k1 = ppw2->index_k1;
  int index_k2 = ppw2->index_k2;
  int index_cosk1k2 = ppw2->index_cosk1k2;
  
  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  double cosk1k2 = ppw2->cosk1k2;  
  double k = ppw2->k;
          
  if (ppt2->perturbations2_verbose > 1) {
    printf("    * error in ndf15: '%s'\n", error_message);
    printf("    * recomputing mode (k1,k2,mu) = (%.17f,%.17f,%.17f) = (%d,%d,%d) using Runge-Kutta method\n",
      k1, k2, cosk1k2, index_k1, index_k2, index_cosk1k2);
    fflush(stdout);
  }
    
  /* We pass to the Runge-Kutta evolver the same arguments that were passed to the ndf15 one.  Note however that rk
    relies on the function timescale_and_approximation while ndf15 does not, so make sure that it points
    to a valid function. In principle we could also pass an exit_strategy function to evolver_rk (e.g. what_if_rk_fails). */
  class_call (evolver_rk (
                  derivs,
                  x_ini,
                  x_end,
                  y, 
                  used_in_output,
                  y_size, 
                  parameters_and_workspace_for_derivs,
                  tolerance, 
                  minimum_variation, 
                  evaluate_timescale,
                  timestep_over_timescale, 
                  x_sampling, 
                  x_size,
                  output,
                  print_variables,
                  NULL,
                  error_message),
    error_message,
    error_message);


          
  return _SUCCESS_;
          
};












/**
 * This is the point where you can output the second-order transfer functions, or any other quantity you
 * are interested into.  This function is called from within the evolver at the times sampled in
 * ppt2->tau_sampling.
*/
int perturb2_save_early_transfers(
          double tau,
          double * y,
          double * dy,
          int index_tau,
          void * parameters_and_workspace,
          ErrorMsg error_message
          )
{
  
  // *** Alleviate notation

  struct perturb2_parameters_and_workspace * pppaw2 = parameters_and_workspace;
  
  struct precision * ppr = pppaw2->ppr;
  struct background * pba = pppaw2->pba;
  struct thermo * pth = pppaw2->pth;
  struct perturbs * ppt = pppaw2->ppt;
  struct perturbs2 * ppt2 = pppaw2->ppt2;
  
  struct perturb2_workspace * ppw2 = pppaw2->ppw2;
  double * pvecback = ppw2->pvecback;
  double * pvecthermo = ppw2->pvecthermo;
  double * pvecmetric = ppw2->pvecmetric;
  double * pvec_metric_quadsources = ppw2->pvec_metric_quadsources;
    
  int index_k1 = ppw2->index_k1;
  int index_k2 = ppw2->index_k2;
  int index_cosk1k2 = ppw2->index_cosk1k2;

  double k1 = ppw2->k1;
  double k2 = ppw2->k2;
  double cosk1k2 = ppw2->cosk1k2;  
  double k1_sq = k1*k1;
  double k2_sq = k2*k2;
  double k1_dot_k2 = ppw2->k1_dot_k2;
  double k = ppw2->k;
  double k_sq = ppw2->k_sq;
  double kz1 = ppw2->kz1;
  double kz2 = ppw2->kz2;  
  double k1_0 = ppw2->k1_0;
  double k2_0 = ppw2->k2_0;
  int tp2_size = ppt2->tp2_size;
  int l,m;
  int m_max = ppw2->pv->m_max;




  // **********************             Interpolate needed quantities         ********************  

  /* Call functions that will fill pvec___ arrays with useful quantities.  Do not alter the order
    in which these functions are called, since they all rely on the quantities computed by the
    previous ones.  */
         

  // *** Interpolate background-related quantities (pvecback)
  class_call (background_at_tau(
               pba,
               tau,
               pba->long_info, 
               pba->inter_closeby, 
               &(ppw2->last_index_back),
               ppw2->pvecback),
    pba->error_message,
    error_message);

  double a = pvecback[pba->index_bg_a];
  double a_sq = a*a;
  double Hc = pvecback[pba->index_bg_H]*a;
  double Hc_sq = Hc*Hc;
  double H = pvecback[pba->index_bg_H];
  double Y = log10(a/pba->a_eq);  
  double Omega_m = ppw2->pvecback[pba->index_bg_Omega_m];
  double Omega_r = ppw2->pvecback[pba->index_bg_Omega_r];

  // *** Interpolate thermodynaics-related quantities (pvecthermo)
  class_call (thermodynamics_at_z(
               pba,
               pth,
               1./pvecback[pba->index_bg_a]-1.,  /* redshift z=1/a-1 */
               pth->inter_closeby,
               &(ppw2->last_index_thermo),
               ppw2->pvecback,
               ppw2->pvecthermo),
    pth->error_message,
    error_message);

  /* Interaction rate */
  double kappa_dot = pvecthermo[pth->index_th_dkappa];
  
  /* Photon to baryon ratio */
  double r = pvecback[pba->index_bg_rho_g]/pvecback[pba->index_bg_rho_b];  


  // *** Interpolate quadratic sources

  /* The following functions fills
       - ppw2->pvec_metric_quadsources
       - ppw2->pvec_liouville_quadsources
       - ppw2->pvec_collision_quadsources */

  if (ppt2->has_quadratic_sources == _TRUE_) {
    class_call(perturb2_quadratic_sources_at_tau(
                 ppt,
                 ppt2,
                 tau,            
                 ppw2
                 ),
      ppt2->error_message,
      error_message);
  }


  // *** Interpolate first-order quantities (ppw2->psources_1)
  class_call(perturb_quadsources_at_tau_for_all_types(
               ppt,
               ppt2->index_mode,
               ppt2->index_ic,
               ppw2->index_k1,
               tau,
               ppt->inter_normal,
               &(ppw2->last_index_sources),
               ppw2->pvec_sources1),
     ppt->error_message,
     ppt2->error_message);

  // *** Interpolate first-order quantities (ppw2->psources_2)  
  class_call(perturb_quadsources_at_tau_for_all_types(
               ppt,
               ppt2->index_mode,
               ppt2->index_ic,
               ppw2->index_k2,
               tau,
               ppt->inter_normal,
               &(ppw2->last_index_sources),                 
               ppw2->pvec_sources2),
    ppt->error_message,
    ppt2->error_message);

  /* Define shorthands */
  double * pvec_sources1 = ppw2->pvec_sources1;
  double * pvec_sources2 = ppw2->pvec_sources2;
  

  // *** Interpolate Einstein equations (pvecmetric)
  class_call (perturb2_einstein(
                ppr,
                pba,
                pth,
                ppt,
                ppt2,
                tau,
                y,
                ppw2),       /* We shall store the metric variables in ppw2->pvecmetric */
    ppt2->error_message,
    error_message);

 

  
  // ***********************            Gauge specific quantities         ******************


  // =================================
  // =        Newtonian Gauge        =
  // =================================
  double phi, psi;

  if (ppt->gauge == newtonian) {
    
    psi = pvecmetric[ppw2->index_mt2_psi];
    phi = y[ppw2->pv->index_pt2_phi]; 
  }
  

  
  // =====================================
  // =          Synchronous Gauge        =
  // =====================================
  double alpha_prime, h_prime_prime, eta_prime_prime, h;

  if (ppt->gauge == synchronous) {
  
    // /* alpha' = (h''+ 6 eta'')/2k^2 */
    // alpha_prime = pvecmetric[ppw2->index_mt2_alpha_prime];
    //   
    // /* h'' */
    // h_prime_prime = pvecmetric[ppw2->index_mt2_h_prime_prime];
    //   
    // /* eta'' = 1./6. * (2 k^2 alpha' - h'') */
    // // TODO:  Include the quadratic terms for eta_prime_prime
    // eta_prime_prime = 1./6. * (2.*k_sq*alpha_prime - h_prime_prime);
    // 
    // // TODO:  Include the quadratic terms of the continuity equation
    // h = -2. * delta_cdm;     
    //   
    // /* Synchronous to Netwonian gauge transformation for the potentials */
    // // TODO:  Include the quadratic terms of the gauge transformation
    // psi = (a * H * (pvecmetric[ppw2->index_mt2_h_prime] + 6. * pvecmetric[ppw2->index_mt2_eta_prime])/2./k_sq + alpha_prime);  
    // phi = y[ppw2->pv->index_pt2_eta]-a*H/2./k_sq*(pvecmetric[ppw2->index_mt2_h_prime] + 6. * pvecmetric[ppw2->index_mt2_eta_prime]);
  }
  



  // ********************           Smart dipole         **********************

  /* We cannot rely on ppw2->pv->b_110 because it is updated only after a call of perturb_derivs. */
  double b_110 = b(1,1,0), s_110=0;
  double b_111 = 0, s_111 = 0;
  if (m_max > 0) b_111 = b(1,1,1);
  
  if (ppt2->has_smart_dipole == _TRUE_) {
    s_110  = b(1,1,0);
    b_110  = s_110 - r*I(1,0);
    if (m_max > 0)  {
      s_111  = b(1,1,1);
      b_111  = s_111 - r*I(1,1);
    }
  }


  // *********************            Define fluid limit variables              ****************
  
  /* We use the following relations to convert multipoles in fluid variables:
        000 = delta               -    2 (w+1) v^i * v_i
        11m = 3 (w+1) v[m]        +    6 (1+cs^2) delta*v[m]
        200 = 3  pressure/rho     -    2 (w+1) v^i * v_i
        22m = -15/2 sigma[m]/rho  -   15 (w+1) X[m]^ij v^i * v_j
    where X[m]^ij is the matrix that represents the n^i*n^j in multipole space  */
  
  // *** Shortcuts
  double delta_g=0, pressure_g=0, v_0_g=0, sigma_0_g=0, delta_g_adiab=0;
  double delta_g_1=0, delta_g_2=0, v_g_1=0, v_g_2=0;
  double delta_b=0, pressure_b=0, v_0_b=0, sigma_0_b=0;
  double delta_b_1=0, delta_b_2=0, v_b_1=0, v_b_2=0;  
  double delta_cdm=0, pressure_cdm=0, v_0_cdm=0, sigma_0_cdm=0;  
  double delta_cdm_1=0, delta_cdm_2=0, v_cdm_1=0, v_cdm_2=0;
  double delta_ur=0, pressure_ur=0, v_0_ur=0, sigma_0_ur=0;  
  double delta_ur_1=0, delta_ur_2=0, v_ur_1=0, v_ur_2=0;
  
  /* This is the tensor product between k1 and k2, that is X[0]^ij k1_i k2_j */
  double * k1_ten_k2 = ppw2->k1_ten_k2;


  // *** Photons fluid variables
  delta_g_1 = pvec_sources1[ppt->index_qs_delta_g];
  delta_g_2 = pvec_sources2[ppt->index_qs_delta_g];
  v_g_1 = ppw2->pvec_sources1[ppt->index_qs_v_g];
  v_g_2 = ppw2->pvec_sources2[ppt->index_qs_v_g];

  delta_g = I(0,0) + 8/3.*k1_dot_k2*v_g_1*v_g_2;
  pressure_g = 1/3. * ( I(0,0) + 8/3.*k1_dot_k2*v_g_1*v_g_2  );
  m=0;
  v_0_g = I(1,0)/4. - delta_g_1*(-k2_0*v_g_2) - delta_g_2*(-k1_0*v_g_1);
  sigma_0_g = -2/15.*I(2,0) + 8/3.*k1_ten_k2[m+2]*v_g_1*v_g_2;

    /* 'delta_g_adiab' is supposed to be equal to delta_b/3 during tight coupling. */
  delta_g_adiab = I(0,0)/4. - delta_g_1*delta_g_2/16.;


  // *** Baryon fluid variables
  delta_b_1 = pvec_sources1[ppt->index_qs_delta_b];
  delta_b_2 = pvec_sources2[ppt->index_qs_delta_b];
  v_b_1 = ppw2->pvec_sources1[ppt->index_qs_v_b];
  v_b_2 = ppw2->pvec_sources2[ppt->index_qs_v_b];

  delta_b = b(0,0,0) + 2*k1_dot_k2*v_b_1*v_b_2;
  pressure_b = 1/3. * ( b(2,0,0) + 2*k1_dot_k2*v_b_1*v_b_2  );
  m=0;
  v_0_b = b_110/3. - delta_b_1*(-k2_0*v_b_2) - delta_b_2*(-k1_0*v_b_1);
  sigma_0_b = -2/15.*b(2,2,0) + 2*k1_ten_k2[m+2]*v_b_1*v_b_2;
    
  // *** Cold dark matter fluid variables
  if (pba->has_cdm == _TRUE_) {

    delta_cdm_1 = pvec_sources1[ppt->index_qs_delta_cdm];
    delta_cdm_2 = pvec_sources2[ppt->index_qs_delta_cdm];  

    if(ppt->gauge != synchronous) {
      v_cdm_1 = ppw2->pvec_sources1[ppt->index_qs_v_cdm];
      v_cdm_2 = ppw2->pvec_sources2[ppt->index_qs_v_cdm];
    }

    delta_cdm = cdm(0,0,0) + 2*k1_dot_k2*v_cdm_1*v_cdm_2;
    pressure_cdm = 1/3. * ( cdm(2,0,0) + 2*k1_dot_k2*v_cdm_1*v_cdm_2  );
    m=0;
    if(ppt->gauge != synchronous)
      v_0_cdm = cdm(1,1,0)/3.  - delta_cdm_1*(-k2_0*v_cdm_2) - delta_cdm_2*(-k1_0*v_cdm_1);
    sigma_0_cdm = -2/15.*cdm(2,2,0) + 2*k1_ten_k2[m+2]*v_cdm_1*v_cdm_2;
    
  }


  // *** Neutrino fluid variables
  if (pba->has_ur == _TRUE_) {

    delta_ur_1 = pvec_sources1[ppt->index_qs_delta_ur];
    delta_ur_2 = pvec_sources2[ppt->index_qs_delta_ur];
    v_ur_1 = ppw2->pvec_sources1[ppt->index_qs_v_ur];
    v_ur_2 = ppw2->pvec_sources2[ppt->index_qs_v_ur];

    delta_ur = N(0,0) + 8/3.*k1_dot_k2*v_ur_1*v_ur_2;
    pressure_ur = 1/3. * ( N(0,0) + 8/3.*k1_dot_k2*v_ur_1*v_ur_2  );
    m=0;
    v_0_ur = N(1,0)/4.  - delta_ur_1*(-k2_0*v_ur_2) - delta_ur_2*(-k1_0*v_ur_1);
    sigma_0_ur = -2/15.*N(2,0) + 8/3.*k1_ten_k2[m+2]*v_ur_1*v_ur_2;
  }
  

  // *************             Analytical limits            **************

  double psi_1, psi_2, kernel_delta, kernel_theta, kernel_psi;
  double delta_cdm_analytical, theta_cdm_analytical, v_0_cdm_analytical, psi_analytical;

  /*  We are taking the delta and theta equations from eq. 45-46 of Bernardeau et al. 2002.
   The 2 factors come from the fact that we expand X = X0 + X1 + 1/2*X2.
   The formula relative to psi comes from eq. 6 of Pitrou et al. 2008.  Note that we
   are adding a minus sign to match our potential. */
  kernel_delta = 5/7. + 0.5*cosk1k2*(k1/k2+k2/k1) + 2/7.*cosk1k2*cosk1k2;
  delta_cdm_analytical = 2*kernel_delta*delta_cdm_1*delta_cdm_2;
  
  kernel_theta = 3/7. + 0.5*cosk1k2*(k1/k2+k2/k1) + 4/7.*cosk1k2*cosk1k2;
  theta_cdm_analytical = 2*kernel_theta*delta_cdm_1*delta_cdm_2;
  v_0_cdm_analytical   = theta_cdm_analytical/k;
  
  psi_1 = pvec_sources1[ppt->index_qs_psi];
  psi_2 = pvec_sources2[ppt->index_qs_psi];
  kernel_psi = k1_sq*k2_sq/(3/2.*Hc_sq*k_sq)*
    (5/7. + 0.5*k1_dot_k2/k1_sq + 0.5*k1_dot_k2/k2_sq + 2/7. *cosk1k2*cosk1k2);
  psi_analytical = -2*kernel_psi*psi_1*psi_2;


  /* Photon quadrupole at early times in tight-coupling (equivalent of eq. C.6 of P2010) */
  double I_2_0_analytical = 5/8. * (c_minus_12(2,0) * I_1_tilde(1) * I_2_tilde(1) +
                                    c_minus_21(2,0) * I_2_tilde(1) * I_1_tilde(1) );
  
  /* Adiabatic velocity at early times (see perturb2_initial_conditions for details) */
  double L_quad = ppw2->pvec_metric_quadsources[ppw2->index_mt2_phi_prime_longitudinal];
  double v_0_adiabatic = 2*(k/Hc)*(psi - L_quad/Hc)
                       - (-k1_0*v_cdm_1)*(3*Omega_m*delta_cdm_2 + 4*Omega_r*delta_g_2)
                       - (-k2_0*v_cdm_2)*(3*Omega_m*delta_cdm_1 + 4*Omega_r*delta_g_1);

  v_0_adiabatic *= 1/(3*Omega_m + 4*Omega_r);


  /* Some debug */
  // if(index_tau==0) {
  // 
  //   printf("\nDENTRO SAVE EARLY TRANSFERS\n");
  //   printf("tau = %g, y = %g\n", tau, Y);
  //   printf("v_0_adiabatic = %g\n", v_0_adiabatic);
  //   printf("psi = %g\n", psi);
  //   printf("Hc = %g\n", Hc);
  //   printf("k = %g\n", k);
  //   printf("L_quad = %g\n", L_quad);
  //   printf("v_cdm_1 = %g\n", v_cdm_1);
  //   printf("(3*Omega_m*delta_b_2 + 4*Omega_r*delta_g_2) = %g\n", (3*Omega_m*delta_b_2 + 4*Omega_r*delta_g_2));
  // }                      


  // ************************                Print to file             ***************************

  // *** Variables related to the files

  /* Shortcut to the file where we shall print the transfer functions. */
  FILE * file_tr = ppt2->transfers_file;
  int index_print_tr = 1;

  /* Shortcut to the file where we shall print all the quadratic sources */
  FILE * file_qs = ppt2->quadsources_file;    
  int index_print_qs = 1;

  /* Shortcut to the file where we shall print the quadratic part of the Liouville operator */
  FILE * file_ql = ppt2->quadliouville_file;
  int index_print_ql = 1;

  /* Shortcut to the file where we shall print the quadratic part of the collision term */
  FILE * file_qc = ppt2->quadcollision_file;
  int index_print_qc = 1;

  /* Choose how label & values should be formatted */
  char format_label[64] = "%11s(%02d) ";
  char format_value[64] = "%+15e ";      
  char buffer[64];

  
  // *** Print some info to file
  if ( (index_tau==0) && (ppt2->perturbations2_verbose > 0) ) {
    fprintf(file_tr, "%s", ppw2->info);
    fprintf(file_qs, "%s", ppw2->info);
    fprintf(file_ql, "%s", ppw2->info);
    fprintf(file_qc, "%s", ppw2->info);
  }
  
  // *** Time variables
  // conformal time
  if (index_tau==0) {
    fprintf(file_tr, format_label, "tau", index_print_tr++);
    fprintf(file_qs, format_label, "tau", index_print_qs++);
    fprintf(file_ql, format_label, "tau", index_print_ql++);
    fprintf(file_qc, format_label, "tau", index_print_qc++);
  }
  else {
    fprintf(file_tr, format_value, tau);
    fprintf(file_qs, format_value, tau);
    fprintf(file_ql, format_value, tau);
    fprintf(file_qc, format_value, tau);
  }
  // scale factor
  if (index_tau==0) {
    fprintf(file_tr, format_label, "a", index_print_tr++);
    fprintf(file_qs, format_label, "a", index_print_qs++);
    fprintf(file_ql, format_label, "a", index_print_ql++);
    fprintf(file_qc, format_label, "a", index_print_qc++);
  }
  else {
    fprintf(file_tr, format_value, a);
    fprintf(file_qs, format_value, a);
    fprintf(file_ql, format_value, a);
    fprintf(file_qc, format_value, a);
  }
  // y = log10(a/a_eq)
  if (index_tau==0) {
    fprintf(file_tr, format_label, "y", index_print_tr++);
    fprintf(file_qs, format_label, "y", index_print_qs++);
    fprintf(file_ql, format_label, "y", index_print_ql++);
    fprintf(file_qc, format_label, "y", index_print_qc++);
  }
  else {
    fprintf(file_tr, format_value, Y);
    fprintf(file_qs, format_value, Y);
    fprintf(file_ql, format_value, Y);
    fprintf(file_qc, format_value, Y);
  }

  // *** Newtonian gauge metric variables  
  if (ppt->gauge == newtonian) {    
    // psi
    if (index_tau==0) {
     fprintf(file_tr, format_label, "psi", index_print_tr++);
     fprintf(file_qs, format_label, "psi", index_print_qs++);
    }
    else {
     fprintf(file_tr, format_value, psi);
     fprintf(file_qs, format_value, pvec_metric_quadsources[ppw2->index_mt2_psi]);
    }
    // phi
    if (index_tau==0) fprintf(file_tr, format_label, "phi", index_print_tr++);
    else fprintf(file_tr, format_value, phi);
    // phi_prime_poisson
    if (index_tau==0) {
     fprintf(file_tr, format_label, "phi'tt", index_print_tr++);
     fprintf(file_qs, format_label, "phi'tt", index_print_qs++);
    }
    else {
     fprintf(file_tr, format_value, pvecmetric[ppw2->index_mt2_phi_prime_poisson]);
     fprintf(file_qs, format_value, pvec_metric_quadsources[ppw2->index_mt2_phi_prime_poisson]);
    }
    // phi_prime_longitudinal
    if (index_tau==0) {
     fprintf(file_tr, format_label, "phi'lg", index_print_tr++);
     fprintf(file_qs, format_label, "phi'lg", index_print_qs++);
    }
    else {
     fprintf(file_tr, format_value, pvecmetric[ppw2->index_mt2_phi_prime_longitudinal]);
     fprintf(file_qs, format_value, pvec_metric_quadsources[ppw2->index_mt2_phi_prime_longitudinal]);
    }
  }
  
  
  // *** Analytical limits
  if (pba->has_cdm == _TRUE_ ) {    

    // delta_cdm_analytical
    if (index_tau==0) fprintf(file_tr, format_label, "deltacdm_an", index_print_tr++);
    else fprintf(file_tr, format_value, delta_cdm_analytical);
    // v_0_cdm_analytical
    if (index_tau==0) fprintf(file_tr, format_label, "v_0_cdm_an", index_print_tr++);
    else fprintf(file_tr, format_value, v_0_cdm_analytical);
    // psi_analytical
    if (index_tau==0) fprintf(file_tr, format_label, "psi_an", index_print_tr++);
    else fprintf(file_tr, format_value, psi_analytical);
  }
  
  
  
  // *** Initial conditions


  // I_2_0_analytical
  if (index_tau==0) fprintf(file_tr, format_label, "I_2_0_an", index_print_tr++);
  else fprintf(file_tr, format_value, I_2_0_analytical);

  // Adiabatic velocity
  if (index_tau==0) fprintf(file_tr, format_label, "v_0_adiab", index_print_tr++);
  else fprintf(file_tr, format_value, v_0_adiabatic);
  
  
  
  
  
  // *** Baryon fluid limit variables
  // delta_b
  if (index_tau==0)  fprintf(file_tr, format_label, "delta_b", index_print_tr++);
  else fprintf(file_tr, format_value, delta_b);
  // pressure_b 
  if (index_tau==0)  fprintf(file_tr, format_label, "pressure_b", index_print_tr++);
  else fprintf(file_tr, format_value, pressure_b);
  // v_0_b 
  if (index_tau==0) fprintf(file_tr, format_label, "v_0_b", index_print_tr++);
  else fprintf(file_tr, format_value, v_0_b);
  // sigma_0_b 
  if (index_tau==0)  fprintf(file_tr, format_label, "sigma_0_b", index_print_tr++);
  else fprintf(file_tr, format_value, sigma_0_b);
  
  
  // *** CDM fluid limit variables
  if (pba->has_cdm == _TRUE_ ) {
    // delta_cdm
    if (index_tau==0)  fprintf(file_tr, format_label, "delta_cdm", index_print_tr++);
    else fprintf(file_tr, format_value, delta_cdm);
    // pressure_cdm 
    if (index_tau==0) fprintf(file_tr, format_label, "pressur_cdm", index_print_tr++);
    else fprintf(file_tr, format_value, pressure_cdm);
    // v_0_cdm 
    if (index_tau==0) fprintf(file_tr, format_label, "v_0_cdm", index_print_tr++);
    else fprintf(file_tr, format_value, v_0_cdm);
    // sigma_0_cdm 
    if (index_tau==0) fprintf(file_tr, format_label, "sigma_0_cdm", index_print_tr++);
    else fprintf(file_tr, format_value, sigma_0_cdm);
  }
   
  // *** Photon fluid limit variables
  // delta_g_adiab
  if (index_tau==0) fprintf(file_tr, format_label, "delta_g_ad", index_print_tr++);
  else fprintf(file_tr, format_value, delta_g_adiab);
  // delta_g
  if (index_tau==0)  fprintf(file_tr, format_label, "delta_g", index_print_tr++);
  else fprintf(file_tr, format_value, delta_g);
  // pressure_g 
  if (index_tau==0) fprintf(file_tr, format_label, "pressure_g", index_print_tr++);
  else fprintf(file_tr, format_value, pressure_g);
  // v_0_g
  if (index_tau==0) fprintf(file_tr, format_label, "v_0_g", index_print_tr++);
  else fprintf(file_tr, format_value, v_0_g);
  // sigma_0_g 
  if (index_tau==0) fprintf(file_tr, format_label, "sigma_0_g", index_print_tr++);
  else fprintf(file_tr, format_value, sigma_0_g);
  
  
  // *** Neutrino fluid limit variables
  if (pba->has_ur == _TRUE_) {
    // delta_ur
    if (index_tau==0) fprintf(file_tr, format_label, "delta_ur", index_print_tr++);
    else fprintf(file_tr, format_value, delta_ur);
    // pressure_ur 
    if (index_tau==0) fprintf(file_tr, format_label, "pressure_ur", index_print_tr++);
    else fprintf(file_tr, format_value, pressure_ur);
    // v_0_ur
    if (index_tau==0) fprintf(file_tr, format_label, "v_0_ur", index_print_tr++);
    else fprintf(file_tr, format_value, v_0_ur);
    // sigma_0_ur 
    if (index_tau==0) fprintf(file_tr, format_label, "sigma_0_ur", index_print_tr++);
    else fprintf(file_tr, format_value, sigma_0_ur);
  }
  
    
  // *** Baryon evolved variables
  // b 000
  if (index_tau==0) {
   fprintf(file_tr, format_label, "b_0_0_0", index_print_tr++);
   fprintf(file_qs, format_label, "b_0_0_0", index_print_qs++);
   fprintf(file_ql, format_label, "b_0_0_0", index_print_ql++);
   fprintf(file_qc, format_label, "b_0_0_0", index_print_qc++);
  }
  else {
   fprintf(file_tr, format_value, b(0,0,0));
   fprintf(file_qs, format_value, db_quad(0,0,0));
   fprintf(file_ql, format_value, db_ql(0,0,0));
   fprintf(file_qc, format_value, kappa_dot*db_qc(0,0,0));
  }
  // b 110
  if (index_tau==0) {
   fprintf(file_tr, format_label, "b_1_1_0", index_print_tr++);
   fprintf(file_qs, format_label, "b_1_1_0", index_print_qs++);
   fprintf(file_ql, format_label, "b_1_1_0", index_print_ql++);
   fprintf(file_qc, format_label, "b_1_1_0", index_print_qc++);      
  }
  else {
   fprintf(file_tr, format_value, b_110);
   fprintf(file_qs, format_value, db_quad(1,1,0));
   fprintf(file_ql, format_value, db_ql(1,1,0));
   fprintf(file_qc, format_value, kappa_dot*db_qc(1,1,0));
  }
  // s 110
  if (ppt2->has_smart_dipole == _TRUE_) {
    if (index_tau==0) fprintf(file_tr, format_label, "s_1_1_0", index_print_tr++);
    else fprintf(file_tr, format_value, s_110);
  }
  // b 111
  if (m_max > 0) {
    if (index_tau==0) {
     fprintf(file_tr, format_label, "b_1_1_1", index_print_tr++);
     fprintf(file_qs, format_label, "b_1_1_1", index_print_qs++);
     fprintf(file_ql, format_label, "b_1_1_1", index_print_ql++);
     fprintf(file_qc, format_label, "b_1_1_1", index_print_qc++);      
    }
    else {
     fprintf(file_tr, format_value, b_111);
     fprintf(file_qs, format_value, db_quad(1,1,1));
     fprintf(file_ql, format_value, db_ql(1,1,1));
     fprintf(file_qc, format_value, kappa_dot*db_qc(1,1,1));
    }
  }
  // b 200
  if (index_tau==0) {
   fprintf(file_tr, format_label, "b_2_0_0", index_print_tr++);
   fprintf(file_qs, format_label, "b_2_0_0", index_print_qs++);
   fprintf(file_ql, format_label, "b_2_0_0", index_print_ql++);
  }
  else {
   fprintf(file_tr, format_value, b(2,0,0));
   fprintf(file_qs, format_value, db_quad(2,0,0));
   fprintf(file_ql, format_value, db_ql(2,0,0));
  }
  // b 22m
  for(m=0; m<=min(2,m_max); ++m) {
    sprintf(buffer, "b_2_2_%d", m);
    if (index_tau==0) {
     fprintf(file_tr, format_label, buffer, index_print_tr++);
      fprintf(file_qs, format_label, buffer, index_print_qs++);
      fprintf(file_ql, format_label, buffer, index_print_ql++);
    }
    else {
     fprintf(file_tr, format_value, b(2,2,m));
     fprintf(file_qs, format_value, db_quad(2,2,m));
     fprintf(file_ql, format_value, db_ql(2,2,m));
    }
  }
  
  
  // *** CDM evolved variables
  if (pba->has_cdm == _TRUE_ ) {
  
    // cdm 000
    if (index_tau==0) {
     fprintf(file_tr, format_label, "cdm_0_0_0", index_print_tr++);
     fprintf(file_qs, format_label, "cdm_0_0_0", index_print_qs++);
     fprintf(file_ql, format_label, "cdm_0_0_0", index_print_ql++);
    }
    else {
     fprintf(file_tr, format_value, cdm(0,0,0));
     fprintf(file_qs, format_value, dcdm_quad(0,0,0));
     fprintf(file_ql, format_value, dcdm_ql(0,0,0));
    }
    // cdm 11m
    for(m=0; m<=min(1,m_max); ++m) {
      sprintf(buffer, "cdm_1_1_%d", m);
      if (index_tau==0) {
       fprintf(file_tr, format_label, buffer, index_print_tr++);
       fprintf(file_qs, format_label, buffer, index_print_qs++);
       fprintf(file_ql, format_label, buffer, index_print_ql++);
      }
      else {
       fprintf(file_tr, format_value, cdm(1,1,m));
       fprintf(file_qs, format_value, dcdm_quad(1,1,m));
       fprintf(file_ql, format_value, dcdm_ql(1,1,m));
      }
    }
    // cdm 200
    if (index_tau==0) {
     fprintf(file_tr, format_label, "cdm_2_0_0", index_print_tr++);
     fprintf(file_qs, format_label, "cdm_2_0_0", index_print_qs++);
     fprintf(file_ql, format_label, "cdm_2_0_0", index_print_ql++);
    }
    else {
     fprintf(file_tr, format_value, cdm(2,0,0));
     fprintf(file_qs, format_value, dcdm_quad(2,0,0));
     fprintf(file_ql, format_value, dcdm_ql(2,0,0));
    }
    // cdm 22m
    for(m=0; m<=min(2,m_max); ++m) {
      sprintf(buffer, "cdm_2_2_%d", m);
      if (index_tau==0) {
       fprintf(file_tr, format_label, buffer, index_print_tr++);
       fprintf(file_qs, format_label, buffer, index_print_qs++);
       fprintf(file_ql, format_label, buffer, index_print_ql++);
      }
      else {
       fprintf(file_tr, format_value, cdm(2,2,m));
       fprintf(file_qs, format_value, dcdm_quad(2,2,m));
       fprintf(file_ql, format_value, dcdm_ql(2,2,m));
      }
    }
  
  } // end of if(has_cdm)
  
  
  
  // *** Photon temperature evolved variables
  int l_max_g = min(ppw2->l_max_g, ppt2->l_max_debug);
  
  for(l=0; l<=l_max_g; ++l) {
    for(m=0; m<=min(l,m_max); ++m) {
      sprintf(buffer, "I_%d_%d", l, m);
      if (index_tau==0) {
       fprintf(file_tr, format_label, buffer, index_print_tr++);
       fprintf(file_qs, format_label, buffer, index_print_qs++);
       fprintf(file_ql, format_label, buffer, index_print_ql++);
       fprintf(file_qc, format_label, buffer, index_print_qc++);
      }
      else {
       fprintf(file_tr, format_value, I(l,m));
       fprintf(file_qs, format_value, dI_ql(l,m) + kappa_dot*dI_qc(l,m));
       fprintf(file_ql, format_value, dI_ql(l,m));
       fprintf(file_qc, format_value, kappa_dot*dI_qc(l,m));
      }
    }
  }
  
  // *** Photon polarization evolved variables
  if (ppt2->has_polarization2 == _TRUE_) {
  
    int l_max_pol_g = min(ppw2->l_max_pol_g, ppt2->l_max_debug);
  
    // E-mode polarization
    for(l=2; l<=l_max_pol_g; ++l) {
      for(m=0; m<=min(l,m_max); ++m) {
        sprintf(buffer, "E_%d_%d", l, m);
        if (index_tau==0) {
         fprintf(file_tr, format_label, buffer, index_print_tr++);
         fprintf(file_qs, format_label, buffer, index_print_qs++);
         fprintf(file_ql, format_label, buffer, index_print_ql++);
         fprintf(file_qc, format_label, buffer, index_print_qc++);
        }
        else {
         fprintf(file_tr, format_value, E(l,m));
         fprintf(file_qs, format_value, dE_ql(l,m) + kappa_dot*dE_qc(l,m));
         fprintf(file_ql, format_value, dE_ql(l,m));
         fprintf(file_qc, format_value, kappa_dot*dE_qc(l,m));
        }
      }
    }
   
    // B-mode polarization
    for(l=2; l<=l_max_pol_g; ++l) {
      for(m=1; m<=min(l,m_max); ++m) {
        sprintf(buffer, "B_%d_%d", l, m);
        if (index_tau==0) {
         fprintf(file_tr, format_label, buffer, index_print_tr++);
         fprintf(file_qs, format_label, buffer, index_print_qs++);
         fprintf(file_ql, format_label, buffer, index_print_ql++);
         fprintf(file_qc, format_label, buffer, index_print_qc++);           
        }
        else {
         fprintf(file_tr, format_value, B(l,m));
         fprintf(file_qs, format_value, dB_ql(l,m) + kappa_dot*dB_qc(l,m));
         fprintf(file_ql, format_value, dB_ql(l,m));
         fprintf(file_qc, format_value, kappa_dot*dB_qc(l,m));
        }
      }
    }
   
  } // end of if(has_polarization2)
  
  
  
  // *** Neutrino evolved variables
  if (pba->has_ur == _TRUE_) {
  
    int l_max_ur = min(ppw2->l_max_ur, ppt2->l_max_debug);
  
    for(l=0; l<=l_max_ur; ++l) {
      for(m=0; m<=min(l,m_max); ++m) {
        sprintf(buffer, "N_%d_%d", l, m);
        if (index_tau==0) {
         fprintf(file_tr, format_label, buffer, index_print_tr++);
         fprintf(file_qs, format_label, buffer, index_print_qs++);
         fprintf(file_ql, format_label, buffer, index_print_ql++);
        }
        else {
         fprintf(file_tr, format_value, N(l,m));
         fprintf(file_qs, format_value, dN_ql(l,m));
         fprintf(file_ql, format_value, dN_ql(l,m));
        }
      }
    }
  }  // end of if(has_ur)
  
  
  
  // *** Some other random variables
  sprintf(buffer, "exp_m_kappa");
  if (index_tau==0)
   fprintf(file_tr, format_label, buffer, index_print_tr++);
  else
   fprintf(file_tr, format_value, pvecthermo[pth->index_th_exp_m_kappa]);
  
  sprintf(buffer, "g");
  if (index_tau==0)
   fprintf(file_tr, format_label, buffer, index_print_tr++);
  else
   fprintf(file_tr, format_value, pvecthermo[pth->index_th_g]);

  sprintf(buffer, "H");
  if (index_tau==0)
   fprintf(file_tr, format_label, buffer, index_print_tr++);
  else
   fprintf(file_tr, format_value, pvecback[pba->index_bg_H]);

  sprintf(buffer, "Hc");
  if (index_tau==0)
   fprintf(file_tr, format_label, buffer, index_print_tr++);
  else
   fprintf(file_tr, format_value, a*pvecback[pba->index_bg_H]);



  fprintf(file_tr, "\n");
  fprintf(file_qs, "\n");
  fprintf(file_ql, "\n");
  fprintf(file_qc, "\n");
  
  return _SUCCESS_;

}








int perturb2_quadratic_sources_at_tau(
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        double tau,
        struct perturb2_workspace * ppw2
        )
{
  
 
  /* Linear interpolation */
  if (ppt->quadsources_interpolation == linear_quadsources_interpolation) {

    class_call(perturb2_quadratic_sources_at_tau_linear(
              ppt,
              ppt2,
              tau,            
              ppw2
              ),
          ppt2->error_message,
          ppt2->error_message);

  }
  /* Cubic spline interpolation */
  else if (ppt->quadsources_interpolation == cubic_quadsources_interpolation) {

    class_call(perturb2_quadratic_sources_at_tau_cubic_spline(
              ppt,
              ppt2,
              tau,            
              ppw2
              ),
          ppt2->error_message,
          ppt2->error_message);

  } // end of if(ppt->quadsources_interpolation)
  
  
  return _SUCCESS_;
  
}



/**
  * Function that interpolates the quadratic sources at a time tau for a specific wavemode
  * set (index_k1, index_k2, index_cosk1k2), and for all types, using linear interpolation.
  *
  * This function assumes that the quadratic sources are stored in
  *
  *  - ppw2->metric_quadsources_table
  *  - ppw2->liouville_quadsources_table
  *  - ppw2->collision_quadsources_table
  *
  * and its purpose is to fill the following arrays:
  *
  *  - ppw2->pvec_metric_quadsources
  *  - ppw2->pvec_liouville_quadsources
  *  - ppw2->pvec_collision_quadsources
  *
  */
int perturb2_quadratic_sources_at_tau_linear(
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        double tau,
        struct perturb2_workspace * ppw2
        )
{


  /* First of all, test that we are not asking for a tau that is out of bounds */
  class_test (((tau>ppt->tau_sampling_quadsources[ppt->tau_size_quadsources-1]) || (tau<ppt->tau_sampling_quadsources[0])),
              ppt2->error_message,
              "you requested a time which is not contained in the interpolation table.");



  /* Index at the left of tau in ppt->tau_sampling_quadsources */
  int index_tau;
  
  /* Point at the right of tau */
  double tau_right;
  
  /* Interpolation weight associated to the point at the left of tau */
  double a;
  
  /* Step associated to the time sampling. Available only in lin_tau_sampling  and log_tau_sampling modes */
  double step;



  // ******   Find time index in the interpolation table   ******
  
  /* When the time-sampling is linear or logarithmic, we can obtain the position of tau
    in a straightforward way */
  if (ppt->has_custom_timesampling_for_quadsources == _TRUE_) {

    if (ppt->custom_tau_mode_quadsources == lin_tau_sampling) {
      step = ppt->custom_tau_step_quadsources;
      index_tau = (int)((tau - ppt->custom_tau_ini_quadsources)/step);
      tau_right = ppt->tau_sampling_quadsources[index_tau+1];
    }

    else if (ppt->custom_tau_mode_quadsources == log_tau_sampling) {
      double log_step = ppt->custom_tau_step_quadsources;
      index_tau = (int)((log(tau) - ppt->custom_log_tau_ini_quadsources)/log_step);
      tau_right = ppt->tau_sampling_quadsources[index_tau+1];
      step = tau_right - ppt->tau_sampling_quadsources[index_tau];
    }
  }
  /* For a general time-sampling, we resort to bisection */
  else {
    
    int inf = 0;
    int sup = ppt->tau_size_quadsources - 1;
    int mid, i;
    double * tau_vec = ppt->tau_sampling_quadsources;

    if (tau_vec[inf] < tau_vec[sup]){

      while (sup-inf > 1) {

        mid = (int)(0.5*(inf+sup));

        if (tau < tau_vec[mid])
          sup = mid;
        else
          inf = mid;
      }
    }
    else {
      while (sup-inf > 1) {

        mid = (int)(0.5*(inf+sup));

        if (tau > tau_vec[mid])
          sup = mid;
        else
          inf = mid;
      }
    }

    index_tau = mid-1;
    tau_right = tau_vec[index_tau+1];
    step = tau_right - tau_vec[index_tau];
    
    /* Some debug */
    // printf("tau=%g, tau_left[%d]=%g, tau_right=%g\n", tau, index_tau, ppt->tau_sampling_quadsources[index_tau], ppt->tau_sampling_quadsources[index_tau+1]);
    
  } // end of if(has_custom_timesampling_for_quadsources)
  
      
  /* Compute the weight associated to tau_right */
  a = (tau_right - tau)/step;


  // ******    Interpolate metric quadsources     ******

  int index_qm;
  
  /* Size of the output */
  int qm2_size = ppw2->qm2_size;
  
  /* Loop over types */
  for (index_qm=0; index_qm<qm2_size; ++index_qm) {

    /* Values of the function at the nodes around tau */
    double source_left = ppw2->metric_quadsources_table[index_qm][index_tau];
    double source_right = ppw2->metric_quadsources_table[index_qm][index_tau+1];
    
    /* Linear interpolation */
    ppw2->pvec_metric_quadsources[index_qm] = a*source_left + (1-a)*source_right;
    
    /* Some debug */
    // printf("a=%g, step=%g, source_left(%g[%d])=%g, source(%g)=%g, source_right(%g[%d])=%g\n",
    //   a, step,
    //   ppt->tau_sampling_quadsources[index_tau], index_tau, source_left,
    //   tau,ppw2->pvec_metric_quadsources[index_qm],
    //   ppt->tau_sampling_quadsources[index_tau+1], index_tau+1, source_right
    //   );
    
  }
  
  
  
  // ******    Interpolate Liouville quadsources     ******

  int index_ql;
  
  /* Size of the output */
  int ql2_size = ppw2->ql2_size;
  
  /* Loop over types */
  for (index_ql=0; index_ql<ql2_size; ++index_ql) {

    /* Values of the function at the nodes around tau */
    double source_left = ppw2->liouville_quadsources_table[index_ql][index_tau];
    double source_right = ppw2->liouville_quadsources_table[index_ql][index_tau+1];
    
    /* Linear interpolation */
    ppw2->pvec_liouville_quadsources[index_ql] = a*source_left + (1-a)*source_right;
    
    /* Some debug */
    // printf("a=%g, step=%g, source_left(%g[%d])=%g, source(%g)=%g, source_right(%g[%d])=%g\n",
    //   a, step,
    //   ppt->tau_sampling_quadsources[index_tau], index_tau, source_left,
    //   tau,ppw2->pvec_liouville_quadsources[index_ql],
    //   ppt->tau_sampling_quadsources[index_tau+1], index_tau+1, source_right
    //   );
        
  }
  
  
  // ******    Interpolate collisional quadsources     ******

  int index_qc;
  
  /* Size of the output */
  int qc2_size = ppw2->qc2_size;
  
  /* Loop over types */
  for (index_qc=0; index_qc<qc2_size; ++index_qc) {

    /* Values of the function at the nodes around tau */
    double source_left = ppw2->collision_quadsources_table[index_qc][index_tau];
    double source_right = ppw2->collision_quadsources_table[index_qc][index_tau+1];
    
    /* Linear interpolation */
    ppw2->pvec_collision_quadsources[index_qc] = a*source_left + (1-a)*source_right;
    
    /* Some debug */
    // if (index_qc == (ppw2->index_qc2_monopole_b+1))
    //   if (tau==1)
    //     printf("index_qc=%d, tau=%g, index_tau=%d, a=%g, step=%g, source_left(%g[%d])=%g, source(%g)=%g, source_right(%g[%d])=%g\n",
    //       index_qc, tau, index_tau, a, step,
    //       ppt->tau_sampling_quadsources[index_tau], index_tau, source_left,
    //       tau,ppw2->pvec_collision_quadsources[index_qc],
    //       ppt->tau_sampling_quadsources[index_tau+1], index_tau+1, source_right
    //       );
  
  }  
  
  return _SUCCESS_;
}







int perturb2_quadratic_sources_at_tau_cubic_spline(
        struct perturbs * ppt,
        struct perturbs2 * ppt2,
        double tau,
        struct perturb2_workspace * ppw2
        )
{
  
  int dump;
  
  class_call(spline_sources_interpolate_two_levels(
           ppt->tau_sampling_quadsources,
           ppt->tau_size_quadsources,
           ppw2->metric_quadsources_table,
           ppw2->dd_metric_quadsources_table,
           ppw2->qm2_size,
           tau,
           &dump,
           ppw2->pvec_metric_quadsources,
           ppw2->qm2_size,
           ppt2->error_message
           ),
        ppt2->error_message,
        ppt2->error_message);  

  class_call(spline_sources_interpolate_two_levels(
           ppt->tau_sampling_quadsources,
           ppt->tau_size_quadsources,
           ppw2->liouville_quadsources_table,
           ppw2->dd_liouville_quadsources_table,
           ppw2->ql2_size,
           tau,
           &dump,
           ppw2->pvec_liouville_quadsources,
           ppw2->ql2_size,
           ppt2->error_message
           ),
        ppt2->error_message,
        ppt2->error_message);  


  class_call(spline_sources_interpolate_two_levels(
           ppt->tau_sampling_quadsources,
           ppt->tau_size_quadsources,
           ppw2->collision_quadsources_table,
           ppw2->dd_collision_quadsources_table,
           ppw2->qc2_size,
           tau,
           &dump,
           ppw2->pvec_collision_quadsources,
           ppw2->qc2_size,
           ppt2->error_message
           ),
        ppt2->error_message,
        ppt2->error_message);  

  
  
  return _SUCCESS_; 
  
}



/**
  * Load the line of sight sources from disk for a given k1 value. The sources will be read from the file
  * given in ppt2->sources_run_paths[index_k1].
  *
  * This function is used in the transfer2.c module.
  *
  */
int perturb2_load_sources_from_disk(
        struct perturbs2 * ppt2,
        int index_k1
        )
{
 
  
  /* Allocate memory to keep the line-of-sight sources */
  class_call (perturb2_allocate_k1_level(ppt2, index_k1), ppt2->error_message, ppt2->error_message);
  
  /* Running indexes */
  int index_type, index_k2, index_cosk1k2;

  /* Open file for reading */
  class_open (ppt2->sources_run_files[index_k1], ppt2->sources_run_paths[index_k1], "rb", ppt2->error_message);

  /* Print some debug */
  if (ppt2->perturbations2_verbose > 2)
    printf("    * reading line-of-sight source for index_k1=%d from '%s' ... ", index_k1, ppt2->sources_run_paths[index_k1]);
  
  for (index_type = 0; index_type < ppt2->tp2_size; ++index_type) {
  
    for (index_k2 = index_k1; index_k2 < ppt2->k_size; ++index_k2) {

      for (index_cosk1k2 = 0; index_cosk1k2 < ppt2->cosk1k2_size; ++index_cosk1k2) { 

        int n_read = fread(
              ppt2->sources[index_type][index_k1][index_k2-index_k1][index_cosk1k2],
              sizeof(double),
              ppt2->tau_size,
              ppt2->sources_run_files[index_k1]);

        /* Read a chunk with all the time values for this set of (type,k1,k2,cosk1k2) */
        class_test( n_read != ppt2->tau_size,
          ppt2->error_message,
          "Could not read in '%s' file, read %d entries but expected %d",
          ppt2->sources_run_paths[index_k1], n_read, ppt2->tau_size);

        /* Update the counter for the values stored in ppt2->sources */
        #pragma omp atomic
        ppt2->count_memorized_sources += ppt2->tau_size;

      }  // end of for(index_cosk1k2)

    } // end of for(index_k2)
    
  } // end of for(index_type)
  
  /* Close file */
  fclose(ppt2->sources_run_files[index_k1]);
  
  if (ppt2->perturbations2_verbose > 1)
    printf ("Done.\n");
  
  return _SUCCESS_; 
  
}





/**
  * Save the line of sight sources to disk for a given k1 value. The file were the sources will be saved
  * is given by ppt2->sources_run_paths[index_k1].
  */
int perturb2_save_sources_to_disk(
        struct perturbs2 * ppt2,
        int index_k1
        )
{

  /* Open file for writing */
  class_open (ppt2->sources_run_files[index_k1], ppt2->sources_run_paths[index_k1], "wb", ppt2->error_message);

  /* Running indexes */
  int index_type, index_k2, index_cosk1k2;

  /* Print some debug */
  if (ppt2->perturbations2_verbose > 1)
    printf("    * run_storage: writing results for index_k1=%d on '%s'\n", index_k1, ppt2->sources_run_paths[index_k1]);
  
  for (index_type = 0; index_type < ppt2->tp2_size; ++index_type) {
  
    for (index_k2 = index_k1; index_k2 < ppt2->k_size; ++index_k2) {

      for (index_cosk1k2 = 0; index_cosk1k2 < ppt2->cosk1k2_size; ++index_cosk1k2) { 

        /* Write a chunk with all the time values for this set of (type,k1,k2,cosk1k2) */
        fwrite(
              ppt2->sources[index_type][index_k1][index_k2-index_k1][index_cosk1k2],
              sizeof(double),
              ppt2->tau_size,
              ppt2->sources_run_files[index_k1]
              );

      }  // end of for(index_cosk1k2)

    } // end of for(index_k2)
    
  } // end of for(index_type)
  
  /* Close file */
  fclose(ppt2->sources_run_files[index_k1]);
    
  /* Write information on the status file */
  // class_open (ppt2->sources_status_file, ppt2->sources_status_path, "a+b", ppt2->error_message);
    
  return _SUCCESS_; 
  
}
  
  
  



/**
  * Allocate the k1 level of the array ppt2->sources[index_type][index_k1][index_k2][index_cosk1k2][index_tau].
  * This function must be called after the functions perturb2_indices_of_perturbs and perturb2_get_k_lists, and
  * after the ppt2->tau_size field have been filled.
  *
  */
int perturb2_allocate_k1_level(
     struct perturbs2 * ppt2,
     int index_k1
     )
{


  /* Issue an error if ppt2->sources[index_k1] has already been allocated */
  class_test (ppt2->has_allocated_sources[index_k1] == _TRUE_,
              ppt2->error_message,
              "the index_k1=%d level of ppt2->sources is already allocated, stop to prevent error", index_k1);


  int index_k2, index_cosk1k2, index_type, count=0;
  
  for (index_type = 0; index_type < ppt2->tp2_size; index_type++) {

    /* Allocate k2 level.  Note that the size of this level is smaller than ppt2->k_size,
      and depends on k1.  The reason is that we shall solve the system only for those k2's
      that are larger than k1 (our equations are symmetrized wrt to k1<->k2) */
    int k2_size = ppt2->k_size - index_k1;

    class_alloc(
      ppt2->sources[index_type][index_k1],
      k2_size * sizeof(double **),
      ppt2->error_message);

    for(index_k2 = 0; index_k2 < k2_size; ++index_k2) {

      /* Allocate cosk1k2 level */
      class_alloc(
        ppt2->sources[index_type][index_k1][index_k2],
        ppt2->cosk1k2_size * sizeof(double *),
        ppt2->error_message);

      for(index_cosk1k2 = 0; index_cosk1k2 < ppt2->cosk1k2_size; ++index_cosk1k2) {

        /* Allocate time level */
        class_alloc(
          ppt2->sources[index_type][index_k1][index_k2][index_cosk1k2],
          (ppt2->tau_size) * sizeof(double),
          ppt2->error_message);
    
        #pragma omp atomic
        ppt2->count_allocated_sources += ppt2->tau_size;
        count += ppt2->tau_size;

      } // end of for(index_cosk1k2)
    } // end of for(index_k2)
  } // end of for(index_type)

  /* Print some debug information on memory consumption */
  if (ppt2->perturbations2_verbose > 2)
    printf(" -> allocated ~ %.3g MB (%d doubles) for index_k1=%d; the size of ptr2->sources so far is ~ %.3g MB;\n",
      count*sizeof(double)/1e6, count, index_k1, ppt2->count_allocated_sources*sizeof(double)/1e6);

  /* We succesfully allocated the k1 level of ppt2->sources */
  ppt2->has_allocated_sources[index_k1] = _TRUE_;


  return _SUCCESS_;

}







int perturb2_free_k1_level(
     struct perturbs2 * ppt2,
     int index_k1
     )
{

  /* Issue an error if ppt2->sources[index_k1] has already been freed */
  class_test (ppt2->has_allocated_sources[index_k1] == _FALSE_,
              ppt2->error_message,
              "the index_k1=%d level of ppt2->sources is already free, stop to prevent error", index_k1);

  int index_type, index_k2, index_cosk1k2;

  int k1_size = ppt2->k_size;

  for (index_type = 0; index_type < ppt2->tp2_size; index_type++) {

    int k2_size = k1_size - index_k1;

    for (index_k2 = 0; index_k2 < k2_size; index_k2++) {
    
      for (index_cosk1k2 = 0; index_cosk1k2 < ppt2->cosk1k2_size; index_cosk1k2++) {

        free(ppt2->sources[index_type][index_k1][index_k2][index_cosk1k2]);
    
      } // end of for(index_cosk1k2)
    
      free(ppt2->sources[index_type][index_k1][index_k2]);
    
    } // end of for(index_k2)
  
    free(ppt2->sources[index_type][index_k1]);
  
  } // end of for(index_type)


  /* We succesfully freed the k1 level of ppt2->sources */
  ppt2->has_allocated_sources[index_k1] = _FALSE_;

  return _SUCCESS_;

